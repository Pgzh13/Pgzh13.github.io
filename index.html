<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-计算机网络—网络层" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/" class="article-date">
  <time class="dt-published" datetime="2021-05-20T13:00:51.792Z" itemprop="datePublished">2021-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络——网络层</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="#计算机网络"></a>#计算机网络</h2><h2 id="网络层"><a href="#网络层" class="headerlink" title="##网络层"></a>##网络层</h2><p>###基本概念</p>
<pre><code>--说明：主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务；传输单位是数据报

--功能：
    a.路由选择和分组转发
    b.异构网络互联
    c.拥塞控制

--基础概念：
    a.数据报：网络层的传输单位

    b.分组：把大的数据块分割成小的数据块

    c.报文：源应用发送的信息整体</code></pre>
<p>###数据交换</p>
<pre><code>--电路交换：
    a.特点：
        1-独占资源
    b.优点
        1-通信时延小
        2-有序传输
        3-没有冲突
        4-实时性强
    c.缺点：
        1-建立连接时间长
        2-线路独占，使用效率低
        3-灵活性差
        4-无差错控制能力

--报文交换：
    a.报文：源应用发送的信息整体
    b.优点：
        1-无需建立连接
        2-存储转发，动态分配线路
        3-线路可靠性较高
        4-线路利用率较高
        5-多目标服务
    c.缺点：
        1-有存储转发时延
        2-报文大小补丁，需要网络节点有较大缓存空间

--分组交换：
    a.优点：
        1-无需建立连接
        2-存储转发，动态分配线路
        3-线路可靠性较高
        4-线路利用率较高
        5-相对于报文交换，存储管理更容易
    b.缺点：
        1-有存储转发时延
        2-需要传输额外的信息量
        3-乱序到目的主机时，要对分组排序重组
    c.方式：
        1-数据报方式：
            （1）说明：数据报方式为网络层提供无连接服务
            （2）特点：
                --无连接
                --每个分组携带源和目的地址 
                --路由器根据分组的目的地址转发分组：基于路由协议/算法构建转发表；检索转发表；每个分组独立选路

        2-虚电路方式
            （1）说明：一条源主机到目的主机类似于电路的路径(逻辑链接)，路径上所有结点都要维持这条虚电路的建立，都维持一张虚电路表，每一项记录了一个打开的虚电路的信息；为网络层提供连接服务，将数据报方式和电路交换方式结合</code></pre>
<p>###路由算法</p>
<pre><code>--静态路由算法(非自适应路由算法)：管理员手工配置路由信息
    a.特点：
        简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好；
        路由更新慢，不适用大型网络；

--动态路由算法(自适应路由算法)：路由器间彼此交换信息，按照路由算法优化出路由表项
    a.特点：
        路由更新快，使用大型网络，及时响应链路费用或网络拓扑变化；
        算法复杂，增加网络负担；

    b.分类：
        1-全局性：
            链路状态路由算法OSPF：所有路由器掌握完整的网络拓扑和链路费用信息
        2-分散性：
            距离向量路由算法RIP：路由器只掌握物理相连的邻居及链路费用

--分层次的路由选择协议：
    &lt;!-- 自治系统AS：
        在单一的技术管理下的一组路由器，而这写路由器使用一中AS内部的路由选择协议和共同的度量以确定分组在该AS的路由，同时还是用一种AS之间的路由协议以确定在AS之间的路由；一个AS内所有网络都属于一个行政单位管辖，一个自治系统的所有路由器在本自治系统内都必须连通
     --&gt;
     a.内部网关协议IGP：一个AS内使用的 RIP\OSPF
     b.外部网关协议EGP：AS之间使用的BGP</code></pre>
<p>###IP数据报</p>
<pre><code>--格式：
    a.首部：
        1-固定首部(20B):
            版本号：IPV4/IPV6
            首部长度：单位是4B，最小为5
            区分服务：指示期望获得哪种类型的服务
            总长度：首部+数据，单位是1B
            标识：同一数据报的分片使用同一标识
            标志：只有2位有意义
                &lt;!-- 
                    中间位DF：为1禁止分片，为0允许分片
                    最低位MF：为1，意味着后面还有分片，0则代表最后一片/没分片 --&gt;
            片偏移：指出较长分组分片后，某片在原分组中的相对位置。以8B为单位
            生存时间TTL：IP分组的保质期。经过一个路由器-1，至0则丢弃
            协议：数据部分的协议
            首部检验和：只检验首部
            源地址
            目的地址
        2-可变部分：
            可选字段(长度可变)：可选0-40B，用来支持排错、测量以及安全等措施
            填充字段：全0，把首部补充4B的整数倍
    b.数据部分

--最大传送单位MTU：
    a.说明：链路层数据帧可封装数据的上限</code></pre>
<p>###IPV4地址</p>
<pre><code>--IP地址：
    a.说明：全世界唯一的32位/4字节标识符，标识路由器主机的接口
    b.格式：&#123;&lt;网络号&gt;&lt;主机号&gt;&#125;

--分类IP地址：
    a. A类：
        1-地址范围：10.0.0.0~10.255.255.255
        2-网段个数：1

    b. B类：
        1-地址范围：172.16.0.0~172.31.255.255
        2-网段个数：16

    c. C类：
        1-地址范围：192.168.0.0~192.168.255.255
        2-网段个数：256

--网络地址转换NAT:
    &lt;!-- 路由器对目的地址是私有IP地址的数据报一律不进行转发 --&gt;
    a.说明：在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个有效的外部全球IP地址
        &lt;!-- 在NAT转换表上包括了一个本地网断LAN和一个外网端WAN --&gt;
    b.缺点：
        1-IP地址空间的利用率有时很低
        2-两级IP地址不够灵活

--子网划分：
    a.说明：三级的IP地址&#123;&lt;网络号&gt;&lt;子网号&gt;&lt;主机号&gt;&#125;
    b.子网掩码：网络号全1，主机号全0
    c.路由表：
        1-目的网络地址
        2-目的网络的子网掩码
        3-下一跳地址
    d.路由器转发分组的算法：
        1-提取目的IP地址
        2-是否直接交付
        3-特定主机路由
        4-检测路由表中有无路径：与路由表中的目的网络子网掩码相与
        5-默认路由0.0.0.0
        6-丢弃，报告转发分组出错

--无分类编址CIDR：
    a.格式：IP地址后加上&quot;/&quot;，然后写上网络前缀(可以任意长度)的位数 
    b.子网掩码：网络前缀位数全为1，主机号全为0

--ARP协议：
    a.说明：完成主机或路由器IP地址到MAC地址的映射
    b.使用过程：
        检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为FF-FF-FF-FF-FF-FF的帧封装并广播ARP请求信号，同一个局域网中所有主机都能收到该请求。目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存(10-20min更新一次)
    c.典型情况：
        1-主机A发给本网络上的主机B：用ARP找到主机B的硬件地址
        2-主机A发给另一网络的主机B：用ARP找到本网络上一个路由器(网关)的硬件地址
        3-路由器给本网络的主机A：用ARP找到主机A的硬件地址
        4-路由器发给另一网络的主机B：用ARP找到本网络上的一个路由器的硬件地址

--DHCP协议：
    a.说明：动态主机配置协议DHCP是应用层协议，使用客户/服务器方式，客户端和服务端通过广播的方式进行交互，基于UDP；其提供即插即用联网的机制，主机可以从服务器动态获取IP地址、子网掩码、默认网关、DNS服务器名称与IP地址，允许地址重用，支持移动用户加入网络，支持在用地址续租
    b.步骤：
        1-主机广播DHCP发现报文
        2-DHCP服务器广播DHCP提供报文
        3-主机广播DHCP请求报文
        4-DHCP服务器广播DHCP确认报文

--ICMP协议：
    a.说明：网际控制报文协议，支持路由器或主机
    b.分类：
        1-ICMP差错报告报文：
            （1）终点不可达：报文无法交付
            （2）源点抑制：拥塞丢数据
            （3）时间超过：生存时间TTL=0
            （4）参数问题：首部字段存在问题
            （5）改变路由(重定向)：选择更好路径
            &lt;!-- 
                不适用情况：
                1-ICMP差错报告报文本身
                2-第一个分片的数据报片的后续所有后续数据报片
                3-具有组播地址的数据报
                4-具有特殊地址(如127.0.0.0或0.0.0.0) 
            --&gt;
        2-ICMP询问报文：
            （1）回送请求和回答报文：收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文；用来测试目的站是否可达以及了解相关状态
            （2）时钟戳请求和回答报文：请求某个主机或路由器回答当前的日期和时间；用来进行时钟同步和测量时间

    c.应用：
        1-PING：测试两个主机之间的连通性，实用了ICMP回送请求和回答报文
        2-Traceroute：跟踪一个分组从源点到终点的路径没使用了ICMP时间超过差错报告报文</code></pre>
<p>###IPV6</p>
<pre><code>--IPV6数据包格式：
    ![Image text](./image/IPV6.jpg)</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/" data-id="ckp27pssk000cn8ub34v3fhim" data-title="计算机网络——网络层" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机网络—数据链路层" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" class="article-date">
  <time class="dt-published" datetime="2021-05-14T12:35:57.564Z" itemprop="datePublished">2021-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">计算机网络——数据链路层</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="#计算机网络"></a>#计算机网络</h2><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="##数据链路层"></a>##数据链路层</h2><p>###基本概念</p>
<pre><code>数据链路层：
    --结点：主机、路由器
    --链路：网络中两个结点之间的物理通道
    --数据链路：网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路
    --帧：链路层的协议数据单元，封装网络层数据报

    --说明：
        在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路

    --功能：
        --为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务
        --链路管理，即连接的建立、维持、释放(用于面向连接的服务)
        --组帧
        --流量控制
        --差错控制

局域网：
    --说明：简称LAN(Local Area NetWork)，是指在某一区域内由多台计算机互联成的计算机组，使用广播信道

    --特点：
        a.覆盖的地理范围较小，只在一个相对独立的局部范围内联
        b.使用专门铺设的传输介质进行联网，数据传输速率高
        c.通信延迟时间短，误码率低，可靠性高
        d.各重站点关系平等，共享传输信道
        e.采用分布式控制和广播式通信，能进行广播和组播

    --决定因素：
        a.网络拓扑
            1-星型拓扑
            2-总线拓扑
            3-环形拓扑
            4-树形拓扑
        b.传输介质
        c.介质访问控制方法
            1-CSMA/CD：常用于总线型局域网，也用于属性网络
            2-令牌总线：同上
            3-令牌环：用于环形局域网，如令牌环网

    --分类：
        a.以太网：逻辑总线，物理星型或拓展星型，使用CSMA/CD，符合IEEE802.3系列标准规范
            &lt;!-- 
                802.3：以太网介质访问控制协议(CSMA/CD)及物理层技术规范
                802.5：令牌环网的介质访问控制协议
                802.8：光线技术咨询组，提供有关光纤联网的技术咨询
                802.11：无线局域网的介质访问控制协议以及物理层技术规范
                     MAC帧头（WDS无线分布式系统）：
                         帧控制(2) 生存周期ID(2) 地址1接收端RA(6) 地址2发送端RA(6) 地址3目的地址DA(6) 序列控制(2) 地址4源地址SA(6)
            --&gt;
            1-特点：只实现无差错接收，不实现可靠传输，差错帧直接丢弃，差错纠正由高层负责
            2-组成：
                （1）适配器：计算机与外界有局域网的连接式通过通信适配器
                    &lt;!-- MAC地址：每一个适配器有一个全球唯一的48位二进制地址，前24位代表厂家(由IEEE规定)，后24位厂家自己指定 --&gt;
            3-高速以太网：速率&gt;=100Mb/s的以太网称为高速以太网
                （1）100BASE-T以太网：
                        在双绞线上传送100Mb/s基带信号的星型拓扑以太网，仍使用IEEE802.3的CSMA/CD协议，支持全双工和半双工，可在全双工方式下工作而无冲突
                （2）吉比特以太网：
                        在光纤或双绞线上传送1GB/s信号，支持全双工和半双工，可在全双工方式下工作而无冲突
                （3）10吉比特：
                        10吉比特以太网在光纤上传送10Gb/s信号，支持全双工，无争用问题

        b.令牌环网：物理双环，逻辑环型
        c.FDDI网：物理双环，逻辑环型
        d.ATM网：较新型的单元交换技术，使用53字节固定长度的单元进行交换
        e.无线局域网(WLAN)：符合IEEE802.11标准规范

广域网
    --说明：简称(WAN，Wide Area NetWork)，通常跨接很大的物理范围，广域网的通信子网主要使用分组交换技术，将分布在不同地区的局域网或计算机系统互连起来，达到资源共享的目的</code></pre>
<p>###封装成帧&amp;透明传输</p>
<pre><code>说明：
    就是在一段数据的前后部分添加首部和尾部，这样就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束
    &lt;!-- 
        首部尾部的作用：
            a.帧定界(确定帧的界限)
            b.帧同步：接收方应当能从接收到的二进制比特流中区分出帧的起始和终止
    --&gt;

方法：
    --字符计数法：
        帧首部使用一个计数字段(第一个字节，8位)来表明帧内字符数

    --字符填充法：
        使用SOH作为首部，EOT作为尾部，判断帧的开始和结束；
        当传送的帧是文本文件组成，因为文本文件的字符都是ASCII码，是从键盘中输入的不会和首尾部控制信息发生冲突，即透明传输
        当传送的帧是非ASCII码的文本文件组成时，要采用字符软冲方法实现透明传输，在其中进行字符填充

    --零比特填充法：
        在发送端遇到五个一添加一个0，接收端反之；
        在传送的比特流中可以传送任意比特组合，而不会引起对帧边界的判读错误，保证了透明传输

    --违规编码法：
        通过“高-高”，“低-低”来定界帧的起始和终止

透明传输：
    --说明：是指不管所传数据是什么样的比特组合，都应当能够在链路层上传送；</code></pre>
<p>###差错控制</p>
<pre><code>起因：
    --随机热噪声
    --冲击噪声

位错：比特位出错，其针对的是一组比特，而物理层的编码针对的是单个比特
    --检错编码：
        a.奇偶校验码：由1位校验元和n-1位信息元构成，只能检查出奇数个比特错误，检错能力是50%
        b.循环冗余码CRC：
            发送端的数据由发送的数据和帧检验序列(冗余码/FCS)构成
                &lt;!-- 
                    冗余码的计算：
                        1-加0：假设生成的多项式G(x)的阶为r,则加r个0 
                        2-模2除法：数据加0后除以多项式，余数则为冗余码
                --&gt;
            接收端则判断该帧除以同样的除数，余数是否为0，是则没问题，否则存在差错，则丢弃；
            FCS的生成以及接收端CRC检验都是由硬件实现，不会延误数据的传输
    --纠错编码
        a.海明码：发现双比特错，纠正单比特错
            1-确定校验码位数：
                &lt;!-- 海明不等式：2的r次方&gt;=k+r+1，r为冗余信息位，k为信息位--&gt;
            2-确定校验码和数据的位置
            3-求出校验码的值
            4-检错并纠错
帧错：
    --丢失
    --重复
    --失序 </code></pre>
<p>###流量控制&amp;可靠传输机制</p>
<pre><code>&lt;!-- 其与传输层流量控制的区别：
        链路层的流量控制是点对点的，传输层的流量控制是端到端的；
        数据链路层流量控制的手段：接收方瘦不下就不回复确认 ，而传输层是通过接收端给发送端一个窗口公告
--&gt;

说明：控制发送速率，使接收方有足够的缓冲空间来接受每一个帧

方法：
    --停止-等待协议：每发送完一个帧就停止发送，等待对方确认，在收到确认后再发送下一个帧；发送串口大小=1，接收窗口大小=1；实现简单，但是信道利用率低

        &lt;!-- 信道利用率：发送方在一个发送周期内，有效的地发送数据所需要地时间栈整个发送周期的比率
                        信道利用率 = (L/C)/T ---&gt;T发送周期(从开始发送数据，到收到第一个确认帧为止)，L指T内发送L比特数据，C发送方数据传输率
                        信道吞吐率 = 信道利用率*发送方的发送速率
        --&gt;

        a.无差错情况：
            每发送1个数据帧就停止等待，等待接收帧发送回来的ACK信号，用1bit进行编号

        b.有差错情况：
            1-数据帧丢失或检测到帧出错
                通过设置一个超时计时器，每次发送一个帧就启动一个计时器，当在规定时间内没有接受到确认信号，就进行自动重传
                &lt;!-- 
                    注：
                        1-发送完一个帧后，必须保留其副本
                        2-数据帧和确认帧必须编号 
                --&gt;
            2-ACK丢失：同样设置超时计时器，接收方在接收到重新发送的数据帧，将丢弃掉刚开始接收到的数据帧
            3-ACK迟到：对于晚到的确认帧，接收后丢弃

    --滑动窗口协议：能够进行流量控制，同时进行可靠传输(发送方自动重传)
        a.后退N帧协议(GBN)：
            1-说明：
                （1）发送窗口大小&gt;1，接收窗口大小=1
                    &lt;!-- 
                        滑动窗口长度：
                            若采用n个比特对帧编号，那么发送窗口的尺寸W应满足：1&lt;=W&lt;=2的n次方-1
                            发送窗口过大，会使得接收方无法区别新旧帧 
                    --&gt;

            2-步骤：
                发送方：
                （1）上层调用：
                        上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送；如果窗口已满，发送方只需将数据返回给上层，暗示上层窗口已满。上层等待后再发生(实际上，发送方可以缓存这些数据，窗口不满时再发送帧)
                （2）收到一个ACK：
                        对n号帧的确认采用累计确认的方式，标明接收方已经收到n号帧和它之前的全部帧
                （3）超时事件：
                        协议的名字为后退N帧/回退N帧，来源于出现丢失帧和时延过长时发送方的行为，就像在停等协议中一样，定时器价将在此用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送单未被确认的帧

                接收方：
                    如果正确收到n号帧，并且按序，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层；其余情况都丢弃帧，并未最近按序接收的帧重新发送ACK，接收方无需缓存任何失序帧，只需要维护一个信息：expectedseqnum(下一个按序接收的帧序号)

        b.选择重传协议(SR)
            1-说明：
                （1）发送窗口大小&gt;1，接收窗口大小&gt;1
                    &lt;!-- 
                        注：发送窗口最好等于接收窗口 = 2的n-1次方
                    --&gt;
            2-步骤：
                发送方：
                （1）上层调用：
                        从上层收到数据后，SR发送方检查下一个可用于该帧地序号，如果序号位于发送窗口内，则发送数据帧；否则就像GBN一样，要么将数据缓存，要么返回给上层之后再传输
                （2）收到一个ACK：
                        如果收到ACK，加入该帧序号在窗口，则SR发送方将那个被确认的帧标记为已接收。如果该帧序号是窗口的下界(最左边第一个窗口对应的序号)，则窗口向前移动到具有最小序号的未确认帧处，如果窗口移动了并且有序号在窗口内的未发送帧，则发送这些帧
                （3）超时事件：每个帧都有自己的定时器，一个超时事件发生后只重传一个帧

                接收方：
                    将确认一个正确接受的帧而不管其是否按序，失序的帧将被缓存，并返回给发送方一个该帧的确认帧，直到所有帧(即序号更小的帧)皆被收到为止，这时才可以将一批帧按序交付给上层，然后向前移动滑动窗口；如果收到了窗口序号外(小于窗口下界)的帧，就返回一个ACK</code></pre>
<p>###信道划分介质访问控制            </p>
<pre><code>传输数据使用链路：
    --点对点链路：
        a.说明：两个相邻节点通过一个链路相连，没有第三者
        b.应用：PPP协议，常用于广域网

    --广播式链路：
        a.说明：所有主机共享通信介质
        b.应用：早期的总线以太网、无线局域网，常用于局域网

说明：采取一定的措施，使得两队节点之间的通信不会发生互相干扰的情况

方式：
    --静态划分信道：
        a.信道划分介质访问控制(MAC)：将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域饥饿频域资源合理地分配给网上的设备，在网络负载重时，共享信道效率高，且公平，在负载轻时，则共享信道效率较低
            &lt;!-- 
                多路复用技术：把多个信号组合在一条物理信道上进行传输，使得多个计算机或终端设备共享信道资源，提高信道利用率
             --&gt;
            1-频分多路复用FDN：
                （1）说明：
                    用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带，频分复用地所有用户在同样的时间占用不同的带宽(频率带宽)资源
                （2）优点：
                    充分利用传输介质带宽，系统效率较高，实现比较容易
            2-时分多路复用TDM
                （1）说明：将时间划分为一段段等长地时分复用帧(TDM)，每一个时分复用地用户在每一个TMD帧中占用固定序号的时隙，所有用户轮流占用信道
                    &lt;!-- TDM帧是在物理层传送的比特流所划分的帧，标志一个周期 --&gt;
            3-波分多路复用WDM
                （1）说明：就是指光的频分多路复用，在光纤中传输多种不同波长的光信号，根据波长不同，各路光信号互不干扰，通过波长分解复用器将各路波长分解出来
            4-码分多路复用CDM

    --动态划分信道：动态媒体接入控制\多点接入，信道并非在用户通信时固定分配给用户
        a.轮询访问介质访问控制：
            1-令牌传递协议：每个结点都可以在一定的时间内获得发送数据的权力，并不是无限地持有令牌
                &lt;!-- 
                    令牌：一个特殊格式的MAC空指帧，不含任何信息，控制信道的使用，确保同一时刻只有一个结点独占信道；令牌环网无碰撞
                --&gt;
                a.问题：
                    1-令牌开销
                    2-等待延迟
                    3-单点故障
                b.应用：应用于令牌环网(物理星型拓扑，逻辑环形拓扑)，常用于负载较重、通信量较大的网络中

            2-轮询协议：星型拓扑的方式，主结点进行挨个询问

        b.随机访问介质访问控制
            1-ALOHA协议
                a.纯ALOHA协议：不监听信道，不按时间槽发送，随机发送；发生冲突，接收方就会检测出差错，然后不确认，发送方在一定时间内收不到就判断发生冲突，在超时后等一随机时间再重传
                b.时隙ALOHA协议：把时间分成若干个时间片，所有用户在时间片开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送
            2-CSMA协议
                （1）说明：载波监听多路访问协议，在发送帧之前，监听信道
                    &lt;!-- 
                        CS：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据
                        MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上(总线型网络)
                     --&gt;
                （2）方法：
                    1-- 1-坚持CSMA思想：空闲传输，忙则等待，如果有冲突，则等待一个随机长的时间再监听，重复上述过程。
                        特点：
                            避免了媒体利用率的损失；
                            如果有两个或以上的站点有数据要发送，冲突不可避免
                    2--非坚持CSMA：空闲传输，忙则等待一个随机事件之后再进行监听
                        特点：
                            采用随机的重发延迟时间可以减少冲突发生的可能性；
                            可能存在大家都在延迟等待过程中，使得媒体仍可能处于空闲状态，媒体使用率降低
                    3-- p-坚持CSMA：
                        指的是监听信道空闲的处理；如果一个主机要发送消息，那么它先监听信道，空闲则以p概率直接传输，不必等待；概率1-p等待到下一个时间槽再传输
                        特点：
                            能够减少冲突，同时减少媒体空闲时间；
                            发生冲突后还是要坚持把数据帧发送完，造成了浪费；

            3-CSMA/CD协议
                    &lt;!-- 
                        CS：载波侦听/监听，每一个站在发送数据之前要检测一下总线上是否有其他计算机在发送数据
                        MA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上
                        CD： 碰撞检测(冲突检测)，“边发送边监听”，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据(半双工网络)
                    --&gt;
                （1）说明：载波监听多点接入/碰撞检测
                （2）特性：
                        确定碰撞后的重传时机：使用截断二进制指数规避算法
                        最小帧长：帧的传输时延至少要两倍于信号在总线中的传播时延(总线传播时延*数据传输速率*2)

            4-CSMA/CA协议
                （1）说明：载波监听多点接入/碰撞避免
                （2）工作原理：
                        --发送数据前，先检测信道是否空闲，空闲则发出(RTS，request to send)，RTS包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息；信道忙则等待
                        --接收端收到RTS后，将响应CTS(clear to send)
                        --发送端收到CTS后，开始发送数据帧(同时预约信道：发送方告知其他站点自己要传送多久数据)
                        --接收端收到数据帧后，将用CRC来检验数据是否正确，正确则相应ACK帧
                        --发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数位置(采用二进制数退避算法来确定随机的推迟时间)

                （3）应用：无线局域网</code></pre>
<p>###PPP协议(点对点协议Ponint-to-Point Protocol)</p>
<pre><code>--说明：是目前使用最广泛的数据链路层协议，只支持全双工链路
--要求：
    a.简单：对于链路层的帧，无需纠错，无需序号，无需流量控制
    b.封装成帧
    c.透明传输
    d.多种网络层协议：封装的IP数据报可以采用多种协议
    e.多种类型链路
    f.差错检测：错误就丢弃
    g.检测连接状态
    h.最大传送单元
    i.网络层地址协商：知道通信双方的网络层地址
    j.数据压缩协商

--组成：
    a.将一个IP数据报封装导串行链路的方法
    b.链路控制协议LCP：建立并维护数据链路连接(身份验证)
    c.网络控制协议NCP：PPP支持多种网络协议，每个不同的网络层协议都要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接

--HDLC协议：
    a.说明：高级数据链路控制，是一个在同步网上传输数据、面向比特的数据链路层协议

    b.组成：
        1-主站：发送命令(包括数据信息)帧、接收响应帧，并负责对整个链路的控制系统的初启、流程的控制、差错检测或恢复等
        2-从站：接收由主站发来的命令帧，向主站发送响应帧，并且配合主站参与差错恢复等链路控制
        3-复合站：技能发送，有能接收命令帧和响应帧，并且负责整个链路的控制

    c.数据响应方式：
        1-正常响应方式
        2-异步平衡方式
        3-异步响应方式

    d.帧的分类
        1-信号帧：第1位为0，用来传输数据信息，或使用捎带技术对数据进行确认
        2-监督帧10，用于流量控制和差错控制，执行对信息帧的确认、请求重发和请求暂停发送等功能
        3-无编号帧11，用于提供对链路的建立、拆除等多种控制功能</code></pre>
<p>###链路层设备</p>
<pre><code>网桥：
    --说明：连接着网段，根据MAC帧的目的地址对帧进行转发和过滤。当网桥收到一个帧时，并不向所有接口转发此帧，而是先检查此帧的目的MAC地址，然后再确定将该帧转发发到指定接口，或者是把它丢弃
        &lt;!-- 网段：一般指一个计算机网络中使用同一物理层设备(传输介质，中继器，集线器等)能够直接通讯的那一部分 --&gt;

    --分类：
        a.透明网桥：“透明”指以太网上的站点并不知道所发送的帧将警告哪几个网桥，是一种即插即用设备--自学习
        b.源路由网桥：在发送帧时，把详细的最佳路由信息(路由最少/时间最短)放在帧的首部中
            &lt;!-- 方法：源站以广播方式向欲通信的目的站发送一个发现帧 --&gt;

    --优点：
        a.过滤通信量，增大吞吐量
        b.扩大了物理范围
        c.提高了可靠性
        d.可互连不同物理层、不同MAC子层和不同速率的以太网

交换机(多接口网桥)：
    --说明：每个接口可以独占传输媒体带宽

    --分类：
        a.直通式交换机：查完目的地址(6B)就立刻转发
            特点：延迟小，可靠性低，无法支持具有不同速率的端口有交换
        b.存储转发式交换机：将帧放入高速缓存，并检查是否正确，正确则转发，错误则丢弃
            特点：延迟大，可靠性高，可以支持具有不同速率的端口的交换
    &lt;!-- 
        冲突域：在同一个冲突域中的每一个节点都能收到所有被发送的帧，就是同一时间内只能有一台设备发送信息的范围
        广播域：网络中能接收任意设备发出的广播帧的所有设备的集合，即如果站点发出一个广播信号，能接受收到这个信号的设备范围称为一个广播域
     --&gt;</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/" data-id="ckp27psso000gn8ubeynuglgl" data-title="计算机网络——数据链路层" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机网络—物理层" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/" class="article-date">
  <time class="dt-published" datetime="2021-05-14T05:57:50.313Z" itemprop="datePublished">2021-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/">计算机网络——物理层</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="#计算机网络"></a>#计算机网络</h2><h2 id="物理层"><a href="#物理层" class="headerlink" title="##物理层"></a>##物理层</h2><p>###基本概念</p>
<pre><code>概念：解决如何在连接各种计算机传输媒体上传输数据比特流，而不是指具体的传输媒体

主要任务：确定与传输媒体接口有关的一些特性

定义特性：
    --机械特性：定义物理连接的特性
    --电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配等
    --功能特性：指明某条线上出现的某一电平表示和中医医，接口不见得信号线的用途
    --规程特性：定义各条物理线路的工作规程和时序关系</code></pre>
<p>###数据通信</p>
<pre><code>目的：传送消息
构成：
    --数据：传送信息的实体，通常是有意义的符号序列
    --信号：数据的电气/电磁表现，是数据在传输过程中的存在形式
        &lt;!-- 
            数字信号：代表消息的参数取值时离散的
            模拟信号：代表消息的参数取值是连续的
         --&gt;
    --信源：产生和发送数据的源头
    --信宿：接收数据的中带你
    --信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道

通信方式：
    --单工通信
    --半双工通信
    --全双工通信

数据传输方式：
    --串行传输：速度慢，费用低，适合远距离
    --并行传输：速度快，费用高，适合近距离，用于计算机内部数据传输

性能：
    --码元：是指一个固定时长的信号波形(数字脉冲)，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位
    --速率：数据率，是指数据的传输速率，表示单位时间内传输的数据量，可以用码元传输速率和信息传输速率表示</code></pre>
<p>###奈式准则（奈奎斯特定理）</p>
<pre><code>失真：
    --影响失真程度的因素：
        a.码元传输速率
        b.信号传输距离
        c.噪声干扰
        d.传输媒体质量

    --码间串扰：接收端收到的信号波形失去了码元之间清洗界限的现象

说明：在理想低通(无噪声，带宽受限)条件下为避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz
计算：理想低通信道下的极限数据传输率=2Wlog2V（单位是b/s，V是几种码元/码元的离散电平数目，w是带宽）
性质：

    --在任何信道中，码元传输的速率是有上限的，若传输速率超过此上限，就会出现严重的码间串扰问题
    --信道的频带越宽(即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输
    --奈式准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制
    --由于码元的传输速率受奈式准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法  </code></pre>
<p>###香农定理</p>
<pre><code>信噪比：
    --说明：信号的平均功率/噪声的平均功率
    --单位：1db = 10log10(S/N)

说明：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值
计算：
    信道的极限数据传输速率 = Wlog2(1+S/N)（单位b/s，W是带宽）

性质：
    --信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高
    --只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输
    --香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少</code></pre>
<p>###编码&amp;调制</p>
<pre><code>信道上传送的信号：
    --基带信号：将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输(基带传输)，其可以是来自信源的信号或者就是发出的直接表达了要传输的信息的信号
    --宽带信号：将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输(宽带传输)；把基带信号警告载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输(即仅在一段频率范围内能够通过信道)

性质：
    --编码：
        a.数字数据---&gt;数字信号
            方法：
                1-非归零编码：没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步
                2-归零编码：信号电平在一个码元之内都要恢复到零的这种编码方式
                3-反向不归零编码：信号电平翻转表示0，信号电平不变表示1
                4-曼彻斯特编码：将一个码元分成两个相等的间隔，前低后高为1，前高后低为0；该编码的特点是在每一个码元的中间出现电平跳变，位中间的跳变既做时钟信号，又作数据信号，但它占的频带宽度是原始的基带宽度的两倍
                5-差分曼彻斯特编码：同1异0，常用于局域网传输，在每个码元中间，都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码
                6-4B/5B编码：比特流插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，编码效率为80%

        b.模拟数据---&gt;数字信号
            1-抽样
            2-量化
            3-编码

    --调制：
        a.数字数据---&gt;模拟信号
            方法：
                1-调幅(2ASK)
                2-调频(AFSK)
                3-调相(2PSK)
                4-调相+调幅(QAM)

        b.模拟数据---&gt;模拟信号</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/" data-id="ckp27pssh000bn8ub2wzr4y57" data-title="计算机网络——物理层" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机网络—基础知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2021-05-12T08:15:33.935Z" itemprop="datePublished">2021-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机网络</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="#计算机网络"></a>#计算机网络</h2><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="##基础知识"></a>##基础知识</h2><p>###计网基础知识</p>
<pre><code>概念：
    --是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路链接起来，由功能完善的软件实现资源共享和信息传递的系统
    --互联的、自治的计算机集合

功能：
    --数据通信
    --资源共享
    --分布式处理：多台计算机各自承担同一工作任务的不同部分
    --提高分布式可靠
    --负载均衡

组成：
    --组成部分：硬件、软件、协议

    --工作方式：
        a.边缘部分：用户直接使用
            1-C/S方式
            2-P2P方式
        b.核心部分
            1-为边缘部分服务

    --功能组成：
        a.通信子网：实现数据通信
        b.资源子网：实现资源共享/数据处理

分类：
    --按分布范围：
        a.广域网    WAN
        b.城域网MAN
        c.局域网WAN
        d.个人区域网PAN

    --按使用者：
        a.公用网
        b.专用网

    --按交换技术：
        a.电路交换
        b.报文交换
        c.分组交换

    --按拓扑结构：
        a.总线型
        b.星型
        c.环形
        d.网状型

    --按传输技术：
        a.广播式网络：共享公共通信信道
        b.点对点网络：使用分组存储转发和路由选择机制

性能指标：
    --速率：又称数据率、数据传输率或比特率
        a.说明：连接在计算机网络上的主机在数字信道上传送数据位数的速率

    --带宽：
        a.说明：用爱表示网络的通信线路传送数据的能力，通常是治单位时间内从网络中的某一点到另一点所能通过的“最高数据率”

    --吞吐量：
        a.说明：单位时间内通过某个网络(或信道、接口)的数据量
        b.限制：受网络的带宽或网络的额定速率的限制

    --时延：
        a.说明：指数据(报文/分组/比特流)从网络(或链路)的一端传送到另一端所需的时间，也叫延迟或迟延，单位是s
        b.分类：
            1-发送时延(传输时延)：从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间(在主机内部完成)
                （1）计算：数据长度/信道带宽(发送速率)

            2-传播时延：取决于电磁波传播速度和链路长度(在信道上完成)
                （1）计算：信道长度/电磁波在信道上的传播速率

            3-排队时延：等待输出/输入链路可用

            4-处理时延：检错找出口

    --时延带宽积：
        a.说明：传播时延*带宽 

    --往返时延RRT：
        b.说明：从发送方发送数据开始，到发送方收到接收方的确认，总共经历的时延

    --利用率：
        a.分类：
            1-信道利用率
                （1）计算：有数据通过时间/(有+无)数据通过时间
            2-网络利用率：信道利用率加权平均值

分层：
    --分层原则：
        a.各层之间相互独立，每层只实现一种相对独立的功能
        b.每层之间界面自然清晰
        c.结构上课分隔开，每层都采用最合适的技术来实现
        d.保持下层对上层的独立性，上层单向使用下层提供的服务 
        e.整个分层结构应该能促进标准化工作

    --实体：第n层中的活动元素称为n层实体，同一层的实体叫做对等实体
    --协议：未进行网络中的对等实体数据交换而建立的规则、标准或约定成为网络协议(水平)
    --结构(访问服务点SAP)：上层使用下层服务的入口
    --服务：下层为相邻上层提供的功能调用(垂直)

    --OSI参考模型：

         a.应用层：所有能和用户交互产生网络流量的程序

         b.表示层：用于处理在两个通信系统中交换信息的表示方式(语法和语义)
             1-功能：
                 （1）数据格式变换
                 （2）数据加密解密
                 （3）数据压缩和恢复

         c.会话层：向表示层实体/用户进程提供建立连接并在连接上有序地传输数据，这是会话，也是建立同步(SYN)
             1-功能：
                 （1）建立、管理、终止会话
                 （2）使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步(适用于传输大文件)


         d.传输层：负责主机中两个进程地通信，即端到端地通信。传输单位是报文段或用户数据报
             1-功能：
                 （1）可靠传输、不可靠传输
                 （2）差错控制
                 （3）流量控制
                 （4）复用分用
                     --复用：多个应用层进程可同时使用下面运输层的服务
                     --分用：运输层把收到的信息分别交付给上面应用层中相应的进程

         e.网络层：主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。传输单位是数据报
             1-功能：
                 （1）路由选择：最佳路径
                 （2）流量控制
                 （3）差错控制
                 （4）拥塞控制

         f.数据链路层：主要任务是把网络层传下来的数据报组转成帧；传输单位是帧
             1-功能：
                 （1）成帧(定义帧地开始和结束)
                 （2）差错控制：帧错+位错
                 （3）流量控制
                 （4）访问(接入)控制：控制对信道地访问

         g.物理层：在物理上实现比特流的透明传输；传输单位是比特
             1-功能：
                 （1）定义接口特性
                 （2）定义传输模式
                 （3）定义传输速率
                 （4）比特同步
                 （5）比特编码

    --TCP/IP参考模型：

        a.应用层
        b.传输层
        c.网际层
        d.网络接口层

    --五层参考模型
        a.应用层：支持各种网络应用
        b.传输层：进程-进程的数据传输
        c.网络层：源主机到目的主机的数据分组路由与转发
        d.数据链路层：把网络层传下来的数据报组转成帧
        e.物理层：比特传输

    --OSI模型与TCP/IP模型的异同
        a.相同点：
            1-都分层
            2-基于独立的协议栈的概念
            3-可以实现异构网络互联

        b.不同点：
            1-OSI定义三点：服务、协议、接口
            2-OSI先出现，参考模型先于协议发明，不偏向特定协议
            3-TCP/IP设计之初就考虑到异构网互联问题，将IP作为重要层次 
            4-OSI在网络层上是进行无连接+面向连接的传输而TCP/IP是无连接，在传输层上OSI支持面向连接，而TCP/IP支持无连接+面向连接</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="ckp27psse000an8ubhasfap39" data-title="计算机网络" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java编程杂记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/11/java%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-05-11T06:59:25.165Z" itemprop="datePublished">2021-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/11/java%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/">Java编程杂记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="java编程杂记"><a href="#java编程杂记" class="headerlink" title="#java编程杂记"></a>#java编程杂记</h2><p>##集合</p>
<pre><code>--List是一个接口
--HashSet常用方法：https://www.cnblogs.com/qilin20/p/12300384.html</code></pre>
<p>##数据类型转换</p>
<pre><code>--StringBuffer和String的转换
    a.String--&gt;StringBuffer：
        1-构造函数
        2-append()函数
    b.StringBuffer--&gt;String
        1-构造函数
        2-通过toString方法</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/11/java%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/" data-id="ckp27pss80004n8ub9ll3dura" data-title="Java编程杂记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统—设备管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-05-10T04:14:52.843Z" itemprop="datePublished">2021-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/">操作系统——设备管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="#操作系统"></a>#操作系统</h2><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="##设备管理"></a>##设备管理</h2><p>###磁盘</p>
<pre><code>调度算法：
    --先来先服务
    --最短寻找时间优先(SSTF)
    --扫描算法(SCAN)：只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动
    --Look调度算法：如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动的方向
    --循环扫描算法(C-SCAN)：规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求
    --C-Look算法：  如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁头访问请求的位置即可

减少延迟时间的方法：
    --交替编号：
        a.方法：让编号相邻的扇区在物理上不相邻
        b.原理：读取完一个扇区需要一段事件处理才可以继续读入下一个扇区
    --错位命名：
        a.方法：让相邻盘面的山区编号“错误”
        b.原理：与交替编号方法相同

磁盘地址结构：
    --采用（柱面号，盘面号、扇区号）的结构
    --原因：在读取地址连续的磁盘块时，该结构不需要移动磁头

磁盘的管理：
    --磁盘初始化：
        a.进行低级格式化(物理格式化)，将磁盘的各个磁道划分为扇区；一个扇区通常可分为头、数据区域、尾三个部分组成
        b.将磁盘分区，每个分区由若干柱面组成
        c.进行逻辑格式化，创建文件系统

    --引导块：计算机启动时需要运行初始化程序(自荐程序)来完成初始化

    --坏块：无法正常使用的扇区，属于硬件故障
        a.简单的逻辑磁盘：逻辑格式化时将坏块标记出来
        b.复杂的磁盘：磁盘控制器维护一个坏块链，并管理备用扇区</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" data-id="ckp27pssd0009n8ubc99rh56d" data-title="操作系统——设备管理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统—文件管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T12:01:09.246Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/">操作系统——文件管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="#操作系统"></a>#操作系统</h2><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="##文件管理"></a>##文件管理</h2><p>###文件</p>
<pre><code>说明：是一组有意义的信息/数据集合

属性：    
    --文件名
    --标识符：一个系统内的各文件标识符唯一
    --类型：指明文件类型
    --位置：文件存放的路径
    --大小
    --保护信息：对文件进行保护的访问控制信息

逻辑结构：
    --无结构文件(流式文件)
        说明：文件内部的数据就是一系列二进制流或字符流组成

    --有结构文件(记录式我呢见)
        说明：由一组相似的记录组成，每条记录由若干个数据项组成
        分类：
            （1）顺序文件：
                a.说明：
                    文件中的记录一个接一个地顺序排列(逻辑上)，各个记录在物理上可以顺序存储或链式存储
                b.分类：
                    1-链式存储
                        --特点：无法实现随机存取
                    2-顺序存储
                        --串结构：记录之间地顺序与关键字无关
                        --顺序结构：记录之间地顺序按关键字顺序排列
                        --特点：
                            若是可变长记录，无法实现随机存取；
                            若是定长记录，可实现随机存取；
                            若是采用串结构，无法快速找到某关键字对应的记录；
                            若采用顺序结构，可以快速找到某关键字对应地记录；

            （2）索引文件：
                a.说明：
                    建立一张索引表以加快文件检索速度，每条记录对应一个索引项
                    &lt;!-- 
                        索引表：本身是定长记录文件，每当要增删一个记录时，需要对索引表进行修改；主要用于对信息处理的及时性要求比较高的场合；
                     --&gt;</code></pre>
<p>###文件目录</p>
<pre><code>文件控制块(FCB)：指目录文件中地一条记录
    --说明：
        FCB的有序集合就是文件目录；
        一个FCB就是一个文件目录项，其中包含了文件的基本信息，存取控制信息以及使用信息；
        FCB实现了文件名和文件之间的映射，使用户可以实现“按名存取”

目录结构：
    --单级目录结构：
        a.说明：整个系统只建立一张目录表，每个文件占一个目录项
        b.特点：实现了“按名存取”，但是不允许文件重名

    --两级目录结构：
        a.说明：采用两级结构，分为主文件目录和用户文件目录
        b.特点：允许不同用户的文件重名，也可以在目录上实现访问限制，但是用户不能对自己的文件进行分类

    --多级目录结构(树形目录结构)：
        a.说明：系统根据绝对路径一层一层地找到下一级目录；
        b.特点：方便对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护，但是树形结构不便于实现文件的共享

    --无环图目录结构：
        a.说明：在树形结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个有向无环图；同时，需要为每个共享节点设置一个共享计数器，用于记录此时有多少个地方在共享该节点；用户提出删除节点的请求时，只是和三处该用户的FCB，并使共享计数器减1，并不会直接删除共享节点，只有当共享计数器为0时，才删除节点
        特点：更方便地实现多个用户间文件共享

索引结点：
    说明：是FCB的改进，除了文件名之外的文件描述信息都放到这里

文件的物理结构(分配方式)：
        &lt;!-- 操作系统为文件分配存储空间都是以块为单位的 --&gt;
    --连续分配：
        a.说明：要求文件在磁盘上占有一组连续的块
        b.存储：文件目录表中记录存放的起始块号和长度，根据逻辑块号就可以查找到文件的物理块号
        c.特点：
            1-支持随机访问
            2-在顺序读写时速度最快
            3-不方便拓展
            4-存储空间利用率低，会产生磁盘碎片

    --链接分配：
        a.隐式链接：
            1-说明：除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针
            2-特点：
                （1）只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间
                （2）很方便文件拓展，不会有碎片问题，外存利用率高

        b.显示链接：
            1-说明：把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表(FAT)，开机后FAT常驻内存
            2-存储：操作系统根据逻辑块号找到文件对应的目录项，从目录项中找到起始块号，查询内存中的文件分配表FAT，往后找到逻辑块号对应的物理块号，逻辑块号转换成物理块号地过程不需要读磁盘操作
            3-特点：
                （1）支持随即访问，也支持顺序访问
                （2）由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问的速度快很多
                （3）方便文件拓展，不会有碎片问题，外存利用率高
                （4）文件分配表地需要占用一定的存储空间

    --索引分配：
        a.说明：索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为索引块，文件数据存放的磁盘成为数据块
            &lt;!-- 索引表：建立逻辑页面到物理页之间地映射关系 --&gt;

        b.方案：
            1-链接方案：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放
                特点：若文件很大，索引表很长，索引效率低下
            2-多层索引：类似于多级页表
                特点：即使是小文件，访问一个数据块依然需要K+1次读磁盘
            3-混合索引：多种索引分配方式的结合
                特点：对于小文件来说，访问一个数据块所需的读磁盘次数更少

文件存储空间的管理
    --空闲表法：
        a.分配：空闲表中记录每个连续空闲区的起始盘块号、盘块数；分配时可采用首次适应、最佳适应等策略
        b.回收：注意表项的合并问题
    --空闲链表法：
        a.分配：操作系统保存着链头、链尾指针，若某文件申请K个盘块，则从链头开始一次摘下K个盘块分配，并修改空闲链的链头指针
        b.回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针
    --位视图法
    --成组链表法：适合大型文件系统

文件的基本操作
    --创建文件：
        a.在外存中找到文件所需的空间
        b.根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项 

    --删除文件：
        a.根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项
        b.根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块

    --打开文件：
        a.根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项，并检查该用户是否指定的操作权限、
        b.将目录项复制到内存中的“打开文件表”中，并将对应表目的编号返回给用户，之后用户使用打开文件表的编号来指明要操作的文件

    --关闭文件：
        a.将进程的打开文件表相应表象删除
        b.回收分配给该文件的内存空间等资源
        c.系统打开文件表的打开计时器count-1，若count为0，则删除对应表项

    --读文件：
        a.根据读指针、读入数据量、内存位置将文件数据从外存读入内存

    --写文件：
        a.根据写指针、写出数据量、内存位置将文件数据从内存写出外存  

文件共享：
    --基于索引结点的共享方式(硬链接)：
        a.各个用户的目录项指向同一个索引结点，索引结点中需要有链接计数count
        b.用户删除文件时，只是删除该用户的目录项，且count--，当count==0时才能真正删除文件数据和索引系欸但，否则会导致指针悬空

    --基于符号链的共享方式(软链接)    ：
        a.在一个Link型的文件中记录共享文件的存放路径，操作系统根据路径查找目录，获取共享文件
        b.即使软连接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败
        c.由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I/O，因此用软连接访问

文件保护
    --口令保护
    --加密保护
    --访问控制：在每个FCB中增加一个访问控制列表，该表中记录了各个用户可以对该文件执行的操作权限

文件系统的层次结构
    --用户接口：用于处理用户发出的系统调用请求
    --文件目录系统：根据用户给出的文件路径找到相应的FCB或索引结点
    --存取控制模块：完成了文件保护相关功能
    --逻辑文件系统与文件信息缓冲区：需要将记录号转换为对应的逻辑地址
    --物理文件系统：把逻辑地址转换为实际的物理地址
    --辅助分配模块：负责文件存储空间的管理
    --设备管理模块：直接与硬件交互，负责和硬件直接相关的一些管理工作</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" data-id="ckp27pssc0008n8ub6i9shawy" data-title="操作系统——文件管理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统—进程管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T08:18:57.033Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">操作系统——进程管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="#操作系统"></a>#操作系统</h2><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="##进程管理"></a>##进程管理</h2><p>###进程</p>
<pre><code>定义（体现的是动态性）：
    --进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
    --进程是程序的一次执行过程
    --进程是一个程序及其数据在处理及上顺序执行时所发生的活动
    --进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位
    --进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立

组成： 程序段、数据段、PCB(进程控制块，其是进程存在的唯一标志)三部分组成了进程实体(进程映像)，一般情况下，就把进程实体简称为进程；进程实体是静态的，进程是动态的 

 组织方式：
     （1）链接方式：
         --按照进程状态将PCB分为多个队列，操作系统持有指向个个队列的指针
     （2）索引方式：
         --根据进程状态的不同，建立几张索引表，操作系统持有指向各个索引表的指针

 特征：
     （1）动态性：进程最基本的特征
     （2）并发性
     （3）独立性：晋城市系统进行资源分配、调度的独立单位
     （4）异步性：各进程以不可预知的速度向前推进，可能导致运行结果的不确定性
     （5）结构性

 进程的状态
     （1）运行态(Running)：占有CPU，并在CPU上运行，单核处理机环境下，每一时刻最多只有一个进程处于运行态
     （2）就绪态(Ready)：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行；进程已经拥有了除处理及之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行
     （3）阻塞态(Waiting/Blocked，又称等待态)：因等待某一件事而暂时不能运行
     （4）创建态(New，新建态)：进程正在被创建，操作系统为进程分配资源、初始化PCB
     （5）终止态(Terminated，结束态)：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

 进程控制：
     （1）创建
     （2）终止
     （3）阻塞
     （4）唤醒
     （5）切换

 进程通信：
     说明：是指进程之间的信息交换
     （1）共享存储：
         --基于数据结构的共享：速度慢，限制多，是一种低级通信方式
         --基于存储区的共享：速度更快，是一种高级通信方式
         ps：两个进程对共享空间的访问必须是互斥的（互斥操作通过操作系统提供的工具实现）

     （2）消息传递
         说明：进程间的数据交换以格式化的消息为单位；进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换
         --直接通信方式：消息直接挂到接收进程的消息缓冲队列上
         --间接通信方式（信箱通信方式）：消息要先发送到中间实体(信箱)中

     （3）管道通信：
             --“管道”是指用于连接读写进程的一个共享文件(pipe文件)，其实就是在内存中开辟一个大小固定的缓冲区
             --管道只能采用半双工通信，某一时间段内只能实现单向的传输；如果需要实现双向同时通信，则需要设置两个管道
             --各进程要互斥的访问管道
             --数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待都进程将数据取走。当都进程将数据全部取走后，管道变空，此时读进程的read()系     统调用统调用统的调用将被阻塞
             --数据一旦被读出，就从管道中被抛弃，意味着读进程最多只能有一个，否则可能会有读错数据的情况</code></pre>
<hr>
<p>###线程</p>
<pre><code>定义：
    --线程是一个基本的CPU执行单元，也是程序执行流的最小单元
    --线程是程序执行流的最小单元
    --线程可以理解为“轻量级进进程”

与进程的区别：
    --进程是资源分配的基本单位，线程是调度的基本单位

属性：
    --线程是处理机调度的单位
    --多CPU计算机中，各个线程可以占用不同的CPU
    --每个线程都有一个线程ID、线程控制块(TCB)
    --线程几乎不拥有系统资源
    --统一进程的不同线程间共享进程的资源
    --由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
    --同一进程中的线程切换，不会引起进程切换
    --不同进程中的线程切换，会引起进程切换
    --切换同进程内的线程，系统开销很小；切换进程，系统开销较大

实现方式：

    --用户级线程：
        （1）说明：
            --由应用程序通过线程库实现，所有线程管理工作都有应用程序负责(包括线程切换)
            --用户级线程中，线程切换在用户态下即可完成，无需操作系统干预
            --用户级线程对用户不透明，对操作系统透明

    --内核级线程：
        （1）说明：
            --内核级线程的管理工作由操作系统内核完成
            --内核级线程的切换需要在核心态下才能完成
            --内核级线程对用户透明，对操作系统不透明
            --内核线程是处理机分配的单位

多线程模型：

    --多对一模型：多用户对单内核，每个用户进程只对应一个内核级线程
        advantage：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
        disadvantage：当一个用户线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上并行运行

    --一对一模型：单用户对单内核
        advantage：当一个线程阻塞后，别的线程还可以继续执行，并发能力强；多线程可在多核处理机上并发执行
        disadvantage：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大

    --多对多模型：n用户对m内核，每个用户进程对应m个内核级线程
        action：克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的特点</code></pre>
<hr>
<p>###处理机调度：</p>
<pre><code>说明：处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理及分配给它运行，以实现进程的并发执行
分层：
    （1）高级调度(作业调度)：主要是指调入的问题
        --按一定的原则从外存上处于后备队列的作业中挑选一个(或多个)作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB)，以使得其获得竞争处理机的权力
        --高级调度是辅存与内存之间的调度，作业调入时会建立相应的PCB，作业调出时才撤销PCB

    （2）中级调度(内存调度)：
        --将暂时不能运行的进程调至外存等待，等它重新具备了运行条件且内存稍有空闲时，再重新调入内存；提高内存利用率和系统吞吐量
        --暂时调到外存等待的进程状态为挂起状态，PCB并不会一起调到外存，而是会常驻内存，PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统同过内存中的P     CB来保持对各个进程的监控、管理；被挂起的进程PCB会被放到挂起队列中
            &lt;!-- 
                挂起状态：指的是暂时调到外存等待的进程状态，为减轻系统负载，提高资源利用率
                    分类：
                        --就绪挂起
                        --阻塞挂起 
                    注意:
                        --&quot;挂起&quot;和&quot;阻塞&quot;两种状态都是暂时不能获得CPU的服务,但挂起状态是将进程映像调到外存去了,而阻塞态下进程映像还在内存中
            --&gt;

    （3）低级调度(进程调度)：
        --说明：
            （1）其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它
            （2）进程调度是操作系统中最基本的一种调度

        --过程：
            （1）队员来运行进程的各种数据的保存
            （2）对新的进程各种数据的恢复

        --调度时机：
            （1）需要进行进程调度和切换：
                --当前运行进程主动放弃处理机：
                    a.进程正常终止
                    b.运行过程中发生异常而终止
                    c.进程主动请求阻塞(如 等待I/O)
                --当前运行的进程被动放弃处理机：
                    a.分配给进程的时间片用完
                    b.有更紧急的事需要处理(如I/O中断)
                    c.有更高优先级的进程进入就绪队列
            （2）不能进行进程调度与切换
                --在处理中断过程中。
                --进程在操作系统内核程序临界区中
                    &lt;!--
                        临界资源：一个时间段内只允许一个进程使用的资源，各进程需要互斥地访问临界资源
                        临界区：访问临界资源的那段代码
                      --&gt;
                --在原子操作过程中

        --调度方式：
            （1）非剥夺调度方式(非抢占方式)：只允许进程主动放弃处理机
                特点：实现简单，系统开销小，但无法处理紧急任务；适合于早期的批处理系统
            （2）剥夺调度方式(抢占方式):允许进程被动放弃处理机
                特点：可以优先处理更紧急的进程，也可以实现让各进程按时间片轮流执行的功能(通过时钟中断)；适合于分时操作系统、实时操作系统

调度指标：
    （1）CPU利用率：指CPU“忙碌”的时间占总时间的比例
    （2）系统吞吐量：单位时间内完成作业的数量
    （3）周转时间：是指从作业被提交给系统开始，到作业完成为止的这段时间间隔
    （4）等待时间：指进程/作业处于等处理机状态事件之和
    （5）响应时间：只从用户提交请求到首次产生相应所用的时间

调度算法：
    （1）先来先服务(FCFS)
            --规则：按照作业/进程到达的先后顺序进行服务
            --使用：
                a.用于作业调度时，考虑的是哪个作业先到达后备队列
                b.用于进程调度时，考虑的是哪个进程先到达就绪队列
            --特性：
                a.非抢占式算法
                b.公平，算法实现简单
                c.对长作业有利，对短作业不利

    （2）短作业优先(SJF)
            --规则：最短的作业/进程优先得到服务（是指要求服务时间最短）
            --使用：既可用于作业调度，也可用于进程调度
            --特性：
                a.SJF和SPF(短进程优先算法)是非抢占式算法，而SRTM(最短剩余时间优先算法)是抢占式算法
                b.“最短的”平均等待时间、平均周转时间
                c.不公平，作业/进程的运行时间是由用户提供的，并不一定真是，不一定能做到真正的短作业优先
                d.会导致饥饿现象，如果一直得不到服务，则称为“饿死 ”

    （3）高响应比优先(HRRN)
            --规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务
                &lt;!--
                    响应比 = (等待时间+要求服务时间)/要求服务时间 
                 --&gt;
            --使用：既可以用于作业调度,也可以用于进程调度 
            --特性：
                a.非抢占式算法
                b.综合考虑了等待时间和运行时间(要求服务时间);等待时间相同时,要求服务时间短的优先;要求服务时间相同时,等待时间长的优先 

    （4）时间片轮转算法(RR)
            --规则：按照各进程到达就绪队列的顺序，轮转让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队；如果两个进程在同一时刻到达，则默认新到达的进程先进就绪队列
            --使用：用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)
            --特性：
                a.抢占式算法；由时钟装置发出时钟中断来通知CPU时间片已到
                b.公平且响应快，适用于分时操作系统
                c.由于高频率的进程切换，因此有一定开销，不区分任务的紧急程度

    （5）优先级调度算法
            --规则：没个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程
            --使用：既可以用于作业调度，也可以用于进程调度
            --特性:
                a.具有抢占式和非抢占式
                b.用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各个作业/进程的偏好程度
                c.若源源不断地有高优先级进程到来，则可能导致饥饿

    （6）多级反馈队列调度算法
            --规则：
                a.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
                b.新进程到达时先进入第一级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级地队列，则重新放回该队列队尾
                c.只有第k级队列为空时，才会为k+1级队头地进程分配时间
                d.对各类进程相对公平(FSFC优点)；每个新到达地进程都可以很快得到响应(RR优点)；短进程都只用较少的时间就可完成(SPF优点)；不必实现估计进程的运行时间(避免用户作假)；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程(拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O进程就可以保持较高优先级)
                e.可能会产生饥饿现象</code></pre>
<hr>
<p>###进程同步和互斥</p>
<pre><code>进程同步：
    （1）说明：要让各并发进程按要求有序地推进
进程互斥：
    （1）说明：指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待，当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源
    （2）过程：
        --进入区：负责检查是否可以进入临界区，若可以，则应设置正在访问临界资源的标志，以阻止其他进程同时进入临界区
        --临界区：访问临界资源的代码
        --退出区：负责解除正在访问临界资源的标志
        --剩余区：做其他处理
        注意：
            进入去和退出区是负责实现互斥的代码段

    （3）原则：
        --空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
        --忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待
        --有限等待：对请求访问的进程，应保证能在有限的时间内进入临界区(保证不会饥饿)
        --让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待

    （4）软件实现方法：
        --单标志法：
            a.思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程进入临界区的权限只能被另一个进程赋予
        --双标志先检查法：
            a.思想：色织一个布尔型数组flag[]，数组中各个元素用来标记个进程想进入临界区的医院。每个进程在进入临界区之前先检查当前有没有别的想进入临界区，若没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区
            b.缺点：违反“忙则等待”原则
        --双标志后检查法：
            a.思想：先上锁后检查
            b.缺点：违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象
        --Peterson算法：
            a.思想：如果双方都争着进入临界区，则主动让对方先使用临界区
            b.缺点：未遵循让权等待

    （5）硬件实现方法：
        --中断屏蔽方法：
            a.思想：利用“开/关中断指令”实现（与原语的实现思想相同）
            b.过程：
                --关中断：关中断后即不允许当前进程被中断，也必然不会发生进程切换
                --临界区
                --开中断：直到而当前进程访问完临界区，在执行开中断指令，才有可能有别的进程上处理机并访问临界区
            c.优缺点：
                --简单、高效
                --不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)

        --TestAndSet指令(TestAndSetLock指令/TS指令)：
            a.思想：TSL指令是用硬件实现的，执行的过程不允许被中断
            b.优缺点：
                --实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
                --不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”

        --Swap指令(Exchange指令/XCHG指令)：
            a.思想：Swap指令是用硬件实现的，执行的过程不允许被中断
            b.优缺点：
                --实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
                --不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”</code></pre>
<hr>
<p>###信号量机制</p>
<pre><code>说明：进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步
    &lt;!-- 信号量：用来表示系统中某种资源的数量 --&gt;

使用：通过wait(S)和signal(S)原语，也就是PV操作，实现系统资源的“申请”和“释放”

分类：
    --整型信号量：用来表示系统中某种资源的数量 
        使用：通过该信号量表示系统中的资源，当所需资源大于0，则获取资源，当资源小于等于0，则循环等待
        缺点：存在“忙等”问题
    --记录型信号量：用记录型数据结构表示的信号量
        使用：在记录型数据结构当中有着等待队列，每次进行P操作时，对所需资源数-1，若所需资源数小于0，则将其阻塞，加入到等待队列当中（运行态-&gt;阻塞态）；在执行释放操作时，对所需资源数加1，若当前所需资源数仍然小于等于0，说明当前等待队列中还有阻塞进程，则分配资源给该进程（阻塞态-&gt;就绪态）

注意：实现互斥的P操作一定要在实现同步的P操作之后</code></pre>
<hr>
<p>###管程</p>
<pre><code>说明：是一种特殊的软件模块
组成：
    （1）局部于管程的共享数据结构说明
    （2）对该数据结构进行操作的一组过程
    （3）对局部于管程的共享数据设置初始值的语句
    （4）管程有一个名字

基本特征：
    （1）局部于管程的数据只能被局部于管程的过程访问
    （2）一个进程只有通过调用管程内的过程才能进入管程访问共享数据
    （3）每次仅允许一个进程在管程内执行某个内部过程（这种互斥特性是由编译器负责是实现的）
    （4）可在管程中设置条件变量及等待/唤醒操作以解决同步问题，可以让一个进程或线程在条件变量上等待(此时，该进程应先释放管程的使用权)，可以通过唤醒操作将等待在条件变量上的线程或进程唤醒</code></pre>
<hr>
<p>###死锁</p>
<pre><code>说明：在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象

条件：
    （1）互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁
    （2）不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放
    （3）请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放
    （4）循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程所获得的资源同时被下一个进程所请求
    注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁

处理：
    （1）预防死锁：破坏死锁产生的四个必要条件中的一个或几个
            --破坏互斥条件：将互斥使用的资源改造为允许共享使用，如SPOOLing技术将打印机改为共享设备
                缺点：并不是所有的资源都可以改造成可共享使用的资源

            --破坏不剥夺条件：
                缺点：
                    a.实现起来比较复杂
                    b.释放获得的资源可能造成前一阶段工作的失效，因此这种方法一般只适用于易保存和恢复状态的资源，如CPU
                    c.反复地申请和释放资源会增加系统开销，降低吞吐量
                    d.可能会导致饥饿现象

            --破坏请求和保持条件：采用静态分配方法；即进程在运行前一次申请完它所需要地全部资源，在它地资源未满足前，不让其投入运行，一旦投入运行后，指定资源就一直归其使用，该进程就不会在请求别的任何资源
                缺点：
                    a.可能会造成严重的资源浪费，资源利用率极低
                    b.可能导致某些进程饥饿

            --破坏循环等待条件：可采用顺序资源分配法；给系统中的资源编号，规定每个进程必须按编号递增地顺序请求资源，同类资源一次申请完
                缺点：
                    a.不方便增加新的设备，因为可能需要重新分配所有编号
                    b.进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费
                    c.必须按规定次序申请资源，用户编程麻烦

    （2）避免死锁：如银行家算法
            &lt;!-- 安全状态:指如果系统按照这种序列分配资源,则每个进程都能顺利完成;只要找出一个安全序列,系统就是安全状态;如果系统处于安全状态,就一定不会发生死锁;如果处于不安全状态,就可能发生死锁 --&gt;
            银行家算法:
                a.思想:在进程提出资源申请时,先预判此次分配是否会导致系统进入不安全状态,如果会进入不安全状态,就暂时不答应这次的请求,让该进程先阻塞等待
                b.步骤:
                    1-检查此次申请是否超过了之前声明地最大需求数
                    2-检查此时系统剩余地可用资源是否还能满足这次请求
                    3-试探着分配,更改各数据结构
                    4-用安全性算法检查此次分配是否会导致系统进入不安全状态
                    &lt;!-- 安全性算法:检查当前地剩余可用资源是否能满足某个进程的最大需求,如果可以,就把该进程加入安全序列,并把该进程持有的资源全部回收,不断重复 --&gt;

    （3）死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁
            --死锁的检测:
                a.条件:
                    1-用某种数据结构来保存资源的请求和分配的信息
                    2-提供一种算法,利用上述信息来检测系统是否已进入死锁状态
                b.资源分配图:
                    1-结点:进程结点\资源结点
                    2-边:
                        --请求边:进程结点--&gt;资源结点
                        --分配边:资源结点--&gt;进程结点
                c.死锁检测算法:
                    1-方法:依次消除与不阻塞进程相连的边,直到无边可消
                        &lt;!-- 
                            所谓不阻塞进程是指申请的资源数还足够的进程 
                            --&gt;
                    2-结果:用死锁检测算法花间资源分配图后,还连着那些进程就是死锁进程

            --死锁的解除:
                a.资源剥夺法:挂起(暂时放到外存上)某些死锁进程,并抢占它的资源,将这些资源分配给其他的死锁进程,但是应防止被挂起的进程长时间得不到资源而饥饿
                b.撤销进程法(终止进程法):强制撤销部分\甚至全部死锁进程,并剥夺这些进程的资源
                    优缺点:实现简单,但是付出的代价可能会很大
                c.进程回退法:让一个或多个死锁进程回退到足迹避免死锁的底部,这就要求系统要记录进程的历史信息,设置还原点</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" data-id="ckp27pssn000fn8ubex4pdqcp" data-title="操作系统——进程管理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统—内存管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T08:17:30.054Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">操作系统——内存管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="#操作系统"></a>#操作系统</h2><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="##内存管理"></a>##内存管理</h2><p>###内存基础知识</p>
<pre><code>说明:是用于存放数据的硬件(程序执行前需要先放到内存中才能被CPU处理)

链接方式：由目标模块生成装入模块，链接后形成完整的逻辑地址

    （1）静态链接：在程序运行之前先将各模块及它们所需的库函数连接成一个完整的可执行文件(装入模块)，之后不再拆开
    （2）装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式
    （3）运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。
            优点：便于修改和更新，便于实现对目标模块的共享

装入方式:将装入模块装入内存，装入后形成物理地址

    （1）绝对装入:
            --实现：编译时产生绝对地址
                    &lt;!-- 只适用于单道程序环境 --&gt;

    （2）静态重定位(可重定位装入)：
        --实现：装入时将逻辑地址转换为物理地址
                &lt;!-- 要求：作业在装入内存时，必须分配其要求的全部内存空间，若空间不足，则不能装入改作业；同时一旦进入内存后，在运行期间就不能在移动，也不能再申请内存空间 --&gt;

    （3）动态重定位(动态运行时装入)：
        --实现：运行时将逻辑地址转换为物理地址，需设置重定位寄存器
                    &lt;!-- 重定位寄存器:存放装入模块存放的起始地址 --&gt;
        --优点：
            a.可以将程序分配到不连续的存储区中
            b.程序运行前只需要装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存
            c.便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</code></pre>
<hr>
<p>###内存管理</p>
<pre><code>管理者：操作系统

功能：
    （1）内存空间的分配与回收

            --连续分配管理方式：
                a.说明：指为用户进程分配的必须是一个连续的内存空间
                b.分类：
                        &lt;!-- 
                            内部碎片:分配给某进程的内存区域中,有部分没有使用
                            外部碎片:是指内存中的某些分区由于太小而难以利用
                         --&gt;
                    1-单一连续分配
                        --分区方式：
                            1.系统区：通常位于低地址部分，用于存放操作系统相关数据
                            2.用户区：用于存放用户进程相关数据，内存中只能有一道用户程序，用户程序独占整个用户区空间
                        --优点：
                            1.实现简单
                            2.无外部碎片；
                            3.可以用覆盖技术扩充内存
                            4.不一定需要采取内存保护
                        --缺点：
                            1.只能用于单用户、单任务的操作系统中
                            2.有内部碎片
                            3.存储器利用率低

                    2-固定分区分配
                        --分区方式：将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业
                            &lt;!-- 
                                对于分区大小相同：适合用于用一台计算机控制多个相同对象的场合,但是缺乏灵活性
                                对于分区大小不相等：增加了灵活性，可以满足不同大小的进程需求
                            --&gt;
                        --优点:实现简单,无外部碎片
                        --缺点:
                            1.当用户程序太大时,可能所有分区都不能满足需求,此时不得不采用覆盖技术来解决,但这又会降低性能
                            2.会产生内部碎片,利用率低
                        --注意：操作系统需要建立分区说明表，来实现各个分区的分配与回收

                    3-动态分区分配(可变分区分配)
                        --分区方式:在进程装入内存时,根据进程大小动态地建立分区
                        --记录内存的数据结构:
                            1.空闲分区表
                            2.空闲分区链
                        --优点:没有内部碎片
                        --缺点:存在外部碎片,可以使用紧凑技术来解决

                        --动态分区分配算法:
                            1.首次适应算法:从低地址开始查找,找到第一个满足大小的空闲分区
                            2.最佳适应算法:优先使用更小的空闲区,空闲分区按容量递增次序链接,每次分配内存时顺序查找空闲分区链/表
                                &lt;!-- 会产生很多的外部碎片 --&gt;
                            3.最坏适应算法:优先使用更大的空闲区,空闲区按容量递减次序链接,顺序查找
                                &lt;!-- 会导致较大的连续空闲区被迅速用完,导致之后&quot;大进程&quot;到达,没有内存分区可以使用 --&gt;
                            4.邻近适应算法:空闲分区以地址递增的顺序排列,每次分配内存从上次查找结束的位置开始查找

            --非连续分配管理方式
                a.分类：
                    1-分页存储管理：
                        --分区方式：操作系统以页框为单位为各个进程分配内存空间，进程的每个页面分别放入一个页框中，进程的页面与内存的页框有一一对应的关系；各个页面不必连续存放，也不必按先后顺序来
                            &lt;!-- 
                                页框（页帧/内存块/物理块）：内存空间所被分为一个个等大的分区，从0开始；页框不能太大，否则可能产生过大的内部碎片
                                页（页面）：用户进程的地址空间所被分为一个个与页框等大的区域，从0开始
                                页表：记录进程页面和实际存放内存块之间的对应关系，一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由“页号”和“块号”组成，每个页表项的长度是相同的，页号是“隐含”的
                             --&gt;
                        --逻辑地址结构（以32位为例）：
                            a.0~11位存放的是页内偏移量
                            b.12~31位存放的是页号

                        --基地址变换机构：可以借助进程的页表将逻辑地址转换为物理地址
                            &lt;!-- 快表的结构有效的增加了查询的速度  --&gt;

                    2-分段存储管理：
                        --分区方式：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编制；内存分配是以段为单位分配，每个段在内存中占据连续空间，但各段之间可以不相邻
                        --段表：
                            a.每个段对应一个段表项，其中记录了该段在内存中的起始位置和段的长度
                            b.各个段表的长度是相同的
                            c.段号是可以隐含的，不占存储空间

                    3-段页式管理方式：
                        --分区方式：分段+分页
                        --逻辑地质结构：段号、页号、页内偏移量
                        --段表：每个段对应一个段表项，各段表项长度相同，由段号(隐含)、页表长度、页表存放地址组成
                        --页表：每个页对应一个页表项，各个页表项长度相同，由页号(隐含)、页面存放的内存块号组成

                b.注意：
                    --分页对用户不可见，分段对用户可见
                    --分页的地址空间是一维的，分段是二维的
                    --分段更容易实现信息的共享和保护（纯代码/可重入代码可以共享）
                    --分页(单级页表)、分段访问一个逻辑地址都需要两侧访问，分段存储中也可以引入快表机构




    （2）对内存空间进行扩充

            --覆盖技术：
                a.实现：通过对内存设置固定区和覆盖区，对不能被同时访问的程序段共享同一个覆盖区
                &lt;!-- 缺点：对用户不透明，且需要由程序员声明覆盖结构，增加了用户编程的负担 --&gt;

            --交换技术
                a.实现：将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存
                &lt;!-- 
                    文件区：主要用于存放文件，主要追求存储空间的利用率，因此文件区空间的管理采用离散分配方式
                    对换区：其空间占磁盘空间的小部分，被换出的进程数据就存放在对换区，对换区采用连续分配方式(主要是为了追求换入换出速度)
                     --&gt;
                b.交换条件：通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停
                c.注意：PCB会常驻内存，不会换出外存

            --虚拟存储技术
                a.实现：虚拟内存的实现要建立在离散分配的内存管理方式基础上
                    --请求调页(或请求调段)
                    --页面置换(或段置换)
                        1-最佳置换算法(OPT)
                            说明：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，可以保证最低的缺页率
                        2-先进先出置换算法(FIFO)
                            说明：每次选择淘汰的页面是最早进入内存的页面
                            特点：实现简单，但算法性能差，会产生Belady异常
                                &lt;!-- Belady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象 --&gt;
                        3-最近最久未使用置换算法(LRU)
                            说明：每次淘汰的页面是最近最久未使用的页面
                            实现：赋予每个页面对应的页表项中，用访问字段记录该页面上次被访问以来所经历的时间t
                            特点：性能好，但是实现困难，开销大
                        4-时钟置换算法(CLOCK)：
                            实现：为每个页面设置一个访问位，再将内存中的也买你都通过链表指针连接成一个循环队列，当被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将其置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问未依次置为0后，再进行第二轮扫描

                        5-改进型的时钟置换算法
                            说明：在原来的时间置换算法的基础上，优先淘汰没有修改过的页面，避免I/O操作
                            实现：增加一个修改位，0表示没有被修改，反之，被修改过
                            特点：实现简单，算法开销小，性能也不错，但未考虑是否被修改过

                    --页面分配、置换策略
                        1-驻留集：指请求分页存储管理中给进程分配的物理块的集合

                    --操作：
                        1-页表机制：在基本分页的基础上增加了状态位、访问字段、修改位、外村地址
                        2-缺页中断机制：找到页表项后检查页面是否已在内存，若没在则会产生缺页中断
                            说明：
                                --将目标页面调入内存，有必要时还要换出页面
                                --缺页中断属于内中断，属于内中断中的“故障”，即可能被系统修复的异常
                                --一条指令在执行过程中可能产生多次缺页中断

    （3）实现地址转换（三种装入方式）
    （4）内存保护
            --方法：
                a.在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程指令要访问某个地址，CPU检查是否越界
                b.采用重定位寄存器(基地址寄存器)和界地址寄存器(限长寄存器)进行越界检查。重定位寄存器其中存放的是进程的起始物理地址。界地址寄存器存放的是进程的最大逻辑地址</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" data-id="ckp27pssb0007n8ub9um63bqn" data-title="操作系统——内存管理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2021-04-29T11:31:00.942Z" itemprop="datePublished">2021-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="#操作系统"></a>#操作系统</h2><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="##基础知识"></a>##基础知识</h2><p>###操作系统</p>
<pre><code>定义：
    是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，是计算机系统中最基本的系统软件

功能：
    --作为系统资源的管理者：
        （1）处理机管理
        （2）存储器管理
        （3）文件管理
        （4）设备管理

    --作为永和和计算机硬件之间的接口：
        （1）命令接口：允许用户直接使用
            --联机命令接口
            --脱机命令接口
        （2）程序接口：允许用户通过程序间接使用，由一组系统调用组成，即系统调用=程序接口
        （3）GUI(图形用户界面)

特征：
    --并发：
        定义：指两个或多个事件在同一时间间隔内发生；这些事件在宏观上是同时发生的，但微观上是交替发生的；并发性是指计算机系统中同时存在着多个运行着的程序
        区别：并行是指两个或多个事件在同一时刻同时发生

    --共享：
        定义：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用；共享性是指系统中的资源可供内存中多个并发执行的进程共同使用 
        方式：
            （1）互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段内只允许一个进程访问该资源
            （2）同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对其进行访问

    --虚拟：
        定义：是指把一个物理上的实体变为若干个逻辑上的对应物；物理实体是实际存在的，而逻辑上对应物使用户感受到的

    --异步：
        定义：是指在多道程序环境下，郧西多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进

发展：
    --手工操作阶段
    --多道批处理系统：
        多道程序并发执行，共享计算机资源。资源利用率大幅提升，cpu和其他资源保持“忙碌”状态，系统吞吐量增大，但是用户响应时间长，没有人机交互功能
    --分时操作系统：
        计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互，用户请求可被即时相应，解决了人机交互问题，但不能优先处理一些紧急任务
    --实时操作系统：
        能够优先响应一些紧急任务，某些紧急任务不需要时间片排队；在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件，其主要特点是及时性和可靠性
        注意：
            --硬实时系统：必须在绝对严格的规定时间内完成
            --软实时系统：能接受偶尔违反时间规定

运行机制和体系结构

    --两种处理器状态---&gt;用PSW(程序状态寄存器)中的某标志位来标识房前处理器状态0为用户，1为核心：
        （1）用户态(目态)：此时CPU只能执行非特权指令
        （2）核心态(管态)：特权指令、非特权指令都可执行

    --两种程序：
        （1）内核程序：是系统的管理者，可以执行所有指令，运行在核心态中
        （2）应用程序：只能执行非特权指令，运行在用户态

    --内核：
        说明：是计算机上配置的底层软件，是操作系统最基本、最核心的部分
        分类：
            --大内核：
                说明：将操作系统的主要功能模块都作为系统内核，运行在核心态
                特点：高性能；内核代码庞大，结构混乱，难以维护
            微内核：
                说明：只把最基本的功能保留在内核
                特点：内核功能少，结构清晰，方便维护；需要频繁的在核心态和用户态之间切换，性能底

        功能：
            （1）时钟管理：实现计时功能
            （2）中断处理：负责实现中断机制
            （3）原语：是一种特殊的程序，处于操作系统最底层，是最接近硬件的部分；这种程序的运行具有原子性(运行不可中断)；运行时间较短、调用频繁
            （4）对系统资源尽心管理的功能
                --进程管理
                --存储器管理
                --设备管理

中断和异常（是为了实现多道程序并发执行而引入的一种技术）：
    说明：
        --中断发生时，CPU立即进入核心态
        --中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理
        --对不同的中断信号，会进行不同的处理

    分类（分类的标准--&gt;根据信号的来源：内中断是来自于CPU内部，与当前执行的指令有关，外中断是来自于CPU外部，与当前执行的指令无关）：
        --内中断(异常/例外、陷入)：
            （1）自愿中断：指令中断
            （2）强迫中断：硬件故障、软件中断

        --外中断(中断，狭义的中断)：
            （1）外设请求
            （2）人工干预

    注意：用户态-&gt;核心态 是通过中断实现的，并且中断是唯一途径；而 核心态-&gt;用户态 的切换是通过执行一个特权指令，将程序状态字(PSW)的标志位设置为&quot;用户态&quot;

系统调用：

    说明：系统调用相关处理设计到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下进行
    作用：可以保证系统的稳定性和安全性，防止用户进行非法操作

    分类
        --按功能：
            （1）设备管理
            （2）文件管理
            （3）进程管理
            （4）进程通信
            （5）内存管理

    过程：
        （1）传递系统调用参数
        （2）执行陷入指令(用户态)
        （3）执行系统调用相应服务程序(核心态)
        （4）返回用户程序
        注意：
            --陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内终端，从而CPU进入核心态
            --发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行
            --陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="ckp27pssa0006n8ub1lft9k4b" data-title="操作系统" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络——网络层</a>
          </li>
        
          <li>
            <a href="/2021/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">计算机网络——数据链路层</a>
          </li>
        
          <li>
            <a href="/2021/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/">计算机网络——物理层</a>
          </li>
        
          <li>
            <a href="/2021/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机网络</a>
          </li>
        
          <li>
            <a href="/2021/05/11/java%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/">Java编程杂记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>