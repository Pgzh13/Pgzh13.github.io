<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-java简单类库的使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T06:27:24.916Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/">Java类库与基本操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简单的类库使用"><a href="#简单的类库使用" class="headerlink" title="#简单的类库使用"></a>#简单的类库使用</h2><p>###数字</p>
<pre><code>Math.random():令系统随机选取大于等于0.0且小于1.0的伪随机double值
    Math.random()*(n-m)+m：返回指定范围的随机数（m-n之间）的公式</code></pre>
<hr>
<p>###字符</p>
<pre><code>string.equals():判断二者是否相同 </code></pre>
<hr>
<p>###Arrys工具类</p>
<pre><code>Ops:java.util.Arrays
Using:
    sort():快速排序
    binary():二分查找
    equals():判断两个数组是否相同
    fill(int[] a,int val):将指定值填充到数组之中</code></pre>
<hr>
<p>###JavaBean:是一种Java语言写成的可重用组件（也是一个Java类）</p>
<pre><code>特征：
    （1）类是公共的
    （2）有一个无参的公共的构造器
    （3）有属性，且对应的get、set方法
功能：
    可以将功能、处理、值、数据库访问和其他任何可以用Java代码创造对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。</code></pre>
<hr>
<p>###UML类图</p>
<pre><code>结构：
    类名
    属性（属性名：属性类型）
    方法（方法的类型 方法名(参数名：参数类型)：返回值类型）注：若方法有下划线表示为构造器
    ‘+’表示public,‘-’表示private，‘#’表示proctected</code></pre>
<hr>
<p>###Object类（是所有java类的根父类，如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类） </p>
<pre><code>（1）equals()： 比较二者是否相同

    使用：
        （1）是一个方法，并不是运算符
        （2）只能适用于引用数据类型
        （3）Object类中定义的equals()和==的作用是相同的，比较两个对象的地址值是否相同
        （4）在String、Data、File、包装类等都重写了Object类中的equals()方法，重写后，比较的是两个对象的实体内容

    与“==”的却别：
        ==：
            （1）可以使用在基本数据类型 变量和引用数据类型变量中
            （2）如果比较的是基本数据类型变量，比较二者保存的数据是否相同（不一定要类型相同）
                如果比较的是引用数据类型变量，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体

（2）toString()：

    使用：
        a.当输出一个对象的引用时，实际上就是调用当前对象的toString()方法
        b.String、Date、File、包装类等都重写了Object类中的toString()方法</code></pre>
<hr>
<p>###包装类(Wrapper)的使用</p>
<pre><code>功能：java提供了8种数据类型对应的包装类，使得基本数据类型的变量具有类的特征
使用：
    （1）基本数据类型、包装类、String三者之间的相互转换
        基本数据类型-----&gt;包装类：调用包装类的构造器
        包装类-----&gt;基本数据类型：调用包装类Xxx的xxxValue()
        基本数据类型、包装类----&gt;String类型：调用String重载的valueOf(Xxx xxx)
        String类型-------&gt;基本数据类型、包装类：调用包装类的parseXxx(String s)
    注意：
        自动装箱：可以直接将基本数据类型赋给包装类，可以提高效率（只可以赋值到-128到127，当大于这个数则会通过d调用构造器来创建对象）
        自动拆箱：直接将包装类赋给基本数据类型</code></pre>
<hr>
<p>###Vector类的使用</p>
<pre><code>功能：代替数组进行处理
使用：
    （1）addElement(Object ob)：给向量添加元素
    （2）elementAt(0)：取出向量中的元素，返回值是Object类型
    （3）size()：计算向量长度 </code></pre>
<hr>
<p>###JDK8日期时间API<br>    1.LocalDate\LocalTime\LocalDateTime<br>        实例化：<br>            now(Zoneid zone)：静态方法，根据当前时间创建对象/指定时区的对象<br>            of()：静态方法，根据指定日期/时间创建对象，不存在偏移量</p>
<pre><code>    使用方法：    
        getDayOfMonth()/getDayOfYear()：获得月份太难书(1-31)/获得年份天数(1-366)
        getDayOfWeek()：获取星期几(返回一个DayOfWeek枚举值)
        getMonth()：获得月份，返回一个Month枚举值
        getMonthValue()/getYear()：获取月份(1-12)/获取年份
        getHour()/getMinute/getSecond()：获取当前对象对应的时分秒
        withDayOfMonth()/withDayOfYear()/withMonth()/withYear()：将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象

2.Instent类：时间线上的一个瞬时点
    实例化：
        now()：静态方法，返回默认UTC时区的Instant类的对象
        ofEpochMilli(long epochMilli)：静态方法，返回在1970-01-01 00：00：00基础上加上指定毫秒数之后的Instant类的对象

    使用：
        atOffset(ZoneOffset offset)：结合即时的偏移来创建一个OffsetDateTime
        toEpochMilli()：返回1970-01-01 00：00：00到当前时间的毫秒数，即为时间戳（ofEpochMilli：通过给定的毫秒数，获取Instant实例）

3.DateTimeFormatter类：该类提供了三种格式化方法
    使用：
        ofPattern(String pattern)：静态方法，返回一个指定字符串格式的DateTimeFormatter
        format(TemporalAccessor t)：格式化一个日期、时间，返回字符串
        parse(CharSequence text)：将指定格式的字符序列解析为一个日期、时间

4.Date类
    位置：java.util.Date
    使用：使用其空参构造器创建一个对应当前时间的Date对象，也可以给其构造器赋指定毫秒数
        a.toString()：显式当前的年月日时分秒
        b.getTime()：获取当前Date对象对应的时间戳

5.java.sql.Date
    说明：对应这数据库中的日期类型变量，该类时System类的子类
    实例化：java.sql.Date date = new java.sql.Date(毫秒数)

6.java.text.SimpleFormat类
    说明：是一个不与语言环境有关的方式来格式化和解析日期的具体类
    解析：文本--&gt;日期
    使用：
        a.格式化：日期----&gt;字符串
            String对象 = (SimpleFormat对象).format(Date对象)
        b.解析：格式化的逆过程，字符串----&gt;日期
            解析的String对象需要为&quot;年份-月份-日期 上下午 时:分&quot;
            通过指定格式实例化的方法，可以指定转换的日期格式：Date对象 = SimpleDateFormat对象.parse(&quot;指定格式时间的字符串&quot;)
                要求：字符串必须时符合SimpleDateFormat识别的格式(通过构造器参数体现，否则抛异常)

7.java.util.Calendar(日历)类
    说明：是一个抽象基类，主要用于完成日期字段之间相互操作的功能
    实例化：通过调用它的子类GregorianCalendar的构造器/使用Calendar.getInstance()方法
    常用方法：
        get()：获取常用的时间属性信息
        set()：将指定的时间属性设置成新的值
        add()：在原有的基础属性的值上添加
        getTime()：日历类-----&gt;Date
        setTime()：Date-----&gt;日历类
    注意：月份从0开始，星期从1(星期日)开始

8.其他的时间类
    ZoneId：该类中包含了所有的时区信息】
    ZonedDateTime：一个在ISO-8601日历系统时区的日期时间
    Clock：使用时区提供堆当前即时、日期和时间的访问的时钟
    Duration：用于计算两个&quot;时间&quot;间隔
    Period：用于计算两个&quot;日期&quot;间隔
    TemporalAdjuster：时间校正器。
    TemporalAdjusters：该类通过静态方法(firstDayOfXxx() / lastDayOfXxx() / nextXxx())提供了大量的常用TemporalAdjust的实现</code></pre>
<hr>
<p>###java比较器<br>    Comparable接口：自然排序<br>        包：java.lang.Comparable<br>        使用：<br>            1.像String、包装类等实现了Comparable接口，重写了compareTo()方法，给出了比较两个对象的大小，进行从小到大的排序<br>            2.重写compareTo()的规则<br>                当前对象&gt;形参对象，返回正整数，&lt;返回负整数，相等返回0<br>            3.对于自定义类，如果说需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法，在CompareTo(obj)方法中指明如何排序</p>
<pre><code>Comparator接口：定制排序、
    包：java.lang.Comparator
    使用：可以使用匿名的方式，重写conpare方法</code></pre>
<p>###System类<br>    说明：代表系统，系统级的很多属性和控制方法都放置在该类的内部<br>    包：java.lang<br>    使用：<br>        1.该类的构造器为私有的，所以无法创建该类的对象<br>        2.内部成员变量和成员方法都为static<br>    常用方法：<br>        currentTimeMillis()：返回当前的计算机时间<br>        exit(int status)：退出程序，0表示正常退出，非0表示异常退出，使用该方法可以在图形界面编程中实现程序的退出功能<br>        gc()：请求系统进行垃圾回收<br>        getProperty(String key)：获得系统中属性名为key的属性对应的值</p>
<p>###Math类<br>    说明：提供了一系列静态方法用于科学计算，其方法的参数和返回值类型一般为double型<br>    包：java.lang<br>    常用方法：<br>        abs：绝对值<br>        sqrt：平方值<br>        pow(a,b)：a的b次幂<br>        log：自然对数<br>        exp：e为底指数<br>        random：返回0.0到1.0的随机数<br>        round：将double类型数据转换为long</p>
<p>###BigInteger类<br>    说明：<br>        可以表示不可变的任意精度的整数，其提供所有Java的基本整数操作符的对应物，并提供java.lang.Math的所有相关方法，还提供：模运算、GCD计算、质数测试、素数生成、位操作以及一些其他操作<br>    包:java.math<br>    使用：<br>        构造器：BigInteger(String val)，根据字符串构建BigInteger对象    </p>
<p>###BigDecimal类<br>    说明：表示精度要求比较高的数字，该类支持不可变的、任意精度的有符号十进制定点数<br>    包：java.math<br>    使用：<br>        构造器：BigDecimal(double val/String val)<br>    常用方法：<br>        add：<br>        substract：</p>
<p>###字符串相关的类<br>    （1）string<br>            特征：<br>                a.不可被继承：String类是一个final类<br>                b.内部定义了final char[] value用于存储字符串数据<br>                c.字符串是支持序列化： String实现了Serializable接口<br>                d.String可以比较大小： 实现了Comparable接口<br>                e.不可变性： String代表不可变的字符序列<br>                    体现：<br>                        1-当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值<br>                        2-当对现有的字符串进行链接操作时，也需要重新指定内存区域赋值<br>                        3-当调用replace()方法修改指定字符或字符串时，也需要重新制定内存区域赋值<br>                f.通过字面量直接赋值(区别于new)的方式给一个字符串复制，此时字符串值生命在方法区的字符串常量池中（字符串常量池中不会存储相同内容的字符串）<br>                g.通过new+构造器方式的方式直接进行实例化，其数据是存储在堆空间中开辟空间以后对应的地址值所指向的常量池<br>                h.常量与常量短的拼接结果在常量池，且常量池中不会存在相同内容的常量，只要其中一个是变量，结果就在堆中</p>
<pre><code>        JVM中字符串常量池存放位置：
            jdk1.6（jdk 6.0 ,java 6.0）：字符串常量池存储在方法区(永久区)
            jdk1.7：字符串常量池存储在堆空间
            jdk1.8：字符串常量池存储在方法区(元空间)


        数据类型转换：
            a.String----&gt;基本数据类型、包装类之间的转换：
                调用包装类的静态方法：parseXxx(str)
            b.基本数据类型、包装类----&gt;String:
                调用String重载的valueOf(xxx)
            c.String----&gt;char[]之间的转换
                调用String的toCharArray()
            d.char[]----&gt;String：
                调用String的构造器
            e.Stirng---&gt;byte[](该过程称为编码)：
                调用String的getBytes()：该函数使用默认的字符集，进行转换
            f.byte[]----&gt;String（该过程称为解码）：
                调用String的构造器：使用默认的字符集进行解码

        常用方法：
            string inten()：要求该函 数返回值在常量池当中
            int length()：返回字符串长度
            char charAt(int index)：返回某索引的字符
            boolean isEmpty()：判断是否是空字符串
            String toLowerCase()：使用默认语言环境，将String中的所有字符为小写
            String toUpperCase()：使用默认语言环境，将String中的所有字符转换为大写
            String trim()：返回字符串的副本，忽略前导空白和尾部空白
            boolean equals(Object obj)：比较字符串内容是否相同
            boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写
            String concat(String str)：将指定字符串链接到字符串的结尾，等价于“+”
            int compareTo(String anotherString)：比较两个字符串的大小
            String subString(int beginIndex)：返回一个新的字符串，从beginIndex开始截取
            String substring(int beginIndex,int endIndex)：返回一个新字符串，它是此字符串从beginIndex截取到endIndex

            boolean endWith(String suffix)：测试此字符串是否以指定的后缀结束
            boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始
            boolean startsWith(String prefix,int toffset)：测试此字符串从指定索引开始的子字符串是否以指定字符串开始

            boolean contains(CharSequence s)：当且仅当此字符串包含指定的char值序列时，返回true
            int indexOf(String str)：返回指定字符串在此字符串中第一次出现处的索引
            int indexOf(String str,inr fromIndex)：返回指定字符串在此字符串中第一次出现处的索引，从指定的索引开始
            int lastIndexOf(String str)：返回指定字符串在此字符串中最右边出现处的索引
            int lastIndexOf(String str,int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向操作
                注：indexOf和lastIndexOf未找到，都返回-1
            替换：
                String replace(char oldChar,char newChar)：返回一个新的字符串，他是通过用newChar替换此字符串中出现的所有oldChar得到
                String replace(CharSequence target,CharSequence replacement)：使用指定的字面值替换序列替换此字符串所以匹配字面值目标序列的子字符串
                String replaceAll(String regex,String replacement)：使用给定的replacement替换此字符串所有匹配给顶的正则表达式的子字符串
                String replaceFirst(String regex,String replacement)：使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串
            匹配：
                boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式
            切片：
                String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串
                String【】 split(String regex，int limut)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中 

（2）StringBuffer和StringBuilder
        与String的异同点
            a.String：不可变的字符序列，效率最低 
                内存解析:
                    底层使用char[]存储
            b.StringBuffer：可变的字符序列；线程安全的，效率低；
                内存解析：
                    底层使用char[]存储；调用构造器创建字符数组时，默认给数组扩容为16个字符，若给到指定长度，也在原数组上扩容16，但使用length()函数返回的长度不计算这16扩容，若要添加的数据底层数组盛不下，默认情况下，扩容为原来的2倍+2，同时将原有数组中的元素赋值到新的数组中，但这种操作会降低效率
            c.StringBuilder：可变的字符序列；jdk5.0新增，线程不安全的，效率高；
                内存解析：
                    底层使用char[]存储；同StringBuilder一致 

        常用方法：
            append()：提供了很多的append()方法，用于进行字符串拼接
            delete(int start,int end)：删除指定位置的内容
            replace(int start,int end,String str)：把[start,end)位置换位str
            insert(int offset,xxx)：在指定位置插入xxx
            reverse()：把当前字符序列逆转
            setCharAt(int n,char ch)：修改指定位置的字符
            注：
                append和insert时，如果原来的value数组长度不够，可扩容
                以上的方法支持方法链操作
                方法链原理</code></pre>
<hr>
<p>###日常使用<br>（1）Eclipse快捷键(可到preference当中的keys进行修改)</p>
<pre><code>（1）补全代码的声明：alt + /
（2）快速修复：ctrl + 1
（3）批量导包：ctrl + shift + o
（4）多行注释：ctrl + shift + /（取消使用 \ ）
（5）复制指定行的代码：ctrl + alt +down 或 ctrl + alt + up
（6）删除指定行的代码：ctrl + d
（7）上下移动代码：alt + up 或 alt + down
（8）切换到下一行代码空位：shift + enter（上一行则 + ctrl）
（9）查看源码：ctrl + 选中指定结构 或 ctrl + shift + t
（10）退回到前一个编辑页面：alt + left（下一个编辑界面则是alt + right）
（11）光标选中指定的类，查看继承树结构：ctrl + t
（12）撤销与反撤销：ctrl + z/y
（13）格式化代码：ctrl + shift +f
（14）在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o
（15）批量修改指定的变量名、方法名、类名等：alt + shift + r
（16）选中结构的大小写的切换：ctrl + shift + x/y
（17）调出生成getter/setter/构造器等结构：alt + shift + s
（18）显示当前选择资源（工程 或 文件）的属性：alt + enter
（19）快速查找.参照选中的word快速定位到下一个：ctrl + k
（20）关闭所有窗口：ctrl + shift + w
（21）查看指定的结构使用过的地方：ctrl + alt + g
（22）查找与替换：ctrl + f
（23）最大化当前的View：ctrl + m
（24）直接定位到当前行的首位：home
（25）直接定位到当前行的末位：end</code></pre>
<p>（2）JUnit单元测试</p>
<pre><code>使用：
    a.选中当当前工程-右键选择：bulid path - add libraries -JUnit 4 - 下一步
    b.创建java类，进行单元测试，要求的Java类要求：1.此类权限为public 2.此类提供公共的无参构造函数
    c.此类中声明单元测试方法：此时的单元测试方法权限是public，没有返回值，没有形参
    d.此单元测试方法需要声明注解：@Test，并在单元测试类中导入：org.junit.Test包 </code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" data-id="ckn722y940006okub0eiidpc1" data-title="Java类库与基本操作" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java高级编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/27/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-03-27T14:37:01.185Z" itemprop="datePublished">2021-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/27/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">Java高级编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="高级编程"><a href="#高级编程" class="headerlink" title="#高级编程"></a>#高级编程</h2><p>##基础知识<br>1.进程<br>    定义：是程序依次执行过程，或正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程—–生命周期<br>    内容：<br>        （1）进程作为资源分配的单位，系统在运行时回味每个进程分配不同的内存区域 </p>
<p>2.线程</p>
<pre><code>定义：是一个程序内部的一条执行路径

内容：
    （1）线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器，线程切换的开销小
    （2）一个进程中的多个线程共享相同的内存单元/内存地址空间-&gt;它们从同一个堆中分配对象，可以访问相同的变量和对象


生命周期：
    ![avatar](D:/ComputerUse/blog/img/live.jpg)

多线程的创建：
    （1）方式一：继承于Thread类
        使用：
            a.创建一个Thread类的子类
            b.重写Thread类的run()----&gt;将此线程执行的操作声明在run()中
            c.创建Thread类的子类对象
            d.通过此对象调用start()：该函数会启动当前线程，并调用当前线程的run()

    （2）方式二：实现Runnable接口------&gt;该方法的实现没有类单继承的局限性，更适合用来处理多个线程有共享数据的情况
        使用：
            a.创建一个实现了Runnable接口的类
            b.实现类去实现Runnable中的抽象方法：run()
            c.创建实现类的对象
            d.将此对象作为参数传递到Thread类中的构造器中，创建Thread类的对象
            e.通过Thread类的对象调用start()：启动线程，然后调用当前线程的run()-----&gt;调用了Runnable类型的target的run()

    （3）方式三：实现Callable接口
        使用：
            a.创建一个实现Callable的实现类
            b.实现call方法，将此线程需要执行的操作声明在call()中
            c.创建Callable接口实现类的对象
            d.将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象
            e.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
            f.获取Callable中Call方法中的返回值------&gt;可以通过get()得到返回值
        注：
            a.其call()方法，可以有返回值
            b.方法可以抛出异常，被外面的操作捕获，获取异常信息 
            c.支持泛型的返回值
            d.需要借助FutureTask类

    （4）方式四：使用线程池
            作用：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中，可以避免频繁创建销毁、实现重复里哟
            优点：提高响应速度、降低资源消耗、便于线程管理
            使用：
                a.提供指定线程数量的线程池：ExexcutorService service = Exectors.newFixedThreadPool( &lt;!-- 线程数量 --&gt; )
                b.执行指定线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象
                    service.excute( &lt;!-- 实现Runnable接口类的对象 --&gt; )
                    service.submit( &lt;!-- 实现Callable接口类 的对象 --&gt; )
                c.关闭线程池：service.shutdown()
            注：可以通过强制类型转换的方式，将ExecutorService转换成ThreadPoolExecutor类型对象，对线程池的属性进行设置


Thread类常见的方法：
    start()：启动线程，并执行run()方法
    run()：线程在被调度时执行的操作
    String getName()：返回线程的名称
    void setName(String name)：设置该线程的名称
    static Thread currentThread()：返回当前线程，在Thread子类中就是this，通常用于主线程和Runnable实现类
    yeild()：释放当前CPU的执行权
    join()：在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到join的线程执行完，线程a才结束阻塞状态
    stop()：强制线程生命周期结束，不推荐使用
    boolean isAlive()：返回boolean，判断线程是否还活着
    sleep(long millitime)：让当前线程阻塞指定的millitime毫秒
    getPriority()：返回线程优先级
    setPriority(int newPriority)：改变线程的优先级

解决线程的安全问题
    同步机制：
        （1）方式一：同步代码块
                使用：
                    synchronized(同步监视器)&#123;
                        &lt;!-- 需要被同步的代码(即操作共享数据的代码) --&gt;
                    &#125;
                注：
                    a.同步监视器：俗称，“锁”。任何一个类的对象，都可以充当锁。在以上方法中，多个线程必须要共用同一把锁
                    b.在实现Runnable接口创建多线程方式中，可以考虑使用this充当同步监视器

        （2）方式二：同步方法
                使用：通过 synchronized+方法 的来使用
                注：
                    a.同步方法仍然设计到同步监视器，只是不需要我们显式的声明
                    b.非静态的同步方法的同步监视器是this，静态的同步方法的同步监视器是当前类的本身

    Lock锁：
        使用：通过生成ReentrantLock类的对象，手动的启动同步(Lock())，同时结束同步也需要手动的实现(unlock())
        注：
            a.Lock是显式锁，需要进行手动的开启和关闭，synchronized是隐式锁，除了作用域自动释放
            b.Lock只有代码块锁，synchronized有代码块锁和方法所
            c.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性

死锁：
    定义：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己所需要的同步资源，就形成了线程的死锁。出现死锁后，不会出现异常、提示，只是所有的线程都处于阻塞状态，无法继续

线程通信方法：
    方法：
        wait()：执行此方法，当前线程就进入阻塞状态
        notify()：执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，会优先唤醒优先级高的线程
        notifyAll()：执行此方法，会唤醒所有被wait的一个线程
    注：
        a.以上三个方法必须使用在同步代码块或同步方法中，同时其调用者必须是同步代码块或同步方法当中的同步监视器，否则会出现IllegalMonitorStateException异常
        b.上面三个方法是定义在java.lang.Object类中</code></pre>
<p>3.并行与并发<br>    定义：并行指的是多个CPU同时执行多个任务，并发指的是一个CPU(采用时间片)同时执行多个任务</p>
<p>###枚举类与注解<br>1.枚举类<br>    包：定义的枚举类默认继承于java.lang.Enum<br>    说明：<br>        a.类的对象只有有限个，确定的。当需要定义一组常量时，强烈建议使用枚举类<br>        b.如果枚举类当中只有一个对象，则可以作为单例模式的实现方式<br>        c.定义枚举类：<br>            （1）jdk5.0之前，自定义枚举类<br>                1-声明对象的属性权限为：private final<br>                2-私有化构造器，并给对象属性私有化<br>                3-提供当前枚举类的多个对象</p>
<pre><code>        （2）jdk5.0，可以使用enum关键字定义枚举类
            1-提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束
    d.使用enum关键字定义的枚举类实现接口：当我们需要在调用指定枚举类时进行不同的操作，则在枚举对象后进行重写

常用方法：
    valueOf()：返回枚举类型的对象数组，该方法可以很方便的遍历所有的枚举值。也可以给其赋值一个字符串，可以索引指定名字的枚举对象，要求字符串必须是枚举对象的&quot;名字&quot;，否则会运行异常
    toString()：返回当前枚举对象常量名称</code></pre>
<p>2.注解<br>    说明：<br>        是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。可以用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在Annotation的”name=value”对中</p>
<pre><code>使用示例：
    a.使用Annotation时要在前面增加@符号，并把该Annotation当成一个修饰符使用
    b.在编译时进行格式检查（JDK内置的三个基本注解Override\Deprecated\SuppressWarnings）
    c.跟踪代码依赖性，实现替代配置文件功能
    d.spring框架中关于“事务”的管理

自定义注解：自定义注解必须配上注解的信息处理流程(使用反射)才有意义
    a.定义新的Annotation类型使用@interface关键字
    b.内部成员，通常使用value表示，可以指定成员的默认值，使用default定义。如果自定义注解没有成员，表示是一个标识作用。

元注解：    
    说明：用于修饰其他Annotation定义，对现有的注解进行解释说明的注解
    使用：
        Retention：只能用于修饰一个Annotation定义，用于指定该Annotation的生命周期---》SOURCE\CLASS(默认行为)\RUNTIME(能通过反射)
        Target：用于指定被修饰的Annotation能用于修饰哪些程序元素
        Documented：用于指定那个被盖院Annotation修饰的Annotation类将被javadoc工具提取成文档。默认情况下，javadoc是不包括注解的
        Inherited：被它修饰的Annotation将具有继承性

jdk8中注解的新特性
    可重复注解：@Repeatable
    类型注解：
        ElementType.TYPE_PARAMETER：表示该注解能写在类型变量的声明语句中（如：泛型声明）
        ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中</code></pre>
<p>###java集合</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/27/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" data-id="ckn722y8r0003okuba4q0g52w" data-title="Java高级编程" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2021-03-22T06:51:03.838Z" itemprop="datePublished">2021-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="设计模式"><a href="#设计模式" class="headerlink" title="#设计模式"></a>#设计模式</h2><p>##单例设计模式<br>    描述：采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，能够减少系统性的开销<br>    实现方法：<br>        1.饿汉式：其是线程安全的，但加载时间相对更长<br>            （1）私有化类的构造器<br>            （2）内部创建类的对象（也必须声明为静态）<br>            （3）提供公共的静态方法，返回类的对象<br>        2.懒汉式：能够延迟对象的创建，但目前是线程不安全的<br>            （1）私有化类的构造器<br>            （2）声明当前类对象，没有初始化（此对象也须声明为static）<br>            （3）声明public、static的返回当前类对象的方法</p>
<hr>
<p>##模板方法设计模式<br>    描述：当功能内部一部分实现是确定的，一部分是现实不确定的。这时可以把不确定的部分暴露出去，让子类去实现，这是一种模板模式</p>
<hr>
<p>##代理模式<br>    描述：代理设计就是为其他对象提供一种代理以控制对这个对象的访问<br>    应用场景：<br>        安全代理：屏蔽对真实角色的直接访问<br>        远程代理：通过代理类处理远程方法调用(RMI)<br>        延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象<br>    分类：<br>        静态代理：静态定义代理类<br>        动态代理：动态生成代理类</p>
<hr>
<p>##工厂设计模式<br>    描述：实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="ckn722y8u0004okub27wah1b7" data-title="设计模式" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-STL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/15/STL/" class="article-date">
  <time class="dt-published" datetime="2021-03-15T12:07:43.502Z" itemprop="datePublished">2021-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/15/STL/">STL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="STL"><a href="#STL" class="headerlink" title="#STL"></a>#STL</h2><h2 id="stl的使用"><a href="#stl的使用" class="headerlink" title="##stl的使用"></a>##stl的使用</h2><p>###pair的使用</p>
<pre><code>定义：
    （1）pair&lt;数据类型,数据类型&gt; p;
    （2）pair&lt;int,int&gt; p(1,5),直接初始化其内容
    （3）pair&lt;int,int&gt; p[maxnum]，定义了一个pair类型数组

访问：
    通过first与second访问其前后的内容
使用：
    （1）向pair数组里面插入值
        （a）map&lt;int,int&gt; mp;
            mp.insert(make_pair(1,2));
        （b）pair&lt;int,int&gt; p[maxnum];
            p[i]=&#123;1,2&#125;;
注意：可以直接使用关系运算符进行比较，当first相同时会通过判别second的大小来比较</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/15/STL/" data-id="ckn722y8k0001okubfsrl6thb" data-title="STL" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-algorithm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/15/algorithm/" class="article-date">
  <time class="dt-published" datetime="2021-03-15T12:05:55.901Z" itemprop="datePublished">2021-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/15/algorithm/">algorithm</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="algorithm"><a href="#algorithm" class="headerlink" title="#algorithm"></a>#algorithm</h2><h2 id="算法学习"><a href="#算法学习" class="headerlink" title="##算法学习"></a>##算法学习</h2><p>###快速排序</p>
<pre><code>void quickSort(vector&lt;int&gt;&amp; arr,int left,int right)&#123;

    if(left&gt;=right)
        return;
    &lt;!--确定目标数与比较数的位置--&gt;
    int oldLeft = left,oldRight = right;

    &lt;!-- 用于记录序列是否排序完毕 --&gt;
    bool judge = true;
    int    target = arr[left];

    &lt;!-- 通过左右往返比较，确定目标值在序列当中的位置 --&gt;
    while(left&lt;right)&#123;
        while(left&lt;right &amp;&amp; arr[right]&gt;=target)&#123;
            right--;
            judge=false;
        &#125;
        arr[left] = arr[right];

        while(left&lt;right &amp;&amp; arr[left]&lt;=target)&#123;
            left++;
            judge=false;
        &#125;
        arr[right] = arr[left];
    &#125;
    arr[left] = target;

    &lt;!-- 将目标数左右两侧的序列分开进行排序 --&gt;
    if(!judge)&#123;
        quickSort(arr,oldLeft,left-1);
        quickSort(arr,left+1,oldRight);
    &#125;
    return ;
&#125;</code></pre>
<hr>
<p>###堆排序</p>
<pre><code>void adjustPos(vector&lt;int&gt;&amp; args,int markPos,int size)
&#123;
    &lt;!-- 左右叶节点  --&gt;
    int left = 2*markPos+1;
    int right = 2*markPos+2;

    &lt;!-- 记录最值位置，比较左右结点与根节点的大小  --&gt;
    int maxNums=markPos;
    if(left&lt;size &amp;&amp; args[left]&gt;args[maxNums])
        maxNums = left;
    if(right&lt;size &amp;&amp; args[right]&gt;args[maxNums])
        maxNums = right;
    if(maxNums!=markPos)&#123;
        swap(args[maxNums],args[markPos]);    
        adjustPos(args,maxNums,size);
    &#125;
    return ;
&#125;
void heapSort(vector&lt;int&gt;&amp; args)&#123;
    int markNode=args.size()/2-1;        &lt;!-- 最后一个非叶子节点位置 --&gt; 

    &lt;!-- 通过遍历非叶子结点，将其构造成大顶堆（升序）/小顶堆（降序） --&gt; 
    for(int i=markNode;i&gt;=0;i--)&#123;
        adjustPos(args,i,args.size());
    &#125;

    &lt;!-- 每次得到根节点为最大值  --&gt;
    for(int i=args.size()-1;i&gt;=1;i--)&#123;
        swap(args[i],args[0]);
        adjustPos(args,0,i);
    &#125;
    return ;
&#125;</code></pre>
<p>###哈希表</p>
<p>###优先队列</p>
<pre><code>功能：在优先队列中，元素被赋予优先级，当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出的行为特征

实现：
    class prorityQueue&#123;
        public:
            prorityQueue()&#123;

            &#125;
            &lt;!-- 对于基本类型的大/小顶堆  --&gt;
            void bigTopPile()&#123;
                &lt;!-- 等同于priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; a
                若要其置成小顶堆则
                    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; --&gt;
                priority_queue&lt;int&gt; a;          
                int s=0;
                while(cin&gt;&gt;s)&#123;
                    a.push(s);
                &#125;
                while(!a.empty())&#123;
                    cout&lt;&lt;a.top()&lt;&lt;&quot; &quot;;
                    a.pop();
                &#125;
                return ;
            &#125;

            &lt;!-- 使用pair做优先队列元素，先比较第一个元素，第一个相等比较第二个 --&gt;
            void pairPriorityQueue(int nums)&#123;
                priority_queue&lt;pair&lt;int,string&gt; &gt; pq;
                int pos;
                string posStr;
                pair&lt;int,string&gt; p1[nums];
                int i=0;
                while(cin&gt;&gt;pos&gt;&gt;posStr)&#123;
                    p1[i]=&#123;pos,posStr&#125;;
                    pq.push(p1[i]);
                    i++;
                &#125;
                while(!pq.empty())&#123;
                    cout&lt;&lt;pq.top().first&lt;&lt;&quot; &quot;&lt;&lt;pq.top().second&lt;&lt;endl;
                    pq.pop();
                &#125;
                return ;

            &lt;!-- 用自定义的类型做优先队列元素 --&gt;

            &#125;
    &#125;;</code></pre>
<p>###并查集</p>
<pre><code>作用：主要可以用于解决一些元素分组的问题，管理一系列不相交的集合
功能：
    （1）合并：把两个不相交的集合合并为一个集合
    （2）查询：查询两个元素是否在同一个集合中
实现：
    MergeQurey()&#123;
        nums=0;
        &lt;!-- 使用两个数组分别来记录当前点所连接的根节点，以及当前节点深度 --&gt;
        vector&lt;int&gt; t1(10001,0),t2(10000,1);
        pre = t1;
        rank = t2;
        for(int i=0;i&lt;10001;i++)
            pre[i]=i;
    &#125;
    &lt;!-- 用于搜寻当前结点的根节点 --&gt;
    int find(int j)&#123;
        if(pre[j] == j)
            return j;
        else
            return find(pre[j]);
    &#125;
    &lt;!-- 合并两个节点,比较两个节点的深度,尽量由深度短的节点,指向深度深的节点,减少节点长度,降低搜寻长度 --&gt;
    void orderMerge(int i,int j)&#123;
        int x= find(i),y = find(j);
        if(rank[x] &lt;= rank[y])&#123;
            pre[x] = y;
        &#125;else&#123;
            pre[y] = x;
        &#125;
        &lt;!-- 当两个节点深度相同，则二者相连 --&gt;
        if(rank[x] == rank[y] &amp;&amp; x!=y)
            rank[y]++; 
    &#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/15/algorithm/" data-id="ckn722y8p0002okub84so5m7g" data-title="algorithm" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JavaLearing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/08/JavaLearing/" class="article-date">
  <time class="dt-published" datetime="2021-03-08T06:43:23.566Z" itemprop="datePublished">2021-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<p>title: JavaLearing<br>tags: </p>
<hr>
<h2 id="Java学习"><a href="#Java学习" class="headerlink" title="#Java学习"></a>#Java学习</h2><p>##编程基础</p>
<hr>
<p>###基础知识杂记<br>1.进制转换</p>
<pre><code>二进制：0b开头
八进制：0开头
十六进制：0x开头</code></pre>
<p>2.运算符<br>    位运算符：</p>
<pre><code>    操作的都为整型数据
    右移运算符根据最高位的数来补充（&gt;&gt;&gt;都用0补）
    ~：正(负)数取反，各二进制码按补码各位取反
    运算符优先级：</code></pre>
<p>3.Scanner</p>
<pre><code>包：java.util.Scanner
对象生成：Scanner scanner = new Scanner(System.in);

int型数据：nextInt()
double型数据：nextDouble()
float型数据：nextFloat()
boolean型数据：nextBoolean()
char型数据：Scanner没有提供相关的方法，只能通过获取一个字符串，再通过String当中的charAt()获取

注意：需要根据相应的方法来输入指定类型的值，如果输入的数据类型与要求的类型不匹配时，会报异常</code></pre>
<p>4.条件转换语句</p>
<pre><code>switch结构中的表达式所允许的数据类型：
    byte、short、char、int、枚举类型（JDK5.0新增）、String类型（JDK7.0新增）</code></pre>
<p>5.可变个数形参(jdk5.0新增的内容)</p>
<pre><code>格式：数据类型 ... 变量名
使用：其性质与数组相同
注意：
    (1)    则其与本类名中方法名相同，形参类型也相同的数组之间不构成重载，二者不能共存
    (2)    在形参当中使用，必须声明在末尾
    (3)    最多只能声明一个可变形参</code></pre>
<p>6.Java中的参数传递机制：值传递</p>
<pre><code>如果参数是基本数据类型，此时实参赋给形参的是实参的真实存储的数据值
如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值 </code></pre>
<hr>
<p>###面向对象（程序设计要求高内聚、 低耦合）</p>
<p>1.对象的内存解析：</p>
<pre><code>堆：所有的对象实例以及数组都要在堆上分配
栈（虚拟机栈）：用于存储局部变量等
方法区：用于存储已被虚拟机加载的类信息、常量、静态、变量、即使编译器编译后的代码等数据
类属性：在内存当中加载到堆空间中
局部变量：在内存当中加载到栈空间中</code></pre>
<p>2.封装性：</p>
<pre><code>访问权限：用于修饰类以及类的内部结构：属性、方法、构造器、内部类
    (1)    private：类内部
    (2)    default（缺省）：private + 同一个包 
    (3)    protected：default + 不同包的子类
    (4)    public：proctected + 同一个工程
    注意：对于class的权限修饰只可以用public和default，public类可以在任意地方被访问，default类只可以被同一个包内部的类访问</code></pre>
<p>3.继承性：</p>
<pre><code>格式：class A extends B（子类A继承父类B后，子类A中就获取了父类B中声明的结构、属性和方法 ）
        A:子类、派生类、subclass
        B:父类、超类、基类、superclass

使用：
    （1）一个类只能有一个父类，java中的单继承性 
    （2）一个父类可以派生出多个子类
    （3）子父类是相对的
    （4）子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法

注意：
    （1）父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私 有的结构，只因为封装性的影响，使得子类不能直接调用父类的结构
    （2）如果没有显示的声明一个类的父类，则此类继承于java.lang.Object类（注：所有的java类，处java.lang.Object类之外，都直接或简介的继承于java.lang,Object类，也就意味着，所有Java类具有java.lang.Object类生命的功能）</code></pre>
<p>4.多态性：父类的引用指向子类的对象</p>
<pre><code>使用：
    （1）虚拟方法调用：子类中定义了伊夫雷同名同参数的方法，在多态情况下，将此时父类的方法成为虚拟方法，父类根据赋值给他的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期时无法确定的
    （2）有了对象多态性以后，在编译期中，我们只能调用父类中声明的方法，但在运行期，实际执行的时子类重写父类的方法
    （3）对象的多态性只适用于方法， 不适用于属性
    （4）使用对象的多态性时，内存实际上是加载了子类特有的属性和方法，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法，子类特有的属性和方法不能调用
    （5）可以使用强制类型转换向下转型，赋给子类对象（注意：使用强制类型转换，可能会出现ClassCastException异常，我们可以使用instanceof关键字进行判断）</code></pre>
<p>5.方法的重写（override/overwrite）：</p>
<pre><code>功能：重写后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的时子类重写父类的方法，进行覆盖操作
规定：
    （1）子类重写方法的权限修饰符不小父类被重写的方法的权限修饰符
    （2）返回值类型
        父类为void--------&gt;子类void
        父类为A类型-------&gt;子类为A类或A类的子类
        父类为基本数据类型---------&gt;子类为相同的基本数据类型
    （3）子类重写的方法抛出异常 类型不大于父类被重写的方法抛出的异常类型
注意：子类不能重写父类中声明为private的方法</code></pre>
<p>6.子类对象实例化的全过程</p>
<pre><code>（1）从结果上看：（继承性）
    子类继承父类够，就获取了父类中声明的属性或方法
    创建子类对象，在堆空间中就会加载所有父类中生命的属性
（2）从过程上看：
    当我们通过子类的构造器创建子类对象时，一定会直接或间接的调用其父类的构造器，进而调用父类的父类构造器，直到调用了java.lang,Object类中的空参的构造器为止。因此我们才可以看到内存中有父类的结构，子类对象才可以考虑进行调用</code></pre>
<p>7.关键字</p>
<pre><code>this关键字：
    功能：用来修饰属性、方法、构造器，可以理解为当前对象或当前正在创建的对象
    使用：
        在类的构造器和方法中我们可以使用“this.属性”或“this.方法”的方式，来调用当前正在创建的对象属性或方法/已存在的对象属性或方法，同时我们可以通过使用“this（形参列表）”的方式，来调用本类中指定的其他构造器，但是不能调用自己这个构造器 


package关键字：
    功能：为了更好的实现项目中类的管理
    使用：
        （1）使用其声明类或接口所属的包，声明在源文件的首行
        （2）属性名中每“.”一次，代表一层文件目录
        （3）同一个包下，不能命名同名的接口或类

import关键字：
    功能：在源文件中显式的使用import结构导入指定包下的类、接口 
    使用： 
        （1）声明在包的声明和类的声明之间
        （2）使用“xxx.*”的方式，表示可以导入xxx包下的所有结构
        （3）如果使用的类或接口是java.lang包下定义的或者是在本包下定义的，则可以省略import结构
        （4）如果在源文件中，使用了不同包下的同名类，则必须至少有一个需要以全类名的方式显示
        （5）使用“xxx.*”方式表明可以调用xxx包下的所有结构，但是如果使用的是xxx子包下的结构，则仍需导入 
        （6）import static：导入指定类或接口中的静态结构

super关键字（可以理解为父类的）
    功能：
        （1）可以在子类的方法或构造器当中，通过使用“super.属性”或“super.方法”的方式，显式的调用父类中声明的属性或方法，但是通常对其进行省略
        （2）当子类和父类中定义了同名的属性时，想要在子类当中调用父类中声明的属性，则必须显式的使用“super.属性”的方法，表明调用的时父类中声明的属性
        （3）当子类重写了父类中的方法后，若是需要在子类当中调用父类的方法时，则必须显式的使用“super.方法”的方式，表明调用的是父类被重写的方法
        （4）可以在子类的构造器中显式的使用“super(形参列表)”的方法调用父类中声明的指定构造器（注意：必须声明在子类构造器的首行，同时对于this(形参列表)或super(形参列表)，二者不能同时出现）
        （5）在构造器的首行中，没有显式的声明“this(形参列表)”或“super(形参列表)”，则默认调用的是父类中空参的构造器
        （6）在类的多个构造器中，至少有一个类的构造器实用了“super(形参)”，调用父类中的构造器

instanceof关键字
    功能：判断指定对象是否是指定类的实例
    格式：a instanceof A（a对象 A类）

static关键字：
    功能：静态的，可以用来修饰属性、方法、代码块、内部类
    使用：
        （1）属性：是否使用static修饰，分为静态属性(类变量)和非静态属性(实例变量)
                实例变量：所创建的每个对象都独立拥有一套类中的非静态属性
                静态变量：所创建的多个对象都共享一个静态变量，当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，进行了修改。同时，静态变量随着类的加载而加载，其加载要早于对象的创建，则可以通过 “ 类.静态变量 ” 的方式来进行调用
        （2）方法：其使用方法与属性一致
                注意：
                    a.在静态方法中，只能调用静态的方法或属性
                    b.在静态方法中，不可以使用this关键字、super关键字

final关键字：
    功能：可以用来修饰类、方法、变量
    使用：
        （1）用来修饰类，此类不能被其他类所继承
        （2）用来修饰方法，表明此方法不能被重写
        （3）用来修饰变量，此时变量称为“常量 ”，其赋值的位置有显式初始化、代码块中初始化、构造器中初始化。当使用final修饰形参时，表明此形参是一个常量，当我们调用此方法时，给常量形参赋一个实参，一旦赋值以后，就只呢在方法体内使用此形参，但不能进行重新赋值
        （4）static final用来修饰属性：全局常量

abstract关键字： 
    功能：可以用来修饰的类和方法 
    使用：
        修饰对象为类： 
            （1）此类不能实例化
            （2）此类中一定有构造器，便于子类实例化时调用（因此，在开发中都会提供抽象类的子类，让子类对象完成实例化，完成相关操作） 
        修饰对象为方法：
            （1）抽象方法只有方法的声明，没有方法体 
            （2）包含抽象方法的类，一定是个抽象类，而抽象类中可以没有抽象方法
            （3）若子类重写了父类中的所有抽象方法后，此子类方可实例化，若没有重写完父类中所有的抽象方法，此子类也是一个抽象类，需要使用abstract修饰 
    注意：
        （1）不能用来修饰属性、构造器等结构 
        （2）不能用来修饰私有方法、静态方法、final方法、final类

mian()方法
    功能： 
        （1）作为程序的入口
        （2）一个普通的静态方法
        （3）可以作为与控制台交互的方式 </code></pre>
<p>8.代码块（初始化块）</p>
<pre><code> 作用：用来初始化类、对象
 使用：
     （1）代码块如果有修饰的话，只能使用static
     （2）对于静态代码块：初始化类的信息 
             a.内部可以有输出语句
             b.随着类的加载而执行，而且只会执行一次
             c.如果类中定义了多个静态代码块，则按照声明的先后顺序执行
             d.只能调用静态结构
         对于非静态代码块：可以在创建对象时，对对象的等进行初始化
             a.内部可以有输出语句
             b.随着对象的创建而执行，每创建一次对象执行一次
             c.按照声明的先后顺序执行</code></pre>
<p>9.接口(interface)：Java中，接口和类是并列的两个结构</p>
<pre><code>使用：
    （1）在JDK7及以前：只能定义全局常量(public static final)和抽象方法(public abstract)，在JDK8以后：增加定义静态方法、默认方法
    （2）接口中不能定义构造器，意味着其不能实例化
    （3）Java开发中，接口通过让类去实现(implements)的方式来使用实例化，如果实现类覆盖了接口中所有的抽象方法，则实现类就可以实例化，若没有完全覆盖，则仍为抽象类
    （4）Java类中可以实现多个接口（弥补Java当中单继承性的局限性）
        格式：class AA extends BB implements CC,DD
    （5）接口与接口之间可以继承，而且可以多继承
    （6）接口中定义的静态方法，只能通过接口来调用
    （7）通过实现类的对象，可以调用接口中的默认方法。如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法
    （8）对于方法的类优先原则：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的方法，那么子类再没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法
    （9）接口冲突：在实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么实现类没有重写此方法的情况下，会报错。解决接口冲突则需在实现类当中重写此方法
    （10）在子类(或实现类)的方法当中调用父类、接口被重写的方法
            自己重写的方法：use();
            父类中声明的方法：super.use();
            接口中的默认方法：XXX.super.use()</code></pre>
<p>10.内部类</p>
<pre><code>描述：在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类
分类：
    （1）成员内部类(静态、非静态)：
        a.作为一个类：
            类内可以定义属性、方法、构造器等
            可以被final修饰，表示此类不能被继承
            可以被abstract修饰
        b.作为外部类的成员：
            可以调用外部类的结构
            可以被static修饰
            可以被4种不同的权限修饰

    （2）局部内部类(方法内、代码块内、构造器内)：在局部内部类的方法中，如果调用及局部内部类所声明的方法中的局部变量，要求此局部变量声明为final
使用：
    （1）实例化成员内部类对象
        example ：Person.Bird bird = new p.Bird()</code></pre>
<hr>
<p>###异常处理(抓抛模型)<br>    方法：<br>        （1）try-catch-finally：<br>                使用：<br>                    try{<br>                        可能出现异常的代码<br>                    }catch(异常类型1 变量名1){<br>                        处理异常的方式<br>                    }<br>                    ….<br>                    finally{<br>                        一定会被执行的代码(即使catch当中出现异常，或try当中出现return语句)<br>                    }</p>
<pre><code>        注意：
            a.finally是可选的
            b.catch中的若异常类型如果满足子父类关系，则要求子类一定声明在父类上面。否则，报错。
            c.使用该异常处理方式，处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错
            d.开发中，由于运行时异常比较常见，所以通常不针对运行时异常编写 方法来处理

    （2）throws+异常类型：
            使用：
                （1）写在方法的声明处，指明方法执行时，可能会抛出的异常类型。一旦方法体执行时出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码就不再执行
                （2）如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws

    （3）throw关键字：通过throw new 异常类的方法，从而可以手动生成异常对象，声明在方法体内

    （4）自定义异常类
            使用：
                （1）继承与现有的异常结构：RuntimeExeption\Exception
                （2）提供全局常量：serialVersionUID
                （3）提供重载的构造器</code></pre>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/08/JavaLearing/" data-id="ckn722y8a0000okub6j3ea4f6" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-后端开发路线" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF/" class="article-date">
  <time class="dt-published" datetime="2021-03-01T09:14:16.000Z" itemprop="datePublished">2021-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF/">后端开发路线</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="后端开发路线"><a href="#后端开发路线" class="headerlink" title="#后端开发路线"></a>#后端开发路线</h2><p>##编程基础</p>
<hr>
<p>###Java语言</p>
<p>1.语言基础：</p>
<pre><code>基础语法    面向对象    接口    容器    异常    泛型    反射        注释        I/O</code></pre>
<p>2.JVM虚拟机：</p>
<pre><code>类加载机制
字节码执行机制
JVM内存模型
GC垃圾回收
JVM性能监控与故障定位
JVM调优</code></pre>
<p>3.多线程/并发：</p>
<pre><code>并发编程基的基础
线程池
锁
并发容器
源子类
JUC并发工具类</code></pre>
<hr>
<p>###数据结构和算法</p>
<hr>
<p>###计算机网络</p>
<pre><code>1.ARP协议
2.IP协议、ICMP协议
3.TCP、UDP协议
4.DNS/HTTP/HTTPS协议
5.session/Cookie</code></pre>
<hr>
<p>###SQL/数据库</p>
<pre><code>1.SQL语句的书写
2.SQL语句的优化
3.事务、隔离级别
4.索引</code></pre>
<hr>
<p>###操作系统</p>
<pre><code>1.进程、线程
2.并发、锁
3.内存管理和调度
4.I/O原理</code></pre>
<hr>
<p>###设计模式：<br>    单例    工厂    代理    策略    模板方法    观察者    适配器    责任链    建造者</p>
<hr>
<p>##应用框架</p>
<hr>
<p>###Spring家族框架</p>
<p>1.Sprng</p>
<pre><code>IoC AOP</code></pre>
<p>2.SPringMVC</p>
<p>3.Spring Boot</p>
<pre><code>自动适配、开箱即用
整合Web
整合数据库（事务问题）
整合权限：
    Shiro\Spring Security</code></pre>
<p>4.整合各种中间件</p>
<pre><code>Redius    MQ    RPC框架    NIO框架</code></pre>
<hr>
<p>###服务器软件<br>1.web服务器</p>
<pre><code>Nginx</code></pre>
<p>2.应用服务器</p>
<pre><code>Tomcat    Jetty    Undertow</code></pre>
<p>3.中间件</p>
<pre><code>缓存：
    Redis：
        5大基础数据类型    事务        管道        持久化    集群

消息队列：
    RocketMQ    RabbitMQ    Kafa

RPC框架：
    Dubbo    gRPC    Thrift    Spring-Cloud    Netty</code></pre>
<p>4.数据库框架</p>
<pre><code>ORM层框架：
    Mybatis    Hibermate    JPA

连接池：
    Druid    HikariCP    C3P0

分库分表：
    MyCAT    Sharding-JDBC    Shardin-Sphere</code></pre>
<p>5.搜索引擎</p>
<pre><code>ElasticSearch    Soir</code></pre>
<p>6.分布式/微服务</p>
<pre><code>服务发现/注册：
    Eureka    Consul    Zookeeper    Nacos

网关：
    Zuui    Gateway

服务调用
    Ribbon    Feign</code></pre>
<p>7.熔断/降级</p>
<pre><code>Hystrix</code></pre>
<p>8.配置中心</p>
<pre><code>Config    Apollp    Nacos</code></pre>
<p>9.认证/鉴权</p>
<pre><code>Spring-Security    OAuth2    SSO单点登录</code></pre>
<p>10.分布式事务</p>
<pre><code>JTA接口：
    Atomiikos组件

2PC/3PC
XA模式

TCC模式：
    tcc-transaction    ByteTCC    EasyTransaction    Seata

SAGA模式：
    ServiceComb    Seate

LCN模式：
    tx-lcn</code></pre>
<p>11.任务调度</p>
<pre><code>Quartz    Elastic-Job</code></pre>
<p>12.链路追踪和监控</p>
<pre><code>Zipkin    Sleuth    Skywalking</code></pre>
<p>13.日志分析和监控</p>
<pre><code>ELK：
    ElasticSearch    Logstash    Kibana</code></pre>
<p>###虚拟化/容器化</p>
<p>1.容器技术</p>
<pre><code>Docker</code></pre>
<p>2.容器编排技术</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF/" data-id="ckn722y8v0005okubhvgehs2z" data-title="后端开发路线" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/06/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/">Java类库与基本操作</a>
          </li>
        
          <li>
            <a href="/2021/03/27/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">Java高级编程</a>
          </li>
        
          <li>
            <a href="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/2021/03/15/STL/">STL</a>
          </li>
        
          <li>
            <a href="/2021/03/15/algorithm/">algorithm</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>