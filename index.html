<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-计算机网络—物理层" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/" class="article-date">
  <time class="dt-published" datetime="2021-05-14T05:57:50.313Z" itemprop="datePublished">2021-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/">计算机网络——物理层</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="#计算机网络"></a>#计算机网络</h2><h2 id="物理层"><a href="#物理层" class="headerlink" title="##物理层"></a>##物理层</h2><p>###基本概念</p>
<pre><code>概念：解决如何在连接各种计算机传输媒体上传输数据比特流，而不是指具体的传输媒体

主要任务：确定与传输媒体接口有关的一些特性

定义特性：
    --机械特性：定义物理连接的特性
    --电气特性：规定传输二进制位时，线路上信号的电压范围、阻抗匹配等
    --功能特性：指明某条线上出现的某一电平表示和中医医，接口不见得信号线的用途
    --规程特性：定义各条物理线路的工作规程和时序关系</code></pre>
<p>###数据通信</p>
<pre><code>目的：传送消息
构成：
    --数据：传送信息的实体，通常是有意义的符号序列
    --信号：数据的电气/电磁表现，是数据在传输过程中的存在形式
        &lt;!-- 
            数字信号：代表消息的参数取值时离散的
            模拟信号：代表消息的参数取值是连续的
         --&gt;
    --信源：产生和发送数据的源头
    --信宿：接收数据的中带你
    --信道：信号的传输媒介。一般用来表示向某一个方向传送信息的介质，因此一条通信线路往往包含一条发送信道和一条接收信道

通信方式：
    --单工通信
    --半双工通信
    --全双工通信

数据传输方式：
    --串行传输：速度慢，费用低，适合远距离
    --并行传输：速度快，费用高，适合近距离，用于计算机内部数据传输

性能：
    --码元：是指一个固定时长的信号波形(数字脉冲)，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位
    --速率：数据率，是指数据的传输速率，表示单位时间内传输的数据量，可以用码元传输速率和信息传输速率表示</code></pre>
<p>###奈式准则（奈奎斯特定理）</p>
<pre><code>失真：
    --影响失真程度的因素：
        a.码元传输速率
        b.信号传输距离
        c.噪声干扰
        d.传输媒体质量

    --码间串扰：接收端收到的信号波形失去了码元之间清洗界限的现象

说明：在理想低通(无噪声，带宽受限)条件下为避免码间串扰，极限码元传输速率为2W Baud，W是信道带宽，单位是Hz
计算：理想低通信道下的极限数据传输率=2Wlog2V（单位是b/s，V是几种码元/码元的离散电平数目，w是带宽）
性质：

    --在任何信道中，码元传输的速率是有上限的，若传输速率超过此上限，就会出现严重的码间串扰问题
    --信道的频带越宽(即能通过的信号高频分量越多)，就可以用更高的速率进行码元的有效传输
    --奈式准则给出了码元传输速率的限制，但并没有对信息传输速率给出限制
    --由于码元的传输速率受奈式准则的制约，所以要提高数据的传输速率，就必须设法使每个码元能携带更多个比特的信息量，这就需要采用多元制的调制方法  </code></pre>
<p>###香农定理</p>
<pre><code>信噪比：
    --说明：信号的平均功率/噪声的平均功率
    --单位：1db = 10log10(S/N)

说明：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值
计算：
    信道的极限数据传输速率 = Wlog2(1+S/N)（单位b/s，W是带宽）

性质：
    --信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高
    --只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输
    --香农定理得出的为极限信息传输速率，实际信道能达到的传输速率要比它低不少</code></pre>
<p>###编码&amp;调制</p>
<pre><code>信道上传送的信号：
    --基带信号：将数字信号1和0直接用两种不同的电压表示，再送到数字信道上去传输(基带传输)，其可以是来自信源的信号或者就是发出的直接表达了要传输的信息的信号
    --宽带信号：将基带信号进行调制后形成的频分复用模拟信号，再传送到模拟信道上去传输(宽带传输)；把基带信号警告载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输(即仅在一段频率范围内能够通过信道)

性质：
    --编码：
        a.数字数据---&gt;数字信号
            方法：
                1-非归零编码：没有检错功能，且无法判断一个码元的开始和结束，以至于收发双方难以保持同步
                2-归零编码：信号电平在一个码元之内都要恢复到零的这种编码方式
                3-反向不归零编码：信号电平翻转表示0，信号电平不变表示1
                4-曼彻斯特编码：将一个码元分成两个相等的间隔，前低后高为1，前高后低为0；该编码的特点是在每一个码元的中间出现电平跳变，位中间的跳变既做时钟信号，又作数据信号，但它占的频带宽度是原始的基带宽度的两倍
                5-差分曼彻斯特编码：同1异0，常用于局域网传输，在每个码元中间，都有一次电平的跳转，可以实现自同步，且抗干扰性强于曼彻斯特编码
                6-4B/5B编码：比特流插入额外的比特以打破一连串的0或1，就是用5个比特来编码4个比特的数据，之后再传给接收方，编码效率为80%

        b.模拟数据---&gt;数字信号
            1-抽样
            2-量化
            3-编码

    --调制：
        a.数字数据---&gt;模拟信号
            方法：
                1-调幅(2ASK)
                2-调频(AFSK)
                3-调相(2PSK)
                4-调相+调幅(QAM)

        b.模拟数据---&gt;模拟信号</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/" data-id="ckoo0iqv0000bl8ubhz4s1hs6" data-title="计算机网络——物理层" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机网络—基础知识" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="article-date">
  <time class="dt-published" datetime="2021-05-12T08:15:33.935Z" itemprop="datePublished">2021-05-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机网络</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="#计算机网络"></a>#计算机网络</h2><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="##基础知识"></a>##基础知识</h2><p>###计网基础知识</p>
<pre><code>概念：
    --是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路链接起来，由功能完善的软件实现资源共享和信息传递的系统
    --互联的、自治的计算机集合

功能：
    --数据通信
    --资源共享
    --分布式处理：多台计算机各自承担同一工作任务的不同部分
    --提高分布式可靠
    --负载均衡

组成：
    --组成部分：硬件、软件、协议

    --工作方式：
        a.边缘部分：用户直接使用
            1-C/S方式
            2-P2P方式
        b.核心部分
            1-为边缘部分服务

    --功能组成：
        a.通信子网：实现数据通信
        b.资源子网：实现资源共享/数据处理

分类：
    --按分布范围：
        a.广域网    WAN
        b.城域网MAN
        c.局域网WAN
        d.个人区域网PAN

    --按使用者：
        a.公用网
        b.专用网

    --按交换技术：
        a.电路交换
        b.报文交换
        c.分组交换

    --按拓扑结构：
        a.总线型
        b.星型
        c.环形
        d.网状型

    --按传输技术：
        a.广播式网络：共享公共通信信道
        b.点对点网络：使用分组存储转发和路由选择机制

性能指标：
    --速率：又称数据率、数据传输率或比特率
        a.说明：连接在计算机网络上的主机在数字信道上传送数据位数的速率

    --带宽：
        a.说明：用爱表示网络的通信线路传送数据的能力，通常是治单位时间内从网络中的某一点到另一点所能通过的“最高数据率”

    --吞吐量：
        a.说明：单位时间内通过某个网络(或信道、接口)的数据量
        b.限制：受网络的带宽或网络的额定速率的限制

    --时延：
        a.说明：指数据(报文/分组/比特流)从网络(或链路)的一端传送到另一端所需的时间，也叫延迟或迟延，单位是s
        b.分类：
            1-发送时延(传输时延)：从发送分组的第一个比特算起，到该分组的最后一个比特发送完毕所需的时间(在主机内部完成)
                （1）计算：数据长度/信道带宽(发送速率)

            2-传播时延：取决于电磁波传播速度和链路长度(在信道上完成)
                （1）计算：信道长度/电磁波在信道上的传播速率

            3-排队时延：等待输出/输入链路可用

            4-处理时延：检错找出口

    --时延带宽积：
        a.说明：传播时延*带宽 

    --往返时延RRT：
        b.说明：从发送方发送数据开始，到发送方收到接收方的确认，总共经历的时延

    --利用率：
        a.分类：
            1-信道利用率
                （1）计算：有数据通过时间/(有+无)数据通过时间
            2-网络利用率：信道利用率加权平均值

分层：
    --分层原则：
        a.各层之间相互独立，每层只实现一种相对独立的功能
        b.每层之间界面自然清晰
        c.结构上课分隔开，每层都采用最合适的技术来实现
        d.保持下层对上层的独立性，上层单向使用下层提供的服务 
        e.整个分层结构应该能促进标准化工作

    --实体：第n层中的活动元素称为n层实体，同一层的实体叫做对等实体
    --协议：未进行网络中的对等实体数据交换而建立的规则、标准或约定成为网络协议(水平)
    --结构(访问服务点SAP)：上层使用下层服务的入口
    --服务：下层为相邻上层提供的功能调用(垂直)

    --OSI参考模型：

         a.应用层：所有能和用户交互产生网络流量的程序

         b.表示层：用于处理在两个通信系统中交换信息的表示方式(语法和语义)
             1-功能：
                 （1）数据格式变换
                 （2）数据加密解密
                 （3）数据压缩和恢复

         c.会话层：向表示层实体/用户进程提供建立连接并在连接上有序地传输数据，这是会话，也是建立同步(SYN)
             1-功能：
                 （1）建立、管理、终止会话
                 （2）使用校验点可使会话在通信失效时从校验点/同步点继续恢复通信，实现数据同步(适用于传输大文件)


         d.传输层：负责主机中两个进程地通信，即端到端地通信。传输单位是报文段或用户数据报
             1-功能：
                 （1）可靠传输、不可靠传输
                 （2）差错控制
                 （3）流量控制
                 （4）复用分用
                     --复用：多个应用层进程可同时使用下面运输层的服务
                     --分用：运输层把收到的信息分别交付给上面应用层中相应的进程

         e.网络层：主要任务是把分组从源端传到目的端，为分组交换网上的不同主机提供通信服务。传输单位是数据报
             1-功能：
                 （1）路由选择：最佳路径
                 （2）流量控制
                 （3）差错控制
                 （4）拥塞控制

         f.数据链路层：主要任务是把网络层传下来的数据报组转成帧；传输单位是帧
             1-功能：
                 （1）成帧(定义帧地开始和结束)
                 （2）差错控制：帧错+位错
                 （3）流量控制
                 （4）访问(接入)控制：控制对信道地访问

         g.物理层：在物理上实现比特流的透明传输；传输单位是比特
             1-功能：
                 （1）定义接口特性
                 （2）定义传输模式
                 （3）定义传输速率
                 （4）比特同步
                 （5）比特编码

    --TCP/IP参考模型：

        a.应用层
        b.传输层
        c.网际层
        d.网络接口层

    --五层参考模型
        a.应用层：支持各种网络应用
        b.传输层：进程-进程的数据传输
        c.网络层：源主机到目的主机的数据分组路由与转发
        d.数据链路层：把网络层传下来的数据报组转成帧
        e.物理层：比特传输

    --OSI模型与TCP/IP模型的异同
        a.相同点：
            1-都分层
            2-基于独立的协议栈的概念
            3-可以实现异构网络互联

        b.不同点：
            1-OSI定义三点：服务、协议、接口
            2-OSI先出现，参考模型先于协议发明，不偏向特定协议
            3-TCP/IP设计之初就考虑到异构网互联问题，将IP作为重要层次 
            4-OSI在网络层上是进行无连接+面向连接的传输而TCP/IP是无连接，在传输层上OSI支持面向连接，而TCP/IP支持无连接+面向连接</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" data-id="ckoo0iquy000al8ubc4qp02mf" data-title="计算机网络" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java编程杂记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/11/java%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-05-11T06:59:25.165Z" itemprop="datePublished">2021-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/11/java%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/">Java编程杂记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="java编程杂记"><a href="#java编程杂记" class="headerlink" title="#java编程杂记"></a>#java编程杂记</h2><p>##集合</p>
<pre><code>--List是一个接口
--HashSet常用方法：https://www.cnblogs.com/qilin20/p/12300384.html</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/11/java%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/" data-id="ckoo0iquo0004l8uba2ga9912" data-title="Java编程杂记" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统—设备管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-05-10T04:14:52.843Z" itemprop="datePublished">2021-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/">操作系统——设备管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="#操作系统"></a>#操作系统</h2><h2 id="设备管理"><a href="#设备管理" class="headerlink" title="##设备管理"></a>##设备管理</h2><p>###磁盘</p>
<pre><code>调度算法：
    --先来先服务
    --最短寻找时间优先(SSTF)
    --扫描算法(SCAN)：只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动
    --Look调度算法：如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动的方向
    --循环扫描算法(C-SCAN)：规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求
    --C-Look算法：  如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁头访问请求的位置即可

减少延迟时间的方法：
    --交替编号：
        a.方法：让编号相邻的扇区在物理上不相邻
        b.原理：读取完一个扇区需要一段事件处理才可以继续读入下一个扇区
    --错位命名：
        a.方法：让相邻盘面的山区编号“错误”
        b.原理：与交替编号方法相同

磁盘地址结构：
    --采用（柱面号，盘面号、扇区号）的结构
    --原因：在读取地址连续的磁盘块时，该结构不需要移动磁头

磁盘的管理：
    --磁盘初始化：
        a.进行低级格式化(物理格式化)，将磁盘的各个磁道划分为扇区；一个扇区通常可分为头、数据区域、尾三个部分组成
        b.将磁盘分区，每个分区由若干柱面组成
        c.进行逻辑格式化，创建文件系统

    --引导块：计算机启动时需要运行初始化程序(自荐程序)来完成初始化

    --坏块：无法正常使用的扇区，属于硬件故障
        a.简单的逻辑磁盘：逻辑格式化时将坏块标记出来
        b.复杂的磁盘：磁盘控制器维护一个坏块链，并管理备用扇区</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/" data-id="ckoo0iquw0008l8ub0uvihzpn" data-title="操作系统——设备管理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统—文件管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T12:01:09.246Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/">操作系统——文件管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="#操作系统"></a>#操作系统</h2><h2 id="文件管理"><a href="#文件管理" class="headerlink" title="##文件管理"></a>##文件管理</h2><p>###文件</p>
<pre><code>说明：是一组有意义的信息/数据集合

属性：    
    --文件名
    --标识符：一个系统内的各文件标识符唯一
    --类型：指明文件类型
    --位置：文件存放的路径
    --大小
    --保护信息：对文件进行保护的访问控制信息

逻辑结构：
    --无结构文件(流式文件)
        说明：文件内部的数据就是一系列二进制流或字符流组成

    --有结构文件(记录式我呢见)
        说明：由一组相似的记录组成，每条记录由若干个数据项组成
        分类：
            （1）顺序文件：
                a.说明：
                    文件中的记录一个接一个地顺序排列(逻辑上)，各个记录在物理上可以顺序存储或链式存储
                b.分类：
                    1-链式存储
                        --特点：无法实现随机存取
                    2-顺序存储
                        --串结构：记录之间地顺序与关键字无关
                        --顺序结构：记录之间地顺序按关键字顺序排列
                        --特点：
                            若是可变长记录，无法实现随机存取；
                            若是定长记录，可实现随机存取；
                            若是采用串结构，无法快速找到某关键字对应的记录；
                            若采用顺序结构，可以快速找到某关键字对应地记录；

            （2）索引文件：
                a.说明：
                    建立一张索引表以加快文件检索速度，每条记录对应一个索引项
                    &lt;!-- 
                        索引表：本身是定长记录文件，每当要增删一个记录时，需要对索引表进行修改；主要用于对信息处理的及时性要求比较高的场合；
                     --&gt;</code></pre>
<p>###文件目录</p>
<pre><code>文件控制块(FCB)：指目录文件中地一条记录
    --说明：
        FCB的有序集合就是文件目录；
        一个FCB就是一个文件目录项，其中包含了文件的基本信息，存取控制信息以及使用信息；
        FCB实现了文件名和文件之间的映射，使用户可以实现“按名存取”

目录结构：
    --单级目录结构：
        a.说明：整个系统只建立一张目录表，每个文件占一个目录项
        b.特点：实现了“按名存取”，但是不允许文件重名

    --两级目录结构：
        a.说明：采用两级结构，分为主文件目录和用户文件目录
        b.特点：允许不同用户的文件重名，也可以在目录上实现访问限制，但是用户不能对自己的文件进行分类

    --多级目录结构(树形目录结构)：
        a.说明：系统根据绝对路径一层一层地找到下一级目录；
        b.特点：方便对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护，但是树形结构不便于实现文件的共享

    --无环图目录结构：
        a.说明：在树形结构的基础上，增加一些指向同一节点的有向边，使整个目录成为一个有向无环图；同时，需要为每个共享节点设置一个共享计数器，用于记录此时有多少个地方在共享该节点；用户提出删除节点的请求时，只是和三处该用户的FCB，并使共享计数器减1，并不会直接删除共享节点，只有当共享计数器为0时，才删除节点
        特点：更方便地实现多个用户间文件共享

索引结点：
    说明：是FCB的改进，除了文件名之外的文件描述信息都放到这里

文件的物理结构(分配方式)：
        &lt;!-- 操作系统为文件分配存储空间都是以块为单位的 --&gt;
    --连续分配：
        a.说明：要求文件在磁盘上占有一组连续的块
        b.存储：文件目录表中记录存放的起始块号和长度，根据逻辑块号就可以查找到文件的物理块号
        c.特点：
            1-支持随机访问
            2-在顺序读写时速度最快
            3-不方便拓展
            4-存储空间利用率低，会产生磁盘碎片

    --链接分配：
        a.隐式链接：
            1-说明：除文件的最后一个盘块之外，每个盘块中都存有指向下一个盘块的指针。文件目录包括文件第一块的指针和最后一块的指针
            2-特点：
                （1）只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间
                （2）很方便文件拓展，不会有碎片问题，外存利用率高

        b.显示链接：
            1-说明：把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表(FAT)，开机后FAT常驻内存
            2-存储：操作系统根据逻辑块号找到文件对应的目录项，从目录项中找到起始块号，查询内存中的文件分配表FAT，往后找到逻辑块号对应的物理块号，逻辑块号转换成物理块号地过程不需要读磁盘操作
            3-特点：
                （1）支持随即访问，也支持顺序访问
                （2）由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问的速度快很多
                （3）方便文件拓展，不会有碎片问题，外存利用率高
                （4）文件分配表地需要占用一定的存储空间

    --索引分配：
        a.说明：索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为索引块，文件数据存放的磁盘成为数据块
            &lt;!-- 索引表：建立逻辑页面到物理页之间地映射关系 --&gt;

        b.方案：
            1-链接方案：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放
                特点：若文件很大，索引表很长，索引效率低下
            2-多层索引：类似于多级页表
                特点：即使是小文件，访问一个数据块依然需要K+1次读磁盘
            3-混合索引：多种索引分配方式的结合
                特点：对于小文件来说，访问一个数据块所需的读磁盘次数更少

文件存储空间的管理
    --空闲表法：
        a.分配：空闲表中记录每个连续空闲区的起始盘块号、盘块数；分配时可采用首次适应、最佳适应等策略
        b.回收：注意表项的合并问题
    --空闲链表法：
        a.分配：操作系统保存着链头、链尾指针，若某文件申请K个盘块，则从链头开始一次摘下K个盘块分配，并修改空闲链的链头指针
        b.回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针
    --位视图法
    --成组链表法：适合大型文件系统

文件的基本操作
    --创建文件：
        a.在外存中找到文件所需的空间
        b.根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项 

    --删除文件：
        a.根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项
        b.根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块

    --打开文件：
        a.根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项，并检查该用户是否指定的操作权限、
        b.将目录项复制到内存中的“打开文件表”中，并将对应表目的编号返回给用户，之后用户使用打开文件表的编号来指明要操作的文件

    --关闭文件：
        a.将进程的打开文件表相应表象删除
        b.回收分配给该文件的内存空间等资源
        c.系统打开文件表的打开计时器count-1，若count为0，则删除对应表项

    --读文件：
        a.根据读指针、读入数据量、内存位置将文件数据从外存读入内存

    --写文件：
        a.根据写指针、写出数据量、内存位置将文件数据从内存写出外存  

文件共享：
    --基于索引结点的共享方式(硬链接)：
        a.各个用户的目录项指向同一个索引结点，索引结点中需要有链接计数count
        b.用户删除文件时，只是删除该用户的目录项，且count--，当count==0时才能真正删除文件数据和索引系欸但，否则会导致指针悬空

    --基于符号链的共享方式(软链接)    ：
        a.在一个Link型的文件中记录共享文件的存放路径，操作系统根据路径查找目录，获取共享文件
        b.即使软连接指向的共享文件已被删除，Link型文件依然存在，只是通过Link型文件中的路径去查找共享文件会失败
        c.由于用软链接的方式访问共享文件时要查询多级目录，会有多次磁盘I/O，因此用软连接访问

文件保护
    --口令保护
    --加密保护
    --访问控制：在每个FCB中增加一个访问控制列表，该表中记录了各个用户可以对该文件执行的操作权限

文件系统的层次结构
    --用户接口：用于处理用户发出的系统调用请求
    --文件目录系统：根据用户给出的文件路径找到相应的FCB或索引结点
    --存取控制模块：完成了文件保护相关功能
    --逻辑文件系统与文件信息缓冲区：需要将记录号转换为对应的逻辑地址
    --物理文件系统：把逻辑地址转换为实际的物理地址
    --辅助分配模块：负责文件存储空间的管理
    --设备管理模块：直接与硬件交互，负责和硬件直接相关的一些管理工作</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" data-id="ckoo0iqus0006l8ubckeogedt" data-title="操作系统——文件管理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统—进程管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T08:18:57.033Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">操作系统——进程管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="#操作系统"></a>#操作系统</h2><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="##进程管理"></a>##进程管理</h2><p>###进程</p>
<pre><code>定义（体现的是动态性）：
    --进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
    --进程是程序的一次执行过程
    --进程是一个程序及其数据在处理及上顺序执行时所发生的活动
    --进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位
    --进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立

组成： 程序段、数据段、PCB(进程控制块，其是进程存在的唯一标志)三部分组成了进程实体(进程映像)，一般情况下，就把进程实体简称为进程；进程实体是静态的，进程是动态的 

 组织方式：
     （1）链接方式：
         --按照进程状态将PCB分为多个队列，操作系统持有指向个个队列的指针
     （2）索引方式：
         --根据进程状态的不同，建立几张索引表，操作系统持有指向各个索引表的指针

 特征：
     （1）动态性：进程最基本的特征
     （2）并发性
     （3）独立性：晋城市系统进行资源分配、调度的独立单位
     （4）异步性：各进程以不可预知的速度向前推进，可能导致运行结果的不确定性
     （5）结构性

 进程的状态
     （1）运行态(Running)：占有CPU，并在CPU上运行，单核处理机环境下，每一时刻最多只有一个进程处于运行态
     （2）就绪态(Ready)：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行；进程已经拥有了除处理及之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行
     （3）阻塞态(Waiting/Blocked，又称等待态)：因等待某一件事而暂时不能运行
     （4）创建态(New，新建态)：进程正在被创建，操作系统为进程分配资源、初始化PCB
     （5）终止态(Terminated，结束态)：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

 进程控制：
     （1）创建
     （2）终止
     （3）阻塞
     （4）唤醒
     （5）切换

 进程通信：
     说明：是指进程之间的信息交换
     （1）共享存储：
         --基于数据结构的共享：速度慢，限制多，是一种低级通信方式
         --基于存储区的共享：速度更快，是一种高级通信方式
         ps：两个进程对共享空间的访问必须是互斥的（互斥操作通过操作系统提供的工具实现）

     （2）消息传递
         说明：进程间的数据交换以格式化的消息为单位；进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换
         --直接通信方式：消息直接挂到接收进程的消息缓冲队列上
         --间接通信方式（信箱通信方式）：消息要先发送到中间实体(信箱)中

     （3）管道通信：
             --“管道”是指用于连接读写进程的一个共享文件(pipe文件)，其实就是在内存中开辟一个大小固定的缓冲区
             --管道只能采用半双工通信，某一时间段内只能实现单向的传输；如果需要实现双向同时通信，则需要设置两个管道
             --各进程要互斥的访问管道
             --数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待都进程将数据取走。当都进程将数据全部取走后，管道变空，此时读进程的read()系     统调用统调用统的调用将被阻塞
             --数据一旦被读出，就从管道中被抛弃，意味着读进程最多只能有一个，否则可能会有读错数据的情况</code></pre>
<hr>
<p>###线程</p>
<pre><code>定义：
    --线程是一个基本的CPU执行单元，也是程序执行流的最小单元
    --线程是程序执行流的最小单元
    --线程可以理解为“轻量级进进程”

与进程的区别：
    --进程是资源分配的基本单位，线程是调度的基本单位

属性：
    --线程是处理机调度的单位
    --多CPU计算机中，各个线程可以占用不同的CPU
    --每个线程都有一个线程ID、线程控制块(TCB)
    --线程几乎不拥有系统资源
    --统一进程的不同线程间共享进程的资源
    --由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
    --同一进程中的线程切换，不会引起进程切换
    --不同进程中的线程切换，会引起进程切换
    --切换同进程内的线程，系统开销很小；切换进程，系统开销较大

实现方式：

    --用户级线程：
        （1）说明：
            --由应用程序通过线程库实现，所有线程管理工作都有应用程序负责(包括线程切换)
            --用户级线程中，线程切换在用户态下即可完成，无需操作系统干预
            --用户级线程对用户不透明，对操作系统透明

    --内核级线程：
        （1）说明：
            --内核级线程的管理工作由操作系统内核完成
            --内核级线程的切换需要在核心态下才能完成
            --内核级线程对用户透明，对操作系统不透明
            --内核线程是处理机分配的单位

多线程模型：

    --多对一模型：多用户对单内核，每个用户进程只对应一个内核级线程
        advantage：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
        disadvantage：当一个用户线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上并行运行

    --一对一模型：单用户对单内核
        advantage：当一个线程阻塞后，别的线程还可以继续执行，并发能力强；多线程可在多核处理机上并发执行
        disadvantage：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大

    --多对多模型：n用户对m内核，每个用户进程对应m个内核级线程
        action：克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的特点</code></pre>
<hr>
<p>###处理机调度：</p>
<pre><code>说明：处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理及分配给它运行，以实现进程的并发执行
分层：
    （1）高级调度(作业调度)：主要是指调入的问题
        --按一定的原则从外存上处于后备队列的作业中挑选一个(或多个)作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB)，以使得其获得竞争处理机的权力
        --高级调度是辅存与内存之间的调度，作业调入时会建立相应的PCB，作业调出时才撤销PCB

    （2）中级调度(内存调度)：
        --将暂时不能运行的进程调至外存等待，等它重新具备了运行条件且内存稍有空闲时，再重新调入内存；提高内存利用率和系统吞吐量
        --暂时调到外存等待的进程状态为挂起状态，PCB并不会一起调到外存，而是会常驻内存，PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统同过内存中的P     CB来保持对各个进程的监控、管理；被挂起的进程PCB会被放到挂起队列中
            &lt;!-- 
                挂起状态：指的是暂时调到外存等待的进程状态，为减轻系统负载，提高资源利用率
                    分类：
                        --就绪挂起
                        --阻塞挂起 
                    注意:
                        --&quot;挂起&quot;和&quot;阻塞&quot;两种状态都是暂时不能获得CPU的服务,但挂起状态是将进程映像调到外存去了,而阻塞态下进程映像还在内存中
            --&gt;

    （3）低级调度(进程调度)：
        --说明：
            （1）其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它
            （2）进程调度是操作系统中最基本的一种调度

        --过程：
            （1）队员来运行进程的各种数据的保存
            （2）对新的进程各种数据的恢复

        --调度时机：
            （1）需要进行进程调度和切换：
                --当前运行进程主动放弃处理机：
                    a.进程正常终止
                    b.运行过程中发生异常而终止
                    c.进程主动请求阻塞(如 等待I/O)
                --当前运行的进程被动放弃处理机：
                    a.分配给进程的时间片用完
                    b.有更紧急的事需要处理(如I/O中断)
                    c.有更高优先级的进程进入就绪队列
            （2）不能进行进程调度与切换
                --在处理中断过程中。
                --进程在操作系统内核程序临界区中
                    &lt;!--
                        临界资源：一个时间段内只允许一个进程使用的资源，各进程需要互斥地访问临界资源
                        临界区：访问临界资源的那段代码
                      --&gt;
                --在原子操作过程中

        --调度方式：
            （1）非剥夺调度方式(非抢占方式)：只允许进程主动放弃处理机
                特点：实现简单，系统开销小，但无法处理紧急任务；适合于早期的批处理系统
            （2）剥夺调度方式(抢占方式):允许进程被动放弃处理机
                特点：可以优先处理更紧急的进程，也可以实现让各进程按时间片轮流执行的功能(通过时钟中断)；适合于分时操作系统、实时操作系统

调度指标：
    （1）CPU利用率：指CPU“忙碌”的时间占总时间的比例
    （2）系统吞吐量：单位时间内完成作业的数量
    （3）周转时间：是指从作业被提交给系统开始，到作业完成为止的这段时间间隔
    （4）等待时间：指进程/作业处于等处理机状态事件之和
    （5）响应时间：只从用户提交请求到首次产生相应所用的时间

调度算法：
    （1）先来先服务(FCFS)
            --规则：按照作业/进程到达的先后顺序进行服务
            --使用：
                a.用于作业调度时，考虑的是哪个作业先到达后备队列
                b.用于进程调度时，考虑的是哪个进程先到达就绪队列
            --特性：
                a.非抢占式算法
                b.公平，算法实现简单
                c.对长作业有利，对短作业不利

    （2）短作业优先(SJF)
            --规则：最短的作业/进程优先得到服务（是指要求服务时间最短）
            --使用：既可用于作业调度，也可用于进程调度
            --特性：
                a.SJF和SPF(短进程优先算法)是非抢占式算法，而SRTM(最短剩余时间优先算法)是抢占式算法
                b.“最短的”平均等待时间、平均周转时间
                c.不公平，作业/进程的运行时间是由用户提供的，并不一定真是，不一定能做到真正的短作业优先
                d.会导致饥饿现象，如果一直得不到服务，则称为“饿死 ”

    （3）高响应比优先(HRRN)
            --规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务
                &lt;!--
                    响应比 = (等待时间+要求服务时间)/要求服务时间 
                 --&gt;
            --使用：既可以用于作业调度,也可以用于进程调度 
            --特性：
                a.非抢占式算法
                b.综合考虑了等待时间和运行时间(要求服务时间);等待时间相同时,要求服务时间短的优先;要求服务时间相同时,等待时间长的优先 

    （4）时间片轮转算法(RR)
            --规则：按照各进程到达就绪队列的顺序，轮转让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队；如果两个进程在同一时刻到达，则默认新到达的进程先进就绪队列
            --使用：用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)
            --特性：
                a.抢占式算法；由时钟装置发出时钟中断来通知CPU时间片已到
                b.公平且响应快，适用于分时操作系统
                c.由于高频率的进程切换，因此有一定开销，不区分任务的紧急程度

    （5）优先级调度算法
            --规则：没个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程
            --使用：既可以用于作业调度，也可以用于进程调度
            --特性:
                a.具有抢占式和非抢占式
                b.用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各个作业/进程的偏好程度
                c.若源源不断地有高优先级进程到来，则可能导致饥饿

    （6）多级反馈队列调度算法
            --规则：
                a.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
                b.新进程到达时先进入第一级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级地队列，则重新放回该队列队尾
                c.只有第k级队列为空时，才会为k+1级队头地进程分配时间
                d.对各类进程相对公平(FSFC优点)；每个新到达地进程都可以很快得到响应(RR优点)；短进程都只用较少的时间就可完成(SPF优点)；不必实现估计进程的运行时间(避免用户作假)；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程(拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O进程就可以保持较高优先级)
                e.可能会产生饥饿现象</code></pre>
<hr>
<p>###进程同步和互斥</p>
<pre><code>进程同步：
    （1）说明：要让各并发进程按要求有序地推进
进程互斥：
    （1）说明：指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待，当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源
    （2）过程：
        --进入区：负责检查是否可以进入临界区，若可以，则应设置正在访问临界资源的标志，以阻止其他进程同时进入临界区
        --临界区：访问临界资源的代码
        --退出区：负责解除正在访问临界资源的标志
        --剩余区：做其他处理
        注意：
            进入去和退出区是负责实现互斥的代码段

    （3）原则：
        --空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
        --忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待
        --有限等待：对请求访问的进程，应保证能在有限的时间内进入临界区(保证不会饥饿)
        --让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待

    （4）软件实现方法：
        --单标志法：
            a.思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程进入临界区的权限只能被另一个进程赋予
        --双标志先检查法：
            a.思想：色织一个布尔型数组flag[]，数组中各个元素用来标记个进程想进入临界区的医院。每个进程在进入临界区之前先检查当前有没有别的想进入临界区，若没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区
            b.缺点：违反“忙则等待”原则
        --双标志后检查法：
            a.思想：先上锁后检查
            b.缺点：违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象
        --Peterson算法：
            a.思想：如果双方都争着进入临界区，则主动让对方先使用临界区
            b.缺点：未遵循让权等待

    （5）硬件实现方法：
        --中断屏蔽方法：
            a.思想：利用“开/关中断指令”实现（与原语的实现思想相同）
            b.过程：
                --关中断：关中断后即不允许当前进程被中断，也必然不会发生进程切换
                --临界区
                --开中断：直到而当前进程访问完临界区，在执行开中断指令，才有可能有别的进程上处理机并访问临界区
            c.优缺点：
                --简单、高效
                --不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)

        --TestAndSet指令(TestAndSetLock指令/TS指令)：
            a.思想：TSL指令是用硬件实现的，执行的过程不允许被中断
            b.优缺点：
                --实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
                --不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”

        --Swap指令(Exchange指令/XCHG指令)：
            a.思想：Swap指令是用硬件实现的，执行的过程不允许被中断
            b.优缺点：
                --实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
                --不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”</code></pre>
<hr>
<p>###信号量机制</p>
<pre><code>说明：进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步
    &lt;!-- 信号量：用来表示系统中某种资源的数量 --&gt;

使用：通过wait(S)和signal(S)原语，也就是PV操作，实现系统资源的“申请”和“释放”

分类：
    --整型信号量：用来表示系统中某种资源的数量 
        使用：通过该信号量表示系统中的资源，当所需资源大于0，则获取资源，当资源小于等于0，则循环等待
        缺点：存在“忙等”问题
    --记录型信号量：用记录型数据结构表示的信号量
        使用：在记录型数据结构当中有着等待队列，每次进行P操作时，对所需资源数-1，若所需资源数小于0，则将其阻塞，加入到等待队列当中（运行态-&gt;阻塞态）；在执行释放操作时，对所需资源数加1，若当前所需资源数仍然小于等于0，说明当前等待队列中还有阻塞进程，则分配资源给该进程（阻塞态-&gt;就绪态）

注意：实现互斥的P操作一定要在实现同步的P操作之后</code></pre>
<hr>
<p>###管程</p>
<pre><code>说明：是一种特殊的软件模块
组成：
    （1）局部于管程的共享数据结构说明
    （2）对该数据结构进行操作的一组过程
    （3）对局部于管程的共享数据设置初始值的语句
    （4）管程有一个名字

基本特征：
    （1）局部于管程的数据只能被局部于管程的过程访问
    （2）一个进程只有通过调用管程内的过程才能进入管程访问共享数据
    （3）每次仅允许一个进程在管程内执行某个内部过程（这种互斥特性是由编译器负责是实现的）
    （4）可在管程中设置条件变量及等待/唤醒操作以解决同步问题，可以让一个进程或线程在条件变量上等待(此时，该进程应先释放管程的使用权)，可以通过唤醒操作将等待在条件变量上的线程或进程唤醒</code></pre>
<hr>
<p>###死锁</p>
<pre><code>说明：在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象

条件：
    （1）互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁
    （2）不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放
    （3）请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放
    （4）循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程所获得的资源同时被下一个进程所请求
    注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁

处理：
    （1）预防死锁：破坏死锁产生的四个必要条件中的一个或几个
            --破坏互斥条件：将互斥使用的资源改造为允许共享使用，如SPOOLing技术将打印机改为共享设备
                缺点：并不是所有的资源都可以改造成可共享使用的资源

            --破坏不剥夺条件：
                缺点：
                    a.实现起来比较复杂
                    b.释放获得的资源可能造成前一阶段工作的失效，因此这种方法一般只适用于易保存和恢复状态的资源，如CPU
                    c.反复地申请和释放资源会增加系统开销，降低吞吐量
                    d.可能会导致饥饿现象

            --破坏请求和保持条件：采用静态分配方法；即进程在运行前一次申请完它所需要地全部资源，在它地资源未满足前，不让其投入运行，一旦投入运行后，指定资源就一直归其使用，该进程就不会在请求别的任何资源
                缺点：
                    a.可能会造成严重的资源浪费，资源利用率极低
                    b.可能导致某些进程饥饿

            --破坏循环等待条件：可采用顺序资源分配法；给系统中的资源编号，规定每个进程必须按编号递增地顺序请求资源，同类资源一次申请完
                缺点：
                    a.不方便增加新的设备，因为可能需要重新分配所有编号
                    b.进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费
                    c.必须按规定次序申请资源，用户编程麻烦

    （2）避免死锁：如银行家算法
            &lt;!-- 安全状态:指如果系统按照这种序列分配资源,则每个进程都能顺利完成;只要找出一个安全序列,系统就是安全状态;如果系统处于安全状态,就一定不会发生死锁;如果处于不安全状态,就可能发生死锁 --&gt;
            银行家算法:
                a.思想:在进程提出资源申请时,先预判此次分配是否会导致系统进入不安全状态,如果会进入不安全状态,就暂时不答应这次的请求,让该进程先阻塞等待
                b.步骤:
                    1-检查此次申请是否超过了之前声明地最大需求数
                    2-检查此时系统剩余地可用资源是否还能满足这次请求
                    3-试探着分配,更改各数据结构
                    4-用安全性算法检查此次分配是否会导致系统进入不安全状态
                    &lt;!-- 安全性算法:检查当前地剩余可用资源是否能满足某个进程的最大需求,如果可以,就把该进程加入安全序列,并把该进程持有的资源全部回收,不断重复 --&gt;

    （3）死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁
            --死锁的检测:
                a.条件:
                    1-用某种数据结构来保存资源的请求和分配的信息
                    2-提供一种算法,利用上述信息来检测系统是否已进入死锁状态
                b.资源分配图:
                    1-结点:进程结点\资源结点
                    2-边:
                        --请求边:进程结点--&gt;资源结点
                        --分配边:资源结点--&gt;进程结点
                c.死锁检测算法:
                    1-方法:依次消除与不阻塞进程相连的边,直到无边可消
                        &lt;!-- 
                            所谓不阻塞进程是指申请的资源数还足够的进程 
                            --&gt;
                    2-结果:用死锁检测算法花间资源分配图后,还连着那些进程就是死锁进程

            --死锁的解除:
                a.资源剥夺法:挂起(暂时放到外存上)某些死锁进程,并抢占它的资源,将这些资源分配给其他的死锁进程,但是应防止被挂起的进程长时间得不到资源而饥饿
                b.撤销进程法(终止进程法):强制撤销部分\甚至全部死锁进程,并剥夺这些进程的资源
                    优缺点:实现简单,但是付出的代价可能会很大
                c.进程回退法:让一个或多个死锁进程回退到足迹避免死锁的底部,这就要求系统要记录进程的历史信息,设置还原点</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" data-id="ckoo0iqvd000el8ubafte0rrf" data-title="操作系统——进程管理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统—内存管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T08:17:30.054Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">操作系统——内存管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="#操作系统"></a>#操作系统</h2><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="##内存管理"></a>##内存管理</h2><p>###内存基础知识</p>
<pre><code>说明:是用于存放数据的硬件(程序执行前需要先放到内存中才能被CPU处理)

链接方式：由目标模块生成装入模块，链接后形成完整的逻辑地址

    （1）静态链接：在程序运行之前先将各模块及它们所需的库函数连接成一个完整的可执行文件(装入模块)，之后不再拆开
    （2）装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式
    （3）运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。
            优点：便于修改和更新，便于实现对目标模块的共享

装入方式:将装入模块装入内存，装入后形成物理地址

    （1）绝对装入:
            --实现：编译时产生绝对地址
                    &lt;!-- 只适用于单道程序环境 --&gt;

    （2）静态重定位(可重定位装入)：
        --实现：装入时将逻辑地址转换为物理地址
                &lt;!-- 要求：作业在装入内存时，必须分配其要求的全部内存空间，若空间不足，则不能装入改作业；同时一旦进入内存后，在运行期间就不能在移动，也不能再申请内存空间 --&gt;

    （3）动态重定位(动态运行时装入)：
        --实现：运行时将逻辑地址转换为物理地址，需设置重定位寄存器
                    &lt;!-- 重定位寄存器:存放装入模块存放的起始地址 --&gt;
        --优点：
            a.可以将程序分配到不连续的存储区中
            b.程序运行前只需要装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存
            c.便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</code></pre>
<hr>
<p>###内存管理</p>
<pre><code>管理者：操作系统

功能：
    （1）内存空间的分配与回收

            --连续分配管理方式：
                a.说明：指为用户进程分配的必须是一个连续的内存空间
                b.分类：
                        &lt;!-- 
                            内部碎片:分配给某进程的内存区域中,有部分没有使用
                            外部碎片:是指内存中的某些分区由于太小而难以利用
                         --&gt;
                    1-单一连续分配
                        --分区方式：
                            1.系统区：通常位于低地址部分，用于存放操作系统相关数据
                            2.用户区：用于存放用户进程相关数据，内存中只能有一道用户程序，用户程序独占整个用户区空间
                        --优点：
                            1.实现简单
                            2.无外部碎片；
                            3.可以用覆盖技术扩充内存
                            4.不一定需要采取内存保护
                        --缺点：
                            1.只能用于单用户、单任务的操作系统中
                            2.有内部碎片
                            3.存储器利用率低

                    2-固定分区分配
                        --分区方式：将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业
                            &lt;!-- 
                                对于分区大小相同：适合用于用一台计算机控制多个相同对象的场合,但是缺乏灵活性
                                对于分区大小不相等：增加了灵活性，可以满足不同大小的进程需求
                            --&gt;
                        --优点:实现简单,无外部碎片
                        --缺点:
                            1.当用户程序太大时,可能所有分区都不能满足需求,此时不得不采用覆盖技术来解决,但这又会降低性能
                            2.会产生内部碎片,利用率低
                        --注意：操作系统需要建立分区说明表，来实现各个分区的分配与回收

                    3-动态分区分配(可变分区分配)
                        --分区方式:在进程装入内存时,根据进程大小动态地建立分区
                        --记录内存的数据结构:
                            1.空闲分区表
                            2.空闲分区链
                        --优点:没有内部碎片
                        --缺点:存在外部碎片,可以使用紧凑技术来解决

                        --动态分区分配算法:
                            1.首次适应算法:从低地址开始查找,找到第一个满足大小的空闲分区
                            2.最佳适应算法:优先使用更小的空闲区,空闲分区按容量递增次序链接,每次分配内存时顺序查找空闲分区链/表
                                &lt;!-- 会产生很多的外部碎片 --&gt;
                            3.最坏适应算法:优先使用更大的空闲区,空闲区按容量递减次序链接,顺序查找
                                &lt;!-- 会导致较大的连续空闲区被迅速用完,导致之后&quot;大进程&quot;到达,没有内存分区可以使用 --&gt;
                            4.邻近适应算法:空闲分区以地址递增的顺序排列,每次分配内存从上次查找结束的位置开始查找

            --非连续分配管理方式
                a.分类：
                    1-分页存储管理：
                        --分区方式：操作系统以页框为单位为各个进程分配内存空间，进程的每个页面分别放入一个页框中，进程的页面与内存的页框有一一对应的关系；各个页面不必连续存放，也不必按先后顺序来
                            &lt;!-- 
                                页框（页帧/内存块/物理块）：内存空间所被分为一个个等大的分区，从0开始；页框不能太大，否则可能产生过大的内部碎片
                                页（页面）：用户进程的地址空间所被分为一个个与页框等大的区域，从0开始
                                页表：记录进程页面和实际存放内存块之间的对应关系，一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由“页号”和“块号”组成，每个页表项的长度是相同的，页号是“隐含”的
                             --&gt;
                        --逻辑地址结构（以32位为例）：
                            a.0~11位存放的是页内偏移量
                            b.12~31位存放的是页号

                        --基地址变换机构：可以借助进程的页表将逻辑地址转换为物理地址
                            &lt;!-- 快表的结构有效的增加了查询的速度  --&gt;

                    2-分段存储管理：
                        --分区方式：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编制；内存分配是以段为单位分配，每个段在内存中占据连续空间，但各段之间可以不相邻
                        --段表：
                            a.每个段对应一个段表项，其中记录了该段在内存中的起始位置和段的长度
                            b.各个段表的长度是相同的
                            c.段号是可以隐含的，不占存储空间

                    3-段页式管理方式：
                        --分区方式：分段+分页
                        --逻辑地质结构：段号、页号、页内偏移量
                        --段表：每个段对应一个段表项，各段表项长度相同，由段号(隐含)、页表长度、页表存放地址组成
                        --页表：每个页对应一个页表项，各个页表项长度相同，由页号(隐含)、页面存放的内存块号组成

                b.注意：
                    --分页对用户不可见，分段对用户可见
                    --分页的地址空间是一维的，分段是二维的
                    --分段更容易实现信息的共享和保护（纯代码/可重入代码可以共享）
                    --分页(单级页表)、分段访问一个逻辑地址都需要两侧访问，分段存储中也可以引入快表机构




    （2）对内存空间进行扩充

            --覆盖技术：
                a.实现：通过对内存设置固定区和覆盖区，对不能被同时访问的程序段共享同一个覆盖区
                &lt;!-- 缺点：对用户不透明，且需要由程序员声明覆盖结构，增加了用户编程的负担 --&gt;

            --交换技术
                a.实现：将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存
                &lt;!-- 
                    文件区：主要用于存放文件，主要追求存储空间的利用率，因此文件区空间的管理采用离散分配方式
                    对换区：其空间占磁盘空间的小部分，被换出的进程数据就存放在对换区，对换区采用连续分配方式(主要是为了追求换入换出速度)
                     --&gt;
                b.交换条件：通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停
                c.注意：PCB会常驻内存，不会换出外存

            --虚拟存储技术
                a.实现：虚拟内存的实现要建立在离散分配的内存管理方式基础上
                    --请求调页(或请求调段)
                    --页面置换(或段置换)
                        1-最佳置换算法(OPT)
                            说明：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，可以保证最低的缺页率
                        2-先进先出置换算法(FIFO)
                            说明：每次选择淘汰的页面是最早进入内存的页面
                            特点：实现简单，但算法性能差，会产生Belady异常
                                &lt;!-- Belady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象 --&gt;
                        3-最近最久未使用置换算法(LRU)
                            说明：每次淘汰的页面是最近最久未使用的页面
                            实现：赋予每个页面对应的页表项中，用访问字段记录该页面上次被访问以来所经历的时间t
                            特点：性能好，但是实现困难，开销大
                        4-时钟置换算法(CLOCK)：
                            实现：为每个页面设置一个访问位，再将内存中的也买你都通过链表指针连接成一个循环队列，当被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将其置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问未依次置为0后，再进行第二轮扫描

                        5-改进型的时钟置换算法
                            说明：在原来的时间置换算法的基础上，优先淘汰没有修改过的页面，避免I/O操作
                            实现：增加一个修改位，0表示没有被修改，反之，被修改过
                            特点：实现简单，算法开销小，性能也不错，但未考虑是否被修改过

                    --页面分配、置换策略
                        1-驻留集：指请求分页存储管理中给进程分配的物理块的集合

                    --操作：
                        1-页表机制：在基本分页的基础上增加了状态位、访问字段、修改位、外村地址
                        2-缺页中断机制：找到页表项后检查页面是否已在内存，若没在则会产生缺页中断
                            说明：
                                --将目标页面调入内存，有必要时还要换出页面
                                --缺页中断属于内中断，属于内中断中的“故障”，即可能被系统修复的异常
                                --一条指令在执行过程中可能产生多次缺页中断

    （3）实现地址转换（三种装入方式）
    （4）内存保护
            --方法：
                a.在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程指令要访问某个地址，CPU检查是否越界
                b.采用重定位寄存器(基地址寄存器)和界地址寄存器(限长寄存器)进行越界检查。重定位寄存器其中存放的是进程的起始物理地址。界地址寄存器存放的是进程的最大逻辑地址</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" data-id="ckoo0iquu0007l8ub0bn62m5x" data-title="操作系统——内存管理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-操作系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2021-04-29T11:31:00.942Z" itemprop="datePublished">2021-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="#操作系统"></a>#操作系统</h2><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="##基础知识"></a>##基础知识</h2><p>###操作系统</p>
<pre><code>定义：
    是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，是计算机系统中最基本的系统软件

功能：
    --作为系统资源的管理者：
        （1）处理机管理
        （2）存储器管理
        （3）文件管理
        （4）设备管理

    --作为永和和计算机硬件之间的接口：
        （1）命令接口：允许用户直接使用
            --联机命令接口
            --脱机命令接口
        （2）程序接口：允许用户通过程序间接使用，由一组系统调用组成，即系统调用=程序接口
        （3）GUI(图形用户界面)

特征：
    --并发：
        定义：指两个或多个事件在同一时间间隔内发生；这些事件在宏观上是同时发生的，但微观上是交替发生的；并发性是指计算机系统中同时存在着多个运行着的程序
        区别：并行是指两个或多个事件在同一时刻同时发生

    --共享：
        定义：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用；共享性是指系统中的资源可供内存中多个并发执行的进程共同使用 
        方式：
            （1）互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段内只允许一个进程访问该资源
            （2）同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对其进行访问

    --虚拟：
        定义：是指把一个物理上的实体变为若干个逻辑上的对应物；物理实体是实际存在的，而逻辑上对应物使用户感受到的

    --异步：
        定义：是指在多道程序环境下，郧西多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进

发展：
    --手工操作阶段
    --多道批处理系统：
        多道程序并发执行，共享计算机资源。资源利用率大幅提升，cpu和其他资源保持“忙碌”状态，系统吞吐量增大，但是用户响应时间长，没有人机交互功能
    --分时操作系统：
        计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互，用户请求可被即时相应，解决了人机交互问题，但不能优先处理一些紧急任务
    --实时操作系统：
        能够优先响应一些紧急任务，某些紧急任务不需要时间片排队；在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件，其主要特点是及时性和可靠性
        注意：
            --硬实时系统：必须在绝对严格的规定时间内完成
            --软实时系统：能接受偶尔违反时间规定

运行机制和体系结构

    --两种处理器状态---&gt;用PSW(程序状态寄存器)中的某标志位来标识房前处理器状态0为用户，1为核心：
        （1）用户态(目态)：此时CPU只能执行非特权指令
        （2）核心态(管态)：特权指令、非特权指令都可执行

    --两种程序：
        （1）内核程序：是系统的管理者，可以执行所有指令，运行在核心态中
        （2）应用程序：只能执行非特权指令，运行在用户态

    --内核：
        说明：是计算机上配置的底层软件，是操作系统最基本、最核心的部分
        分类：
            --大内核：
                说明：将操作系统的主要功能模块都作为系统内核，运行在核心态
                特点：高性能；内核代码庞大，结构混乱，难以维护
            微内核：
                说明：只把最基本的功能保留在内核
                特点：内核功能少，结构清晰，方便维护；需要频繁的在核心态和用户态之间切换，性能底

        功能：
            （1）时钟管理：实现计时功能
            （2）中断处理：负责实现中断机制
            （3）原语：是一种特殊的程序，处于操作系统最底层，是最接近硬件的部分；这种程序的运行具有原子性(运行不可中断)；运行时间较短、调用频繁
            （4）对系统资源尽心管理的功能
                --进程管理
                --存储器管理
                --设备管理

中断和异常（是为了实现多道程序并发执行而引入的一种技术）：
    说明：
        --中断发生时，CPU立即进入核心态
        --中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理
        --对不同的中断信号，会进行不同的处理

    分类（分类的标准--&gt;根据信号的来源：内中断是来自于CPU内部，与当前执行的指令有关，外中断是来自于CPU外部，与当前执行的指令无关）：
        --内中断(异常/例外、陷入)：
            （1）自愿中断：指令中断
            （2）强迫中断：硬件故障、软件中断

        --外中断(中断，狭义的中断)：
            （1）外设请求
            （2）人工干预

    注意：用户态-&gt;核心态 是通过中断实现的，并且中断是唯一途径；而 核心态-&gt;用户态 的切换是通过执行一个特权指令，将程序状态字(PSW)的标志位设置为&quot;用户态&quot;

系统调用：

    说明：系统调用相关处理设计到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下进行
    作用：可以保证系统的稳定性和安全性，防止用户进行非法操作

    分类
        --按功能：
            （1）设备管理
            （2）文件管理
            （3）进程管理
            （4）进程通信
            （5）内存管理

    过程：
        （1）传递系统调用参数
        （2）执行陷入指令(用户态)
        （3）执行系统调用相应服务程序(核心态)
        （4）返回用户程序
        注意：
            --陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内终端，从而CPU进入核心态
            --发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行
            --陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="ckoo0iqux0009l8ubea9gcmu3" data-title="操作系统" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java8新特性" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/28/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" class="article-date">
  <time class="dt-published" datetime="2021-04-28T13:02:09.853Z" itemprop="datePublished">2021-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/28/Java8%E6%96%B0%E7%89%B9%E6%80%A7/">Java8新特性</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>#java8</p>
<pre><code>优点：
    --速度更快
    --代码更少(增加了新的语法：Lambda表达式)
    --强大的Stream API
    --便于并行
    --最大化减少空指针异常：Optional
    --Nashorn引擎，允许在JVM上运行JS应用</code></pre>
<hr>
<p>##Lambda表达式</p>
<pre><code>说明：是一个匿名函数，可以将其理解为一段可以传递的代码，使用它可以写出更简洁、更灵活的代码
本质：作为函数式接口的一个实例
    函数式接口：
        说明：只包含一个抽象方法的接口

        使用：
            --可以在接口上使用@Funtionallnterface注解，检查其是否是一个函数式接口，同时javadoc也会包含一条声明，说明这个接口是一个函数式接口

        常用的四大核心函数式接口：
            --Consumer&lt;T&gt;消费型接口：
                void accept(T t)
            --Suppelier&lt;T&gt;供给型接口：
                T get()
            --Function&lt;T,R&gt;函数型接口：
                R apply(T t)
            --Predicate&lt;T&gt;断定型接口：
                boolean test(T t)


格式：
    -&gt; ：Lambda操作符或箭头操作符
    -&gt; 左边：Lambda形参列表(其实就是接口中的抽象方法的形参列表)
    -&gt; 右边：Lambda体(其实就是重写的抽象方法的方法体)

    使用：
        接口名 r1 = (形参列表) -&gt; &#123;
            执行语句
        &#125;；
    注意:
        --Lambda形参列表等等参数类型可以省略(类型推断);如果Lambda形参列表只有一个参数，其括号可以省略
        --Lambda体应使用一对&#123;&#125;包裹；如果Lambda体只有一条执行语句(可能是return语句)，省略这一对&#123;&#125;和return关键字

方法引用
    说明：通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖
    要求：
        实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致
    格式：
        使用操作符“::”将类(或对象)与方法名分隔开来
    使用情景：
        当要传递给Lambda体的操作，已经有实现的方法
    具体情况：
        --对象::非静态方法
        --类::静态方法
        --类::非静态方法

构造器引用：
    要求：和方法引用类似，函数式接口的抽象方法的形参列表的构造器的形参列表一致；抽象方法的返回值类型即为构造器所属的类的类型</code></pre>
<p>##Stream API</p>
<pre><code>执行步骤：
    --Stream实例化：
        （1）通过集合：
            --default Stream&lt;E&gt; stream()：返回一个顺序流
            --default Stream&lt;E&gt; parallelStream()：返回一个并行流
        （2）通过数组：
            --调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)：返回一个流
        （3）通过Stream的of()
        （4）创建无限流：可以使用静态方法Stream.iterate()和Stream.generate()创建无限流
            --迭代：public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed,final UnaryOperator&lt;T&gt; f)
            --生成：public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)

    --中间操作
        （1）筛选与切片
            --filter(Predicate p)：接收Lambda，从流中排除某些元素
            --Limit(n)：截断流，使其元素不超过给给定数量
            --skip(n)：跳过元素，返回一个扔掉了前n个元素的流。若流中的元素不足n个，则返回一个空流
            --distinct()：筛选，通过流所生成元素的hashCode()和equals()去除重复的元素
        （2）映射
            --map(Function f)：接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素
            --flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个
        （3）排序：对于自定义类一定要进行对于Comparable接口的实现或定制排序
            --sorted()：产生一个新流，其中按自然顺序排序
            --sorted(Comparator com)：产生一个新流，其中按比较器顺序排序

    --终止操作
        （1）匹配与查找
            --allMatch(Predicate p)：检查是否匹配所有元素
            --anyMatch(Predicate p)：检查是否至少匹配一个元素
            --noneMatch(Predicate p)：检查是否没有匹配的元素
            --findFirst()：返回第一个元素
            --findAny()：返回当前流中的任意元素
            --cout()：返回流中元素的总个数
            --max/min(Comparator c)：返回流中最大值/最小值
            --foreach(Consumer c)：内部迭代（使用Collection接口需要用户去做迭代称为外部迭代）

        （2）归约
            --reduce(T identify,BinaryOperator)：可以将流中元素反复结合起来，得到一个值，返回T类型数据
            --reduce(BinaryOperator)：可以将流中元素反复结合起来，得到一个值，返回Optional&lt;T&gt;类型数据

        （3）收集
            --collect(Collector c)：将流转换为其他形式；接受一个Collector接口的实现，用于给Stream中元素做汇总的方法
                注意：Collector接口中方法实现决定了如何对流执行收集的操作；另外，Collectors实用类提供了很多的静态方法，可以方便的创建常见收集器实例

注意：
    --Stream是对数据的运算，与CPU相关；集合关注的是数据的存储，与内存相关
    --Stream自己不会存储元素
    --Stream不会改变源对象，但是会返回一个持有结果的新Stream
    --Stream操作是延迟执行，意味着其会等到需要结果的时候才执行</code></pre>
<p>##Optional类</p>
<pre><code>说明：Optional&lt;T&gt;类(java.util.Optional)是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在

常用方法：
    --创建Optional类对象的方法：
        Optional.of(T t)：创建一个Optional实例，t必须非空
        Optional.empty()：创建一个空的Optional对象
        Optional.ofNullable(T t)：t可以为null

    --判断Optional容器中是否包含对象：
        boolean isPresent()：判断是否包含对象
        void ifPresent(Conmuser&lt;?super T&gt; consumer)：如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它

    --获取Optional容器的对象：
        T get()：如果调用对象保函值，返回该值，否则抛异常
        T orElse(T other)：如果有值则将其返回，否则返回指定的other对象
        T orElseGet(Supplier&lt;? extends T&gt; other)：如果有值则将其返回，否则返回由Supplier接口实现提供的对象
        T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/28/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" data-id="ckoo0iqul0003l8ub7r7xfezk" data-title="Java8新特性" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java简单类库的使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T06:27:24.916Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/">Java类库与基本操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简单的类库使用"><a href="#简单的类库使用" class="headerlink" title="#简单的类库使用"></a>#简单的类库使用</h2><p>###数字</p>
<pre><code>Math.random():令系统随机选取大于等于0.0且小于1.0的伪随机double值
    Math.random()*(n-m)+m：返回指定范围的随机数（m-n之间）的公式</code></pre>
<hr>
<p>###字符</p>
<pre><code>string.equals():判断二者是否相同 </code></pre>
<hr>
<p>###Arrys工具类</p>
<pre><code>Ops:java.util.Arrays
Using:
    sort():快速排序
    binary():二分查找
    equals():判断两个数组是否相同
    fill(int[] a,int val):将指定值填充到数组之中</code></pre>
<hr>
<p>###JavaBean:是一种Java语言写成的可重用组件（也是一个Java类）</p>
<pre><code>特征：
    （1）类是公共的
    （2）有一个无参的公共的构造器
    （3）有属性，且对应的get、set方法
功能：
    可以将功能、处理、值、数据库访问和其他任何可以用Java代码创造对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。</code></pre>
<hr>
<p>###UML类图</p>
<pre><code>结构：
    类名
    属性（属性名：属性类型）
    方法（方法的类型 方法名(参数名：参数类型)：返回值类型）注：若方法有下划线表示为构造器
    ‘+’表示public,‘-’表示private，‘#’表示proctected</code></pre>
<hr>
<p>###Object类（是所有java类的根父类，如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类） </p>
<pre><code>（1）equals()： 比较二者是否相同

    使用：
        （1）是一个方法，并不是运算符
        （2）只能适用于引用数据类型
        （3）Object类中定义的equals()和==的作用是相同的，比较两个对象的地址值是否相同
        （4）在String、Data、File、包装类等都重写了Object类中的equals()方法，重写后，比较的是两个对象的实体内容

    与“==”的却别：
        ==：
            （1）可以使用在基本数据类型 变量和引用数据类型变量中
            （2）如果比较的是基本数据类型变量，比较二者保存的数据是否相同（不一定要类型相同）
                如果比较的是引用数据类型变量，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体

（2）toString()：

    使用：
        a.当输出一个对象的引用时，实际上就是调用当前对象的toString()方法
        b.String、Date、File、包装类等都重写了Object类中的toString()方法</code></pre>
<hr>
<p>###包装类(Wrapper)的使用</p>
<pre><code>功能：java提供了8种数据类型对应的包装类，使得基本数据类型的变量具有类的特征
使用：
    （1）基本数据类型、包装类、String三者之间的相互转换
        基本数据类型-----&gt;包装类：调用包装类的构造器
        包装类-----&gt;基本数据类型：调用包装类Xxx的xxxValue()
        基本数据类型、包装类----&gt;String类型：调用String重载的valueOf(Xxx xxx)
        String类型-------&gt;基本数据类型、包装类：调用包装类的parseXxx(String s)
    注意：
        自动装箱：可以直接将基本数据类型赋给包装类，可以提高效率（只可以赋值到-128到127，当大于这个数则会通过d调用构造器来创建对象）
        自动拆箱：直接将包装类赋给基本数据类型</code></pre>
<hr>
<p>###Vector类的使用</p>
<pre><code>功能：代替数组进行处理
使用：
    （1）addElement(Object ob)：给向量添加元素
    （2）elementAt(0)：取出向量中的元素，返回值是Object类型
    （3）size()：计算向量长度 </code></pre>
<hr>
<p>###JDK8日期时间API</p>
<pre><code>1.LocalDate\LocalTime\LocalDateTime
    实例化：
        now(Zoneid zone)：静态方法，根据当前时间创建对象/指定时区的对象
        of()：静态方法，根据指定日期/时间创建对象，不存在偏移量

    使用方法：    
        getDayOfMonth()/getDayOfYear()：获得月份太难书(1-31)/获得年份天数(1-366)
        getDayOfWeek()：获取星期几(返回一个DayOfWeek枚举值)
        getMonth()：获得月份，返回一个Month枚举值
        getMonthValue()/getYear()：获取月份(1-12)/获取年份
        getHour()/getMinute/getSecond()：获取当前对象对应的时分秒
        withDayOfMonth()/withDayOfYear()/withMonth()/withYear()：将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象

2.Instent类：时间线上的一个瞬时点
    实例化：
        now()：静态方法，返回默认UTC时区的Instant类的对象
        ofEpochMilli(long epochMilli)：静态方法，返回在1970-01-01 00：00：00基础上加上指定毫秒数之后的Instant类的对象

    使用：
        atOffset(ZoneOffset offset)：结合即时的偏移来创建一个OffsetDateTime
        toEpochMilli()：返回1970-01-01 00：00：00到当前时间的毫秒数，即为时间戳（ofEpochMilli：通过给定的毫秒数，获取Instant实例）

3.DateTimeFormatter类：该类提供了三种格式化方法
    使用：
        ofPattern(String pattern)：静态方法，返回一个指定字符串格式的DateTimeFormatter
        format(TemporalAccessor t)：格式化一个日期、时间，返回字符串
        parse(CharSequence text)：将指定格式的字符序列解析为一个日期、时间

4.Date类
    位置：java.util.Date
    使用：使用其空参构造器创建一个对应当前时间的Date对象，也可以给其构造器赋指定毫秒数
        a.toString()：显式当前的年月日时分秒
        b.getTime()：获取当前Date对象对应的时间戳

5.java.sql.Date
    说明：对应这数据库中的日期类型变量，该类时System类的子类
    实例化：java.sql.Date date = new java.sql.Date(毫秒数)

6.java.text.SimpleFormat类
    说明：是一个不与语言环境有关的方式来格式化和解析日期的具体类
    解析：文本--&gt;日期
    使用：
        a.格式化：日期----&gt;字符串
            String对象 = (SimpleFormat对象).format(Date对象)
        b.解析：格式化的逆过程，字符串----&gt;日期
            解析的String对象需要为&quot;年份-月份-日期 上下午 时:分&quot;
            通过指定格式实例化的方法，可以指定转换的日期格式：Date对象 = SimpleDateFormat对象.parse(&quot;指定格式时间的字符串&quot;)
                要求：字符串必须时符合SimpleDateFormat识别的格式(通过构造器参数体现，否则抛异常)

7.java.util.Calendar(日历)类
    说明：是一个抽象基类，主要用于完成日期字段之间相互操作的功能
    实例化：通过调用它的子类GregorianCalendar的构造器/使用Calendar.getInstance()方法
    常用方法：
        get()：获取常用的时间属性信息
        set()：将指定的时间属性设置成新的值
        add()：在原有的基础属性的值上添加
        getTime()：日历类-----&gt;Date
        setTime()：Date-----&gt;日历类
    注意：月份从0开始，星期从1(星期日)开始

8.其他的时间类
    ZoneId：该类中包含了所有的时区信息】
    ZonedDateTime：一个在ISO-8601日历系统时区的日期时间
    Clock：使用时区提供堆当前即时、日期和时间的访问的时钟
    Duration：用于计算两个&quot;时间&quot;间隔
    Period：用于计算两个&quot;日期&quot;间隔
    TemporalAdjuster：时间校正器。
    TemporalAdjusters：该类通过静态方法(firstDayOfXxx() / lastDayOfXxx() / nextXxx())提供了大量的常用TemporalAdjust的实现</code></pre>
<hr>
<p>###java比较器</p>
<pre><code>Comparable接口：自然排序
    包：java.lang.Comparable
    使用：
        1.像String、包装类等实现了Comparable接口，重写了compareTo()方法，给出了比较两个对象的大小，进行从小到大的排序
        2.重写compareTo()的规则
            当前对象&gt;形参对象，返回正整数，&lt;返回负整数，相等返回0
        3.对于自定义类，如果说需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法，在CompareTo(obj)方法中指明如何排序

Comparator接口：定制排序、
    包：java.lang.Comparator
    使用：可以使用匿名的方式，重写conpare方法</code></pre>
<p>###System类</p>
<pre><code>说明：代表系统，系统级的很多属性和控制方法都放置在该类的内部
包：java.lang
使用：
    1.该类的构造器为私有的，所以无法创建该类的对象
    2.内部成员变量和成员方法都为static
常用方法：
    currentTimeMillis()：返回当前的计算机时间
    exit(int status)：退出程序，0表示正常退出，非0表示异常退出，使用该方法可以在图形界面编程中实现程序的退出功能
    gc()：请求系统进行垃圾回收
    getProperty(String key)：获得系统中属性名为key的属性对应的值</code></pre>
<p>###Math类</p>
<pre><code>说明：提供了一系列静态方法用于科学计算，其方法的参数和返回值类型一般为double型
包：java.lang
常用方法：
    abs：绝对值
    sqrt：平方值
    pow(a,b)：a的b次幂
    log：自然对数
    exp：e为底指数
    random：返回0.0到1.0的随机数
    round：将double类型数据转换为long</code></pre>
<p>###BigInteger类</p>
<pre><code>说明：
    可以表示不可变的任意精度的整数，其提供所有Java的基本整数操作符的对应物，并提供java.lang.Math的所有相关方法，还提供：模运算、GCD计算、质数测试、素数生成、位操作以及一些其他操作
包:java.math    
使用：
    构造器：BigInteger(String val)，根据字符串构建BigInteger对象    </code></pre>
<p>###BigDecimal类<br>    说明：表示精度要求比较高的数字，该类支持不可变的、任意精度的有符号十进制定点数<br>    包：java.math<br>    使用：<br>        构造器：BigDecimal(double val/String val)<br>    常用方法：<br>        add：<br>        substract：</p>
<p>###字符串相关的类</p>
<pre><code>（1）string
        特征：
            a.不可被继承：String类是一个final类
            b.内部定义了final char[] value用于存储字符串数据
            c.字符串是支持序列化： String实现了Serializable接口
            d.String可以比较大小： 实现了Comparable接口
            e.不可变性： String代表不可变的字符序列
                体现：
                    1-当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值
                    2-当对现有的字符串进行链接操作时，也需要重新指定内存区域赋值
                    3-当调用replace()方法修改指定字符或字符串时，也需要重新制定内存区域赋值
            f.通过字面量直接赋值(区别于new)的方式给一个字符串复制，此时字符串值生命在方法区的字符串常量池中（字符串常量池中不会存储相同内容的字符串）
            g.通过new+构造器方式的方式直接进行实例化，其数据是存储在堆空间中开辟空间以后对应的地址值所指向的常量池
            h.常量与常量短的拼接结果在常量池，且常量池中不会存在相同内容的常量，只要其中一个是变量，结果就在堆中

        JVM中字符串常量池存放位置：
            jdk1.6（jdk 6.0 ,java 6.0）：字符串常量池存储在方法区(永久区)
            jdk1.7：字符串常量池存储在堆空间
            jdk1.8：字符串常量池存储在方法区(元空间)


        数据类型转换：
            a.String----&gt;基本数据类型、包装类之间的转换：
                调用包装类的静态方法：parseXxx(str)
            b.基本数据类型、包装类----&gt;String:
                调用String重载的valueOf(xxx)
            c.String----&gt;char[]之间的转换
                调用String的toCharArray()
            d.char[]----&gt;String：
                调用String的构造器
            e.Stirng---&gt;byte[](该过程称为编码)：
                调用String的getBytes()：该函数使用默认的字符集，进行转换
            f.byte[]----&gt;String（该过程称为解码）：
                调用String的构造器：使用默认的字符集进行解码

        常用方法：
            string inten()：要求该函 数返回值在常量池当中
            int length()：返回字符串长度
            char charAt(int index)：返回某索引的字符
            boolean isEmpty()：判断是否是空字符串
            String toLowerCase()：使用默认语言环境，将String中的所有字符为小写
            String toUpperCase()：使用默认语言环境，将String中的所有字符转换为大写
            String trim()：返回字符串的副本，忽略前导空白和尾部空白
            boolean equals(Object obj)：比较字符串内容是否相同
            boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写
            String concat(String str)：将指定字符串链接到字符串的结尾，等价于“+”
            int compareTo(String anotherString)：比较两个字符串的大小
            String subString(int beginIndex)：返回一个新的字符串，从beginIndex开始截取
            String substring(int beginIndex,int endIndex)：返回一个新字符串，它是此字符串从beginIndex截取到endIndex

            boolean endWith(String suffix)：测试此字符串是否以指定的后缀结束
            boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始
            boolean startsWith(String prefix,int toffset)：测试此字符串从指定索引开始的子字符串是否以指定字符串开始

            boolean contains(CharSequence s)：当且仅当此字符串包含指定的char值序列时，返回true
            int indexOf(String str)：返回指定字符串在此字符串中第一次出现处的索引
            int indexOf(String str,inr fromIndex)：返回指定字符串在此字符串中第一次出现处的索引，从指定的索引开始
            int lastIndexOf(String str)：返回指定字符串在此字符串中最右边出现处的索引
            int lastIndexOf(String str,int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向操作
                注：indexOf和lastIndexOf未找到，都返回-1
            替换：
                String replace(char oldChar,char newChar)：返回一个新的字符串，他是通过用newChar替换此字符串中出现的所有oldChar得到
                String replace(CharSequence target,CharSequence replacement)：使用指定的字面值替换序列替换此字符串所以匹配字面值目标序列的子字符串
                String replaceAll(String regex,String replacement)：使用给定的replacement替换此字符串所有匹配给顶的正则表达式的子字符串
                String replaceFirst(String regex,String replacement)：使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串
            匹配：
                boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式
            切片：
                String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串
                String[] split(String regex，int limut)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中 

（2）StringBuffer和StringBuilder
        与String的异同点
            a.String：不可变的字符序列，效率最低 
                内存解析:
                    底层使用char[]存储
            b.StringBuffer：可变的字符序列；线程安全的，效率低；
                内存解析：
                    底层使用char[]存储；调用构造器创建字符数组时，默认给数组扩容为16个字符，若给到指定长度，也在原数组上扩容16，但使用length()函数返回的长度不计算这16扩容，若要添加的数据底层数组盛不下，默认情况下，扩容为原来的2倍+2，同时将原有数组中的元素赋值到新的数组中，但这种操作会降低效率
            c.StringBuilder：可变的字符序列；jdk5.0新增，线程不安全的，效率高；
                内存解析：
                    底层使用char[]存储；同StringBuilder一致 

        常用方法：
            append()：提供了很多的append()方法，用于进行字符串拼接
            delete(int start,int end)：删除指定位置的内容
            replace(int start,int end,String str)：把[start,end)位置换位str
            insert(int offset,xxx)：在指定位置插入xxx
            reverse()：把当前字符序列逆转
            setCharAt(int n,char ch)：修改指定位置的字符
            注：
                append和insert时，如果原来的value数组长度不够，可扩容
                以上的方法支持方法链操作
                方法链原理</code></pre>
<hr>
<p>###集合Collections工具类</p>
<pre><code>说明：操作Map和Collection的工具类
常用方法：
    reverse(List)：反转List中元素的顺序
    shuffle(List)：对List集合元素进行随机排序
    sort(List)：根据元素的自然顺序对指定List集合元素按升序排序
    sort(List,Comparator)：根据Comparator产生的顺序对List集合元素进行排序
    Object max/min(Collection)：根据元素的自然顺序，返回给定集合的最大/最小元素
    Obeject max/min(Collection,Comparator)：根据Comparator指定的顺序，返回给定集合中最大/最小的元素
    int frequency(Collection,Object)：返回指定集合中指定元素的出现次数
    void copy(List dest,List src)：将src中的内容赋值到dest中
        注意：
            if( dest.size()&lt;src.size() )
                &lt;!-- 抛异常 --&gt;
            else
                复制成功
    boolean replace(List list,Object oldVal,Object newVal)：使用新值替换List对象

    注：在该类当中有多个synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</code></pre>
<hr>
<p>###日常使用</p>
<p>（1）Eclipse快捷键(可到preference当中的keys进行修改)</p>
<pre><code>（1）补全代码的声明：alt + /
（2）快速修复：ctrl + 1
（3）批量导包：ctrl + shift + o
（4）多行注释：ctrl + shift + /（取消使用 \ ）
（5）复制指定行的代码：ctrl + alt +down 或 ctrl + alt + up
（6）删除指定行的代码：ctrl + d
（7）上下移动代码：alt + up 或 alt + down
（8）切换到下一行代码空位：shift + enter（上一行则 + ctrl）
（9）查看源码：ctrl + 选中指定结构 或 ctrl + shift + t
（10）退回到前一个编辑页面：alt + left（下一个编辑界面则是alt + right）
（11）光标选中指定的类，查看继承树结构：ctrl + t
（12）撤销与反撤销：ctrl + z/y
（13）格式化代码：ctrl + shift +f
（14）在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o
（15）批量修改指定的变量名、方法名、类名等：alt + shift + r
（16）选中结构的大小写的切换：ctrl + shift + x/y
（17）调出生成getter/setter/构造器等结构：alt + shift + s
（18）显示当前选择资源（工程 或 文件）的属性：alt + enter
（19）快速查找.参照选中的word快速定位到下一个：ctrl + k
（20）关闭所有窗口：ctrl + shift + w
（21）查看指定的结构使用过的地方：ctrl + alt + g
（22）查找与替换：ctrl + f
（23）最大化当前的View：ctrl + m
（24）直接定位到当前行的首位：home
（25）直接定位到当前行的末位：end</code></pre>
<p>（2）JUnit单元测试</p>
<pre><code>使用：
    a.选中当当前工程-右键选择：bulid path - add libraries -JUnit 4 - 下一步
    b.创建java类，进行单元测试，要求的Java类要求：1.此类权限为public 2.此类提供公共的无参构造函数
    c.此类中声明单元测试方法：此时的单元测试方法权限是public，没有返回值，没有形参
    d.此单元测试方法需要声明注解：@Test，并在单元测试类中导入：org.junit.Test包 </code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" data-id="ckoo0iqvc000dl8ub2413gy28" data-title="Java类库与基本操作" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/">计算机网络——物理层</a>
          </li>
        
          <li>
            <a href="/2021/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机网络</a>
          </li>
        
          <li>
            <a href="/2021/05/11/java%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/">Java编程杂记</a>
          </li>
        
          <li>
            <a href="/2021/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/">操作系统——设备管理</a>
          </li>
        
          <li>
            <a href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/">操作系统——文件管理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>