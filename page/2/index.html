<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Java8新特性" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/28/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" class="article-date">
  <time class="dt-published" datetime="2021-04-28T13:02:09.853Z" itemprop="datePublished">2021-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/28/Java8%E6%96%B0%E7%89%B9%E6%80%A7/">Java8新特性</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>#java8</p>
<pre><code>优点：
    --速度更快
    --代码更少(增加了新的语法：Lambda表达式)
    --强大的Stream API
    --便于并行
    --最大化减少空指针异常：Optional
    --Nashorn引擎，允许在JVM上运行JS应用</code></pre>
<hr>
<p>##Lambda表达式</p>
<pre><code>说明：是一个匿名函数，可以将其理解为一段可以传递的代码，使用它可以写出更简洁、更灵活的代码
本质：作为函数式接口的一个实例
    函数式接口：
        说明：只包含一个抽象方法的接口

        使用：
            --可以在接口上使用@Funtionallnterface注解，检查其是否是一个函数式接口，同时javadoc也会包含一条声明，说明这个接口是一个函数式接口

        常用的四大核心函数式接口：
            --Consumer&lt;T&gt;消费型接口：
                void accept(T t)
            --Suppelier&lt;T&gt;供给型接口：
                T get()
            --Function&lt;T,R&gt;函数型接口：
                R apply(T t)
            --Predicate&lt;T&gt;断定型接口：
                boolean test(T t)


格式：
    -&gt; ：Lambda操作符或箭头操作符
    -&gt; 左边：Lambda形参列表(其实就是接口中的抽象方法的形参列表)
    -&gt; 右边：Lambda体(其实就是重写的抽象方法的方法体)

    使用：
        接口名 r1 = (形参列表) -&gt; &#123;
            执行语句
        &#125;；
    注意:
        --Lambda形参列表等等参数类型可以省略(类型推断);如果Lambda形参列表只有一个参数，其括号可以省略
        --Lambda体应使用一对&#123;&#125;包裹；如果Lambda体只有一条执行语句(可能是return语句)，省略这一对&#123;&#125;和return关键字

方法引用
    说明：通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖
    要求：
        实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致
    格式：
        使用操作符“::”将类(或对象)与方法名分隔开来
    使用情景：
        当要传递给Lambda体的操作，已经有实现的方法
    具体情况：
        --对象::非静态方法
        --类::静态方法
        --类::非静态方法

构造器引用：
    要求：和方法引用类似，函数式接口的抽象方法的形参列表的构造器的形参列表一致；抽象方法的返回值类型即为构造器所属的类的类型</code></pre>
<p>##Stream API</p>
<pre><code>执行步骤：
    --Stream实例化：
        （1）通过集合：
            --default Stream&lt;E&gt; stream()：返回一个顺序流
            --default Stream&lt;E&gt; parallelStream()：返回一个并行流
        （2）通过数组：
            --调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)：返回一个流
        （3）通过Stream的of()
        （4）创建无限流：可以使用静态方法Stream.iterate()和Stream.generate()创建无限流
            --迭代：public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed,final UnaryOperator&lt;T&gt; f)
            --生成：public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)

    --中间操作
        （1）筛选与切片
            --filter(Predicate p)：接收Lambda，从流中排除某些元素
            --Limit(n)：截断流，使其元素不超过给给定数量
            --skip(n)：跳过元素，返回一个扔掉了前n个元素的流。若流中的元素不足n个，则返回一个空流
            --distinct()：筛选，通过流所生成元素的hashCode()和equals()去除重复的元素
        （2）映射
            --map(Function f)：接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素
            --flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个
        （3）排序：对于自定义类一定要进行对于Comparable接口的实现或定制排序
            --sorted()：产生一个新流，其中按自然顺序排序
            --sorted(Comparator com)：产生一个新流，其中按比较器顺序排序

    --终止操作
        （1）匹配与查找
            --allMatch(Predicate p)：检查是否匹配所有元素
            --anyMatch(Predicate p)：检查是否至少匹配一个元素
            --noneMatch(Predicate p)：检查是否没有匹配的元素
            --findFirst()：返回第一个元素
            --findAny()：返回当前流中的任意元素
            --cout()：返回流中元素的总个数
            --max/min(Comparator c)：返回流中最大值/最小值
            --foreach(Consumer c)：内部迭代（使用Collection接口需要用户去做迭代称为外部迭代）

        （2）归约
            --reduce(T identify,BinaryOperator)：可以将流中元素反复结合起来，得到一个值，返回T类型数据
            --reduce(BinaryOperator)：可以将流中元素反复结合起来，得到一个值，返回Optional&lt;T&gt;类型数据

        （3）收集
            --collect(Collector c)：将流转换为其他形式；接受一个Collector接口的实现，用于给Stream中元素做汇总的方法
                注意：Collector接口中方法实现决定了如何对流执行收集的操作；另外，Collectors实用类提供了很多的静态方法，可以方便的创建常见收集器实例

注意：
    --Stream是对数据的运算，与CPU相关；集合关注的是数据的存储，与内存相关
    --Stream自己不会存储元素
    --Stream不会改变源对象，但是会返回一个持有结果的新Stream
    --Stream操作是延迟执行，意味着其会等到需要结果的时候才执行</code></pre>
<p>##Optional类</p>
<pre><code>说明：Optional&lt;T&gt;类(java.util.Optional)是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在

常用方法：
    --创建Optional类对象的方法：
        Optional.of(T t)：创建一个Optional实例，t必须非空
        Optional.empty()：创建一个空的Optional对象
        Optional.ofNullable(T t)：t可以为null

    --判断Optional容器中是否包含对象：
        boolean isPresent()：判断是否包含对象
        void ifPresent(Conmuser&lt;?super T&gt; consumer)：如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它

    --获取Optional容器的对象：
        T get()：如果调用对象保函值，返回该值，否则抛异常
        T orElse(T other)：如果有值则将其返回，否则返回指定的other对象
        T orElseGet(Supplier&lt;? extends T&gt; other)：如果有值则将其返回，否则返回由Supplier接口实现提供的对象
        T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/28/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" data-id="ckp27psrt0000n8ub4xrcd52y" data-title="Java8新特性" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java简单类库的使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T06:27:24.916Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/">Java类库与基本操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简单的类库使用"><a href="#简单的类库使用" class="headerlink" title="#简单的类库使用"></a>#简单的类库使用</h2><p>###数字</p>
<pre><code>Math.random():令系统随机选取大于等于0.0且小于1.0的伪随机double值
    Math.random()*(n-m)+m：返回指定范围的随机数（m-n之间）的公式</code></pre>
<hr>
<p>###字符</p>
<pre><code>string.equals():判断二者是否相同 </code></pre>
<hr>
<p>###Arrys工具类</p>
<pre><code>Ops:java.util.Arrays
Using:
    sort():快速排序
    binary():二分查找
    equals():判断两个数组是否相同
    fill(int[] a,int val):将指定值填充到数组之中</code></pre>
<hr>
<p>###JavaBean:是一种Java语言写成的可重用组件（也是一个Java类）</p>
<pre><code>特征：
    （1）类是公共的
    （2）有一个无参的公共的构造器
    （3）有属性，且对应的get、set方法
功能：
    可以将功能、处理、值、数据库访问和其他任何可以用Java代码创造对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。</code></pre>
<hr>
<p>###UML类图</p>
<pre><code>结构：
    类名
    属性（属性名：属性类型）
    方法（方法的类型 方法名(参数名：参数类型)：返回值类型）注：若方法有下划线表示为构造器
    ‘+’表示public,‘-’表示private，‘#’表示proctected</code></pre>
<hr>
<p>###Object类（是所有java类的根父类，如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类） </p>
<pre><code>（1）equals()： 比较二者是否相同

    使用：
        （1）是一个方法，并不是运算符
        （2）只能适用于引用数据类型
        （3）Object类中定义的equals()和==的作用是相同的，比较两个对象的地址值是否相同
        （4）在String、Data、File、包装类等都重写了Object类中的equals()方法，重写后，比较的是两个对象的实体内容

    与“==”的却别：
        ==：
            （1）可以使用在基本数据类型 变量和引用数据类型变量中
            （2）如果比较的是基本数据类型变量，比较二者保存的数据是否相同（不一定要类型相同）
                如果比较的是引用数据类型变量，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体

（2）toString()：

    使用：
        a.当输出一个对象的引用时，实际上就是调用当前对象的toString()方法
        b.String、Date、File、包装类等都重写了Object类中的toString()方法</code></pre>
<hr>
<p>###包装类(Wrapper)的使用</p>
<pre><code>功能：java提供了8种数据类型对应的包装类，使得基本数据类型的变量具有类的特征
使用：
    （1）基本数据类型、包装类、String三者之间的相互转换
        基本数据类型-----&gt;包装类：调用包装类的构造器
        包装类-----&gt;基本数据类型：调用包装类Xxx的xxxValue()
        基本数据类型、包装类----&gt;String类型：调用String重载的valueOf(Xxx xxx)
        String类型-------&gt;基本数据类型、包装类：调用包装类的parseXxx(String s)
    注意：
        自动装箱：可以直接将基本数据类型赋给包装类，可以提高效率（只可以赋值到-128到127，当大于这个数则会通过d调用构造器来创建对象）
        自动拆箱：直接将包装类赋给基本数据类型</code></pre>
<hr>
<p>###Vector类的使用</p>
<pre><code>功能：代替数组进行处理
使用：
    （1）addElement(Object ob)：给向量添加元素
    （2）elementAt(0)：取出向量中的元素，返回值是Object类型
    （3）size()：计算向量长度 </code></pre>
<hr>
<p>###JDK8日期时间API</p>
<pre><code>1.LocalDate\LocalTime\LocalDateTime
    实例化：
        now(Zoneid zone)：静态方法，根据当前时间创建对象/指定时区的对象
        of()：静态方法，根据指定日期/时间创建对象，不存在偏移量

    使用方法：    
        getDayOfMonth()/getDayOfYear()：获得月份太难书(1-31)/获得年份天数(1-366)
        getDayOfWeek()：获取星期几(返回一个DayOfWeek枚举值)
        getMonth()：获得月份，返回一个Month枚举值
        getMonthValue()/getYear()：获取月份(1-12)/获取年份
        getHour()/getMinute/getSecond()：获取当前对象对应的时分秒
        withDayOfMonth()/withDayOfYear()/withMonth()/withYear()：将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象

2.Instent类：时间线上的一个瞬时点
    实例化：
        now()：静态方法，返回默认UTC时区的Instant类的对象
        ofEpochMilli(long epochMilli)：静态方法，返回在1970-01-01 00：00：00基础上加上指定毫秒数之后的Instant类的对象

    使用：
        atOffset(ZoneOffset offset)：结合即时的偏移来创建一个OffsetDateTime
        toEpochMilli()：返回1970-01-01 00：00：00到当前时间的毫秒数，即为时间戳（ofEpochMilli：通过给定的毫秒数，获取Instant实例）

3.DateTimeFormatter类：该类提供了三种格式化方法
    使用：
        ofPattern(String pattern)：静态方法，返回一个指定字符串格式的DateTimeFormatter
        format(TemporalAccessor t)：格式化一个日期、时间，返回字符串
        parse(CharSequence text)：将指定格式的字符序列解析为一个日期、时间

4.Date类
    位置：java.util.Date
    使用：使用其空参构造器创建一个对应当前时间的Date对象，也可以给其构造器赋指定毫秒数
        a.toString()：显式当前的年月日时分秒
        b.getTime()：获取当前Date对象对应的时间戳

5.java.sql.Date
    说明：对应这数据库中的日期类型变量，该类时System类的子类
    实例化：java.sql.Date date = new java.sql.Date(毫秒数)

6.java.text.SimpleFormat类
    说明：是一个不与语言环境有关的方式来格式化和解析日期的具体类
    解析：文本--&gt;日期
    使用：
        a.格式化：日期----&gt;字符串
            String对象 = (SimpleFormat对象).format(Date对象)
        b.解析：格式化的逆过程，字符串----&gt;日期
            解析的String对象需要为&quot;年份-月份-日期 上下午 时:分&quot;
            通过指定格式实例化的方法，可以指定转换的日期格式：Date对象 = SimpleDateFormat对象.parse(&quot;指定格式时间的字符串&quot;)
                要求：字符串必须时符合SimpleDateFormat识别的格式(通过构造器参数体现，否则抛异常)

7.java.util.Calendar(日历)类
    说明：是一个抽象基类，主要用于完成日期字段之间相互操作的功能
    实例化：通过调用它的子类GregorianCalendar的构造器/使用Calendar.getInstance()方法
    常用方法：
        get()：获取常用的时间属性信息
        set()：将指定的时间属性设置成新的值
        add()：在原有的基础属性的值上添加
        getTime()：日历类-----&gt;Date
        setTime()：Date-----&gt;日历类
    注意：月份从0开始，星期从1(星期日)开始

8.其他的时间类
    ZoneId：该类中包含了所有的时区信息】
    ZonedDateTime：一个在ISO-8601日历系统时区的日期时间
    Clock：使用时区提供堆当前即时、日期和时间的访问的时钟
    Duration：用于计算两个&quot;时间&quot;间隔
    Period：用于计算两个&quot;日期&quot;间隔
    TemporalAdjuster：时间校正器。
    TemporalAdjusters：该类通过静态方法(firstDayOfXxx() / lastDayOfXxx() / nextXxx())提供了大量的常用TemporalAdjust的实现</code></pre>
<hr>
<p>###java比较器</p>
<pre><code>Comparable接口：自然排序
    包：java.lang.Comparable
    使用：
        1.像String、包装类等实现了Comparable接口，重写了compareTo()方法，给出了比较两个对象的大小，进行从小到大的排序
        2.重写compareTo()的规则
            当前对象&gt;形参对象，返回正整数，&lt;返回负整数，相等返回0
        3.对于自定义类，如果说需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法，在CompareTo(obj)方法中指明如何排序

Comparator接口：定制排序、
    包：java.lang.Comparator
    使用：可以使用匿名的方式，重写conpare方法</code></pre>
<p>###System类</p>
<pre><code>说明：代表系统，系统级的很多属性和控制方法都放置在该类的内部
包：java.lang
使用：
    1.该类的构造器为私有的，所以无法创建该类的对象
    2.内部成员变量和成员方法都为static
常用方法：
    currentTimeMillis()：返回当前的计算机时间
    exit(int status)：退出程序，0表示正常退出，非0表示异常退出，使用该方法可以在图形界面编程中实现程序的退出功能
    gc()：请求系统进行垃圾回收
    getProperty(String key)：获得系统中属性名为key的属性对应的值</code></pre>
<p>###Math类</p>
<pre><code>说明：提供了一系列静态方法用于科学计算，其方法的参数和返回值类型一般为double型
包：java.lang
常用方法：
    abs：绝对值
    sqrt：平方值
    pow(a,b)：a的b次幂
    log：自然对数
    exp：e为底指数
    random：返回0.0到1.0的随机数
    round：将double类型数据转换为long</code></pre>
<p>###BigInteger类</p>
<pre><code>说明：
    可以表示不可变的任意精度的整数，其提供所有Java的基本整数操作符的对应物，并提供java.lang.Math的所有相关方法，还提供：模运算、GCD计算、质数测试、素数生成、位操作以及一些其他操作
包:java.math    
使用：
    构造器：BigInteger(String val)，根据字符串构建BigInteger对象    </code></pre>
<p>###BigDecimal类<br>    说明：表示精度要求比较高的数字，该类支持不可变的、任意精度的有符号十进制定点数<br>    包：java.math<br>    使用：<br>        构造器：BigDecimal(double val/String val)<br>    常用方法：<br>        add：<br>        substract：</p>
<p>###字符串相关的类</p>
<pre><code>（1）string
        特征：
            a.不可被继承：String类是一个final类
            b.内部定义了final char[] value用于存储字符串数据
            c.字符串是支持序列化： String实现了Serializable接口
            d.String可以比较大小： 实现了Comparable接口
            e.不可变性： String代表不可变的字符序列
                体现：
                    1-当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值
                    2-当对现有的字符串进行链接操作时，也需要重新指定内存区域赋值
                    3-当调用replace()方法修改指定字符或字符串时，也需要重新制定内存区域赋值
            f.通过字面量直接赋值(区别于new)的方式给一个字符串复制，此时字符串值生命在方法区的字符串常量池中（字符串常量池中不会存储相同内容的字符串）
            g.通过new+构造器方式的方式直接进行实例化，其数据是存储在堆空间中开辟空间以后对应的地址值所指向的常量池
            h.常量与常量短的拼接结果在常量池，且常量池中不会存在相同内容的常量，只要其中一个是变量，结果就在堆中

        JVM中字符串常量池存放位置：
            jdk1.6（jdk 6.0 ,java 6.0）：字符串常量池存储在方法区(永久区)
            jdk1.7：字符串常量池存储在堆空间
            jdk1.8：字符串常量池存储在方法区(元空间)


        数据类型转换：
            a.String----&gt;基本数据类型、包装类之间的转换：
                调用包装类的静态方法：parseXxx(str)
            b.基本数据类型、包装类----&gt;String:
                调用String重载的valueOf(xxx)
            c.String----&gt;char[]之间的转换
                调用String的toCharArray()
            d.char[]----&gt;String：
                调用String的构造器
            e.Stirng---&gt;byte[](该过程称为编码)：
                调用String的getBytes()：该函数使用默认的字符集，进行转换
            f.byte[]----&gt;String（该过程称为解码）：
                调用String的构造器：使用默认的字符集进行解码

        常用方法：
            string inten()：要求该函 数返回值在常量池当中
            int length()：返回字符串长度
            char charAt(int index)：返回某索引的字符
            boolean isEmpty()：判断是否是空字符串
            String toLowerCase()：使用默认语言环境，将String中的所有字符为小写
            String toUpperCase()：使用默认语言环境，将String中的所有字符转换为大写
            String trim()：返回字符串的副本，忽略前导空白和尾部空白
            boolean equals(Object obj)：比较字符串内容是否相同
            boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写
            String concat(String str)：将指定字符串链接到字符串的结尾，等价于“+”
            int compareTo(String anotherString)：比较两个字符串的大小
            String subString(int beginIndex)：返回一个新的字符串，从beginIndex开始截取
            String substring(int beginIndex,int endIndex)：返回一个新字符串，它是此字符串从beginIndex截取到endIndex

            boolean endWith(String suffix)：测试此字符串是否以指定的后缀结束
            boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始
            boolean startsWith(String prefix,int toffset)：测试此字符串从指定索引开始的子字符串是否以指定字符串开始

            boolean contains(CharSequence s)：当且仅当此字符串包含指定的char值序列时，返回true
            int indexOf(String str)：返回指定字符串在此字符串中第一次出现处的索引
            int indexOf(String str,inr fromIndex)：返回指定字符串在此字符串中第一次出现处的索引，从指定的索引开始
            int lastIndexOf(String str)：返回指定字符串在此字符串中最右边出现处的索引
            int lastIndexOf(String str,int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向操作
                注：indexOf和lastIndexOf未找到，都返回-1
            替换：
                String replace(char oldChar,char newChar)：返回一个新的字符串，他是通过用newChar替换此字符串中出现的所有oldChar得到
                String replace(CharSequence target,CharSequence replacement)：使用指定的字面值替换序列替换此字符串所以匹配字面值目标序列的子字符串
                String replaceAll(String regex,String replacement)：使用给定的replacement替换此字符串所有匹配给顶的正则表达式的子字符串
                String replaceFirst(String regex,String replacement)：使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串
            匹配：
                boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式
            切片：
                String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串
                String[] split(String regex，int limut)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中 

（2）StringBuffer和StringBuilder
        与String的异同点
            a.String：不可变的字符序列，效率最低 
                内存解析:
                    底层使用char[]存储
            b.StringBuffer：可变的字符序列；线程安全的，效率低；
                内存解析：
                    底层使用char[]存储；调用构造器创建字符数组时，默认给数组扩容为16个字符，若给到指定长度，也在原数组上扩容16，但使用length()函数返回的长度不计算这16扩容，若要添加的数据底层数组盛不下，默认情况下，扩容为原来的2倍+2，同时将原有数组中的元素赋值到新的数组中，但这种操作会降低效率
            c.StringBuilder：可变的字符序列；jdk5.0新增，线程不安全的，效率高；
                内存解析：
                    底层使用char[]存储；同StringBuilder一致 

        常用方法：
            append()：提供了很多的append()方法，用于进行字符串拼接
            delete(int start,int end)：删除指定位置的内容
            replace(int start,int end,String str)：把[start,end)位置换位str
            insert(int offset,xxx)：在指定位置插入xxx
            reverse()：把当前字符序列逆转
            setCharAt(int n,char ch)：修改指定位置的字符
            注：
                append和insert时，如果原来的value数组长度不够，可扩容
                以上的方法支持方法链操作
                方法链原理</code></pre>
<hr>
<p>###集合Collections工具类</p>
<pre><code>说明：操作Map和Collection的工具类
常用方法：
    reverse(List)：反转List中元素的顺序
    shuffle(List)：对List集合元素进行随机排序
    sort(List)：根据元素的自然顺序对指定List集合元素按升序排序
    sort(List,Comparator)：根据Comparator产生的顺序对List集合元素进行排序
    Object max/min(Collection)：根据元素的自然顺序，返回给定集合的最大/最小元素
    Obeject max/min(Collection,Comparator)：根据Comparator指定的顺序，返回给定集合中最大/最小的元素
    int frequency(Collection,Object)：返回指定集合中指定元素的出现次数
    void copy(List dest,List src)：将src中的内容赋值到dest中
        注意：
            if( dest.size()&lt;src.size() )
                &lt;!-- 抛异常 --&gt;
            else
                复制成功
    boolean replace(List list,Object oldVal,Object newVal)：使用新值替换List对象

    注：在该类当中有多个synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</code></pre>
<hr>
<p>###日常使用</p>
<p>（1）Eclipse快捷键(可到preference当中的keys进行修改)</p>
<pre><code>（1）补全代码的声明：alt + /
（2）快速修复：ctrl + 1
（3）批量导包：ctrl + shift + o
（4）多行注释：ctrl + shift + /（取消使用 \ ）
（5）复制指定行的代码：ctrl + alt +down 或 ctrl + alt + up
（6）删除指定行的代码：ctrl + d
（7）上下移动代码：alt + up 或 alt + down
（8）切换到下一行代码空位：shift + enter（上一行则 + ctrl）
（9）查看源码：ctrl + 选中指定结构 或 ctrl + shift + t
（10）退回到前一个编辑页面：alt + left（下一个编辑界面则是alt + right）
（11）光标选中指定的类，查看继承树结构：ctrl + t
（12）撤销与反撤销：ctrl + z/y
（13）格式化代码：ctrl + shift +f
（14）在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o
（15）批量修改指定的变量名、方法名、类名等：alt + shift + r
（16）选中结构的大小写的切换：ctrl + shift + x/y
（17）调出生成getter/setter/构造器等结构：alt + shift + s
（18）显示当前选择资源（工程 或 文件）的属性：alt + enter
（19）快速查找.参照选中的word快速定位到下一个：ctrl + k
（20）关闭所有窗口：ctrl + shift + w
（21）查看指定的结构使用过的地方：ctrl + alt + g
（22）查找与替换：ctrl + f
（23）最大化当前的View：ctrl + m
（24）直接定位到当前行的首位：home
（25）直接定位到当前行的末位：end</code></pre>
<p>（2）JUnit单元测试</p>
<pre><code>使用：
    a.选中当当前工程-右键选择：bulid path - add libraries -JUnit 4 - 下一步
    b.创建java类，进行单元测试，要求的Java类要求：1.此类权限为public 2.此类提供公共的无参构造函数
    c.此类中声明单元测试方法：此时的单元测试方法权限是public，没有返回值，没有形参
    d.此单元测试方法需要声明注解：@Test，并在单元测试类中导入：org.junit.Test包 </code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" data-id="ckp27pssm000en8ub1cv30yn0" data-title="Java类库与基本操作" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java高级编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/27/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-03-27T14:37:01.185Z" itemprop="datePublished">2021-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/27/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">Java高级编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="高级编程"><a href="#高级编程" class="headerlink" title="#高级编程"></a>#高级编程</h2><p>##基础知识 </p>
<p>1.进程<br>    定义：是程序依次执行过程，或正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程—–生命周期<br>    内容：<br>        （1）进程作为资源分配的单位，系统在运行时回味每个进程分配不同的内存区域 </p>
<p>2.线程</p>
<pre><code>定义：是一个程序内部的一条执行路径

内容：
    （1）线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器，线程切换的开销小
    （2）一个进程中的多个线程共享相同的内存单元/内存地址空间-&gt;它们从同一个堆中分配对象，可以访问相同的变量和对象


生命周期：
    ![avatar](D:/ComputerUse/blog/img/live.jpg)

多线程的创建：
    （1）方式一：继承于Thread类
        使用：
            a.创建一个Thread类的子类
            b.重写Thread类的run()----&gt;将此线程执行的操作声明在run()中
            c.创建Thread类的子类对象
            d.通过此对象调用start()：该函数会启动当前线程，并调用当前线程的run()

    （2）方式二：实现Runnable接口------&gt;该方法的实现没有类单继承的局限性，更适合用来处理多个线程有共享数据的情况
        使用：
            a.创建一个实现了Runnable接口的类
            b.实现类去实现Runnable中的抽象方法：run()
            c.创建实现类的对象
            d.将此对象作为参数传递到Thread类中的构造器中，创建Thread类的对象
            e.通过Thread类的对象调用start()：启动线程，然后调用当前线程的run()-----&gt;调用了Runnable类型的target的run()

    （3）方式三：实现Callable接口
        使用：
            a.创建一个实现Callable的实现类
            b.实现call方法，将此线程需要执行的操作声明在call()中
            c.创建Callable接口实现类的对象
            d.将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象
            e.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
            f.获取Callable中Call方法中的返回值------&gt;可以通过get()得到返回值
        注：
            a.其call()方法，可以有返回值
            b.方法可以抛出异常，被外面的操作捕获，获取异常信息 
            c.支持泛型的返回值
            d.需要借助FutureTask类

    （4）方式四：使用线程池
            作用：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中，可以避免频繁创建销毁、实现重复里哟
            优点：提高响应速度、降低资源消耗、便于线程管理
            使用：
                a.提供指定线程数量的线程池：ExexcutorService service = Exectors.newFixedThreadPool( &lt;!-- 线程数量 --&gt; )
                b.执行指定线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象
                    service.excute( &lt;!-- 实现Runnable接口类的对象 --&gt; )
                    service.submit( &lt;!-- 实现Callable接口类 的对象 --&gt; )
                c.关闭线程池：service.shutdown()
            注：可以通过强制类型转换的方式，将ExecutorService转换成ThreadPoolExecutor类型对象，对线程池的属性进行设置


Thread类常见的方法：
    start()：启动线程，并执行run()方法
    run()：线程在被调度时执行的操作
    String getName()：返回线程的名称
    void setName(String name)：设置该线程的名称
    static Thread currentThread()：返回当前线程，在Thread子类中就是this，通常用于主线程和Runnable实现类
    yeild()：释放当前CPU的执行权
    join()：在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到join的线程执行完，线程a才结束阻塞状态
    stop()：强制线程生命周期结束，不推荐使用
    boolean isAlive()：返回boolean，判断线程是否还活着
    sleep(long millitime)：让当前线程阻塞指定的millitime毫秒
    getPriority()：返回线程优先级
    setPriority(int newPriority)：改变线程的优先级

解决线程的安全问题
    同步机制：
        （1）方式一：同步代码块
                使用：
                    synchronized(同步监视器)&#123;
                        &lt;!-- 需要被同步的代码(即操作共享数据的代码) --&gt;
                    &#125;
                注：
                    a.同步监视器：俗称，“锁”。任何一个类的对象，都可以充当锁。在以上方法中，多个线程必须要共用同一把锁
                    b.在实现Runnable接口创建多线程方式中，可以考虑使用this充当同步监视器

        （2）方式二：同步方法
                使用：通过 synchronized+方法 的来使用
                注：
                    a.同步方法仍然设计到同步监视器，只是不需要我们显式的声明
                    b.非静态的同步方法的同步监视器是this，静态的同步方法的同步监视器是当前类的本身

    Lock锁：
        使用：通过生成ReentrantLock类的对象，手动的启动同步(Lock())，同时结束同步也需要手动的实现(unlock())
        注：
            a.Lock是显式锁，需要进行手动的开启和关闭，synchronized是隐式锁，除了作用域自动释放
            b.Lock只有代码块锁，synchronized有代码块锁和方法所
            c.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性

死锁：
    定义：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己所需要的同步资源，就形成了线程的死锁。出现死锁后，不会出现异常、提示，只是所有的线程都处于阻塞状态，无法继续

线程通信方法：
    方法：
        wait()：执行此方法，当前线程就进入阻塞状态
        notify()：执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，会优先唤醒优先级高的线程
        notifyAll()：执行此方法，会唤醒所有被wait的一个线程
    注：
        a.以上三个方法必须使用在同步代码块或同步方法中，同时其调用者必须是同步代码块或同步方法当中的同步监视器，否则会出现IllegalMonitorStateException异常
        b.上面三个方法是定义在java.lang.Object类中</code></pre>
<p>3.并行与并发<br>    定义：并行指的是多个CPU同时执行多个任务，并发指的是一个CPU(采用时间片)同时执行多个任务</p>
<hr>
<p>###枚举类与注解 </p>
<p>1.枚举类<br>    包：定义的枚举类默认继承于java.lang.Enum<br>    说明：<br>        a.类的对象只有有限个，确定的。当需要定义一组常量时，强烈建议使用枚举类<br>        b.如果枚举类当中只有一个对象，则可以作为单例模式的实现方式<br>        c.定义枚举类：<br>            （1）jdk5.0之前，自定义枚举类<br>                1-声明对象的属性权限为：private final<br>                2-私有化构造器，并给对象属性私有化<br>                3-提供当前枚举类的多个对象</p>
<pre><code>        （2）jdk5.0，可以使用enum关键字定义枚举类
            1-提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束
    d.使用enum关键字定义的枚举类实现接口：当我们需要在调用指定枚举类时进行不同的操作，则在枚举对象后进行重写

常用方法：
    valueOf()：返回枚举类型的对象数组，该方法可以很方便的遍历所有的枚举值。也可以给其赋值一个字符串，可以索引指定名字的枚举对象，要求字符串必须是枚举对象的&quot;名字&quot;，否则会运行异常
    toString()：返回当前枚举对象常量名称</code></pre>
<p>2.注解<br>    说明：<br>        是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。可以用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在Annotation的”name=value”对中</p>
<pre><code>使用示例：
    a.使用Annotation时要在前面增加@符号，并把该Annotation当成一个修饰符使用
    b.在编译时进行格式检查（JDK内置的三个基本注解Override\Deprecated\SuppressWarnings）
    c.跟踪代码依赖性，实现替代配置文件功能
    d.spring框架中关于“事务”的管理

自定义注解：自定义注解必须配上注解的信息处理流程(使用反射)才有意义
    a.定义新的Annotation类型使用@interface关键字
    b.内部成员，通常使用value表示，可以指定成员的默认值，使用default定义。如果自定义注解没有成员，表示是一个标识作用。

元注解：    
    说明：用于修饰其他Annotation定义，对现有的注解进行解释说明的注解
    使用：
        Retention：只能用于修饰一个Annotation定义，用于指定该Annotation的生命周期---》SOURCE\CLASS(默认行为)\RUNTIME(能通过反射)
        Target：用于指定被修饰的Annotation能用于修饰哪些程序元素
        Documented：用于指定那个被盖院Annotation修饰的Annotation类将被javadoc工具提取成文档。默认情况下，javadoc是不包括注解的
        Inherited：被它修饰的Annotation将具有继承性

jdk8中注解的新特性
    可重复注解：@Repeatable
    类型注解：
        ElementType.TYPE_PARAMETER：表示该注解能写在类型变量的声明语句中（如：泛型声明）
        ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中</code></pre>
<hr>
<p>###java集合<br>1.Collection接口：单列数据，定义了存区一组对象的方法的集合</p>
<pre><code>List：元素有序、可重复集合
    （1）ArrayList：
            作为List接口的主要实现类，线程不安全的，效率高。底层使用了Object[]存储
            源码说明：
                jdk7情况下：
                    使用空参的构造器，底层创建了长度为10的Objectp[]数组elementData，如果某次添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原    来的容量的1.5倍，同时将原有数组中的数据复制到新的数组中
                jdk8中：
                    使用空参构造器，底层创建了Object[] elementData初始化为&#123;&#125;，直到第一次调用add()时，底层才创建了长度为10的数组，后续的添加扩容操作与上个版本无异
    （2）LinkedList：
            对于频繁的插入、删除操作，使用此类效率比ArrayList效率高。底层使用双向链表存储 
    （3）Vector：
            作为List接口的古老实现类，线程不安全的，效率低。底层使用了Object[]存储
    （4）常用方法：
                &lt;!-- https://www.cnblogs.com/gaomanito/p/8979076.html --&gt;
            get：获取指定index位置的元素
            addAll(int index,Collection eles)：从index位置开始将eles中的所有元素添加进来
            indexOf(Object obj)：返回obj在集合中首次出现的位置
            set(int index,Object eles)：设置指定index位置的元素为eles
            List subList(int fromIndex,int toIndex)：返回从fromIndex到toIndex位置的子集合
            Object remove(int index)：移除指定index位置阿元素，并返回此元素
            toArray()：将集合转换为数组
            asList()：将数组转换为集合

Set：元素无序，不可重复的集合(注：无序性不等于随机性，存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的)
    （1）HashSet：底层源码使用的时HashMap
            作为Set接口的主要实现类；线程不安全；可以存储null值
            注意：元素a与已经存在指定索引位置上数据以链表的方式存储，在jdk7中，元素a存放到数组中，指向原来的元素，在jdk8中，原来的元素在数组，只想元素a（七上八下准则）
    （2）LinkedHashSet：
            作为HashSet的子类；在添加数据的同时，每个数据还维护了两个引用，记录此数据的前后数据；遍历器内部数据时，可以按照添加的顺序遍历；对于频繁的遍历操作，LinkedHashSet效率高于HashSet5
    上述要求：
        1-向Set中添加的数据，其所在的类一定要重写hashCode()和equals
        2-重写的hashCode()和equals尽可能保持一致性：相等的对象必须具有相等的散列码

    （3）TreeSet：
            可以按照添加对象的指定属性进行排序；在底层当中采用红黑树的存储结构；有序，查询速度比List快；

    上述要求：
        1-向其中添加数据，要求是相同类的对象
        2-在自然排序当中，其比较数据是否相同的方法是通过compareTo函数是否返回0，定制排序中，则使用的是compare函数，不再是通过equals </code></pre>
<p>2.Map接口：双列数据，包存具有映射关系”key-value对”的集合</p>
<pre><code>说明：
    1-Map中的key：无序的、不可重复的，使用Set存储所有的key------&gt;key所在的类要重写equals()和hashCode()（以HashMap为例）
    2-Map中的value：无序的、可重复的，使用Collection存储所有的value-----&gt;value所在的类要重写equals()  
    3-一个键值对&quot;key-value&quot;构成了一个Entry对象
    4-Map中的entry：无序的、不可重复的，使用Set存储所有的entry（对于map内部值的调用，可以通过内部接口Map.Entry的getKey和getValue来查看）
    5-负载因子：用于表示哈希表中元素填满的程度
        a.其大小决定了HashMap的数据密度
        b.负载因子越大，密度越大，发生碰撞的机率越高，数组中的链表越长
        c.负载因子越小，就越容易促发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短
        d.考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数

（1）HashMap
        说明：作为Map中的主要实现类；线程不安全的，效率高；可以存储null的key和value；在jdk7以及之前底层结构为数组+链表，在jdk7之后加入了红黑树
        子类：
            LinkedHashMap（在原有的HashMap底层结构基础上，添加了一堆指针，指向前后元素）
        底层实现原理：
            1-实例化：
                jdk7：底层创建了长度为16的一维数组Entry[] table
                jdk8：底层没有创建一个长度为16的数组，直到首次调用put()方法才创建长度为16的数组，而且其底层数组为Node[]，并非Entry[]
            2-存放数据过程：
                jdk7：调用key所在类的hashCode()计算key哈希值，得到在Entry数组中的存放位置
                    情况：
                        if(位置为空)
                            &lt;!-- 添加成功 --&gt;
                        else
                            if(此位置上所链数据的哈希值是否与hashCode(key)相同)
                                if(key.equals(obj))
                                    key-&gt;value = obj-&gt;value
                                else
                                    &lt;!-- 添加成功 --&gt;
                            else
                                &lt;!-- 添加成功 --&gt;
                        注意：如果原位置上有数据，之后添加进去的数据是以链表的形式与原数据链接
                jdk8：
                    与jdk7的区别，存储结构加入了红黑树（当数组的某一个索引位置上的元素以链表形式存在的数据个数&gt;8且当前数组的长度&gt;64时，此时此索引位置上的所有数据改为使用红黑树存储）
            3-扩容方式：扩容为原来容量的两倍，将原有的数据复制过来


                功能：保证在遍历map元素时，可以添加的顺序实现遍历；对于频繁的遍历操作，此类执行效率高于HashMap
（2）TreeMap
        功能：保证按照添加的key-value对进行排序，实现排序遍历；此时考虑key的自然排序或定制排序
        说明：底层使用红黑树
（3）Hashtable
        说明：作为古老的实现类；线程安全，效率低；不能够存储null的key或value 
        子类：
            Properties
                功能：常用来处理配置文件，key和value都是String类型

（4）常用方法：
        Obeject put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中
        void putAll(Map m)：将m中的所有key-value存放到当前的map中
        Set keySet()：返回所有key构成的Set集合
        Collection values()：返回所有value构成的Collection集合
        Set entrySet()：返回所有key-value对构成的Set集合 </code></pre>
<hr>
<p>###泛型</p>
<pre><code>说明：jdk5.0新增的特性；允许在定义类、接口时通过一个标识表示类中某个属性的类型或者时某个方法的返回值及参数类型，这个类型将在使用时确定
使用：
    1-集合接口或集合类在jdk5.0时都修改为泛型的结构
    2-在实例化集合类时，可以指明具体的泛型类型
    3-指明完以后，在集合类或接口中凡是定义类或接口时，内部结构使用到类的泛型的位置，都指定为你实例化的泛型类型
    4-泛型的类型必须是类，不能是基本数据类型；需要用到基本数据类型的位置，拿包装类替换
    5-如果实例化时，没有指明泛型的类型，默认类型为java.lang.Object类型 
    6-自定义泛型类、接口
        说明：
            a.如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object,但不等价于Object
            b.父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型。如果子类在继承带泛型的父类时，指明了泛型类型，则实例化子类对象时，不再需要指明泛型
            c.泛型类可能有多个参数，此时应将多个参数一起放在尖括号内
            d.实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致
            e.泛型不同的引用不能相互赋值
            f.在编译时两个指定不同泛型的ArrayList,但是在运行时只有一个ArryList被加载到JVM当中
            g.如果泛型结构是一个抽象类或接口，则不可创建泛型类对象
            h.异常类和静态方法不能使用泛型
            i.泛型方法：
                格式：
                    [访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出异常
                （1）在方法中出现泛型结构，泛型参数与类的泛型参数没有任何关系，换句话说，泛型方法所属的类是不是泛型类都没有关系
                （2）泛型方法在调用时，指明了泛型参数的类型
                （3）可以声明为静态的（因为泛型参数实在调用方法时确定的，并非在实例化类时确定）
            j.通配符的使用
                对于?：
                    如List&lt;?&gt;:
                        添加：不能向其内部添加数据除了添加null之外(null是所有类型的成员)
                        获取：允许读取数据，可以用get()方法并使用其返回值，读取的数据类新为Object
                对于 ? extends A:
                    如G&lt;? extends A&gt;：可以作为G&lt;A&gt;和G&lt;B&gt;的父类的，其中B是A的子类
                对于 ? super A:
                    如G&lt;? super A&gt;：可以作为G&lt;A&gt;和G&lt;B&gt;的父类的，其中B是A的父类
                添加：可以向其添加允许范围内的对象</code></pre>
<hr>
<p>###IO流</p>
<pre><code>File类（声明再java.io包下 ）

    说明：
        File类的一个对象，代表一个文件或一个文件目录；在File类当中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作；如果需要读取或写入文件内容，必须使用IO流来完成；后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点 ”

    路径：
        在IDEA中，若没有声明绝对路径，此时其默认的相对路径在当前工程文件下，若使用的是JUnit中的单元测试方法测试，相对路径即为当前Module下。
        在eclipse中，则相对路径都在当前的Project下
        路径分隔符：
            windows：\\
            unix：/

    构造器：
        File(String filePath)
        File(String parentPath,String childPath)
        File(File parantFile,String childPath)

    常用方法：
        （1）String getAbsolutrPath()：获取绝对路径
        （2）String getPath()：获取路径
        （3）String getName()：获取名称
        （4）String gatParent()：获取上层文件目录路径。若无，返回null
        （5）long length()：获取文件长度(即：字节数)；不能获取目录的长度
        （6）long lastModified()：获取最后一次的修改时间，毫秒值
        （7）String[] list()：获取指定目录下的所有文件或者文件目录的名称数组
        （8）File[] listFiles()：获取定制目录下的所有文件或者文件目录的File数组 
        （9）Boolean ranameTo(File dest)：把文件重命名为指定的文件路径；需要file1在硬盘当中是存在的，且dest不能再硬盘当中存在

        （10）boolean isDirectory()：判断是否是文件目录
        （11）boolean isFile()：判断是否是文件
        （12）boolean exists()：判断是否存在
        （13）boolean canRead()：判断是否可读
        （14）boolean canWrite()：判断是否可写
        （15）boolean isHidden()：判断是否隐藏

        （16）boolean createNewFile()：创建文件；若文件存在，则不创建，返回false
        （17）boolean mkdir()：创建文件目录；如果文件目录存在，则不创建，如果此文件目录的上层目录不存在，也不创建(使用mkdirs就可以一并创建)；
            注意：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下
        （18）boolean delete()：删除文件或者文件夹
            注意：java中的删除不走回收站，同时，要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录


I/O流

    流的分类：
        （1）按操作的数据单位：字节流(8 bit--InputStream/OutputStream) 、 字符流(16 bit--Reader/Writer)
        （2）按数据流的流向：输入流(InputSreram\Reader) 、 输出流(OutputStream\Writer)
        （3）按流的角色：节点流 、 处理流

    使用：
        结点流(文件流)---&gt;FileInputStream/FileOutputStream/FileReader/FileWriter：
            1-对于文本文件(.txt/.java/.c/.cpp)，使用字符流处理；对于非文本文件(.jpg/.mp3/.mp4/.avi/.doc/.ppt)，使用字节流处理

            2-写入：
                （1）read()的理解：返回读入的一个字符，如果达到文件末尾，返回-1
                （2）异常处理：为了保证流资源一定可以执行关闭操作，需要使用try-catch-finally处理
                （3）读入文件一定要存在，否则会报异常FileNotFoundException

            3-输出：
                （1）对于输出操作，对应的File可以不存在的；如果不存在，在输出过程中会自动创建此文件
                （2）对于FileWriter的输出操作，可以指定输出内容是否覆盖原文件内容。
        处理流：
            1-缓冲流(处理流的一种)----&gt;BufrferedInputStream/BufferedOutputStream/BufferReader/BufferedWriter
                作用：提高了流的读取、写入的速度(内部提供了一个缓冲区)
                使用：
                    （1）造文件
                    （2）造流（先造节点流，后造缓冲流）
                    （3）使用完后，资源关闭(顺序是从外到内，当我们关闭外层流时，内层流也会自动关闭)

            2-转换流
                作用：提供了在字节流和字符流之间的转换
                使用：
                    InputStreanReader：将一个字节的输入流转换为字符的输入流(解码)
                    OuputStreamWriter：将一个字符的输出流转换为字节的输出流 (编码)
                注意：文件编码的方式，决定了解析时使用的字符集

            3-标准输入、输出流
                作用：
                    System.in：标准的输入流，默认从键盘输入
                    System.out：标准的输出流，默认从控制台输出
                使用：
                    System类的setIn(InputStream is)/setOut(PrintStream ps)方式重新指定输入和输出的

            4-打印流
                作用：实现将基本数据类型的数据格式转换为字符串输出
                使用：
                    PrintStream/PrintWriter 
                        功能：
                            （1）提供可一系列重载的print()和println()方法，用于多种数据类的输出
                            （2）上面两者的输出不会抛出IOException异常
                            （3）有自动的flush功能
                            （4）PrintStream打印的所有字符都使用平台的默认字符编码转化为字节，在需要写入字符而不是写入字节的情况下，应该使用PrintWriter类
                            （5）System.out返回的是PrintStream的实例

            5-数据流
                作用：更方便的操作java语言的基本数据类型和String的数据，用于读取和写出基本数据类型、String类的数据
                使用：主要通过DataOutputStream/DataIntputStream实现
                    注意：读取不同类型的数据的顺序要与当初写入文件时，保存的数据顺序一致

            6-对象流
                作用：用于存储和读取基本数据类型数据或对象的处理流，其强大之处在于可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来
                使用：
                    ObjectInputStream/ObjectOutputStream
                    （1）序列化：用ObjectOutputStream类保存基本数据或对象的机制
                            （1）该机制允许把内存当中的java对象转换成平台无关的二进制流
                            （2）可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原
                            （3）序列化是RMI(Remote Method Invoke - 远程方法调用)过程的参数和返回值都必须实现的机制，而RMI是JavaEE的基础；因此序列化机制是JavaEE
                            （4）要使某个对象支持可序列化，则必须让对象所属的类即其属性是可序列化的
                            注意：
                                为了让某个类是可序列化的，该类必须
                                    a.实现 Serializable/Externalizable 这两个接口之一，否则会抛出NotSerializableException异常；
                                    b.该类需要提供一个全局常量：serialVersionUID（其用来表明类的不同版本间的兼容性，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容）；如果类没有显式定义这个静态变量，它的值时Java在运行时环境根据类的内部细节自动生成的，若类的实例变量做了修改，则serialVersionUID可能发生变化
                    （2）反序列化：用ObjectInputStream类读取基本数据类型或对象的机制
                    注意：
                        ObjectInputStream和ObjectOutputStream不能序列化static和transient修饰的成员变量

            7-随机存取文件流(RandomAccessFile)
                作用：支持“随机访问”方式，程序可以直接跳到文件的任意地方来读、写文件；支持只访问文件的部分内容，可以向已存在的文件后追加内容
                使用：
                    （1）其直接继承于java.lang.Object类，实现了DataInput和DataOutput接口
                    （2）其既可以作为一个输入流，又可以作为一个输出流
                    （3）创建的RandomAccessFile类实例需要指定一个mode参数，该参数只当RandomAccessFile的访问模式：
                        --r：以只读方式打开
                        --rw：打开以便读取和写入
                        --rwd：打开以便读取和写入；同步文件内容的更新
                        --rws：打开以便读取和写入；同步文件内容和元数据的更新
                        注意：
                            a.如果模式为只读r，其是去读取一个已经存在的文件，如果读取的文件不存在，则会出现异常；如果是rw读写模式，当文件不存在时，则会去创建文件，如果存在则不创建
                            b.如果RandomAccessFile作为输出流时，如果写出的文件存在，则会对原有文件内容进行覆盖(默认情况下，从头覆盖)
                    （4）该类的对象包含一个记录指针，用以指示当前读写处的位置；其对象可以自由移动记录指针：
                        --long getFilePointer()：获取文件记录指针的当前位置
                        --void seek(long pos)：将文件记录指针定位到pos位置

NIO(New IO,Non-Blocking IO)
    说明：用于替代标准的Java IO API，其与原来的IO有同样作用和目的，但是使用方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作，NIO将以更高效的方式进行文件的读写操作

    使用：
    --java.nio.channels.Channel
        --FileChannel：处理本地文件
        --SocketChannel：TCP网络编程的客户端的Channel
        --ServerSocketChannel：TCP网络编程的服务器端的Channel
        --DataGramChannel：UDP网络编程中发送端和接收端的Channel

    （1）针对标准输入输出NIO
    （2）网络编程NIO</code></pre>
<p>###网络编程</p>
<pre><code>说明：直接或间接地通过网络协议与其他计算机实现数据交换，进行通讯        
要素：
    1-IP地址(InetAddress)
        --作用：唯一的表示Internet上计算机
        --本地回环地址：127.0.0.1
        --主机名：localhost
        --分类方式：
            方式1：
                --IPV4：4个字节组成，4个0-255，以点分十进制表示
                --IPV6：128位(16个字节)，写成8个无符号整数，每个整数用四个16禁止位表示，数之间用冒号(:)分开，如：3ffe:3201:1401:1280:c8ff:fe4d:db39:1984
            方式2：
                公用地址（万维网使用）/私有地址（局域网使用）
                注意：以192.168.开头就是私有地址

        --使用：java中使用InetAddress类代表IP
            --实例化：
                a.使用getByName(String host)，对其赋IP地址或域名
                b.使用getLocalHost()，生成本地的IP地址

    2-端口号
        --作用：标识正在计算机上运行的进程(程序)
        --格式：规定为一个16位的整数0~65535
        --分类：
            --公认端口：0~1023，被预先定义的服务通信占用
            --注册端口：1024~49151，分配给用户进程或应用进程
            --动态/私有端口：49152~65535
        --Socket：端口号与IP地址的组合得出的网络套接字

    3-网络协议
        --TCP协议(传输控制协议)/IP协议(网络互联协议)
            --IP协议是网络层的主要协议，支持网间互连的数据通信
            --TCP/IP协议模型形成了高效的四层体系结构（物理链路层、IP层、传输层和应用层）
            --协议要求：
                1.使用TCP协议钱，须简历TCP链接，形成数据通道
                2.传输前，采用“三次握手”方式，点对点通信，是可靠的
                3.TCP协议进行通信的两个应用进程：客户端、服务端
                4.在连接中可进行大数据量的传输
                5.传输完毕，需释放已建立的链接(&quot;四次挥手&quot;)，效率低
            --使用：
                --进程端：
                    1.创建Socket对象，指明服务器端的ip和端口号
                    2.获取一个输出流，用于输出数据
                    3.写出数据操作
                    4.资源关闭
                --服务器端：
                    1.创建服务器端的ServerSocket，指明自己的端口号
                    2.调用accept()表示接受来自于客户端的socket
                    3.获取输入流
                    4.读取输入流中的数据
                    5.关闭资源

        --UDP协议(用户数据报协议)
            --协议要求：
                1.将数据、源、目的封装成数据包，不需要建立连接
                2.每个数据报的大小限制在64K
                3.发送不管对方是否准备好，接受方收到也不确认，是不可靠的
                4.可以广播发送
                5.发送数据结束时无需释放资源，开销小，速度快
            --使用：
                1.DatagramSocket/DatagranPacket实现了基于UDP协议网络程序
                2.其通过数据报套接字DatagramSocket发送和接收系统不保证UDP数据报一定能够安全送到目的地，也不确定什么时候可以抵达
                3.DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号
                4.UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接
                --发送端

        --URL类 
            说明：统一资源定位符，表示Internet上某一资源的地址
            基本结构：&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表
                --参数列表格式：参数名=参数值&amp;参数名=参数值......</code></pre>
<p>###Java反射机制(Reflection)</p>
<pre><code>说明：
    反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法；加载完类后，在对内存的方法区中就产生了一个class类型的对象(一个类只有一个Class对象)，这个对象就包含了完整的类的结构信息，可以通过这个对象看到类的结构 

区别：
    正常方式：引入需要的“包类”名称---&gt;通过new实例化----&gt;取得实例化对象
    反射方式：实例化对象---&gt;getClass()方法---&gt;得到完整的“包类”名称 

java.lang.Class类（对应着加载到内存中的一个运行时类）
    类的加载过程：
        --程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)，接着使用java.exe命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，加载到内存中的类，称其为运行时类，此运行时类就作为Class的一个实例。
        --加载到内存中的运行时类，会缓存一定的时间，在此时间之内，可以通过不同的方式来获取此运行时类

    获取Class实例的方式：
        --调用运行时类的属性：class
        --通过运行时类的对象，调用getClass方法
        --调用Class的静态方法：forName(String classPath(绝对路径))
        --使用类的加载器(ClassLoader):
            --类加载器
                作用：
                    将class文件字节码内容加载到内存中，并将这些静态数据转换成方法风趣的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法去中类数据的访问入口
                类缓存：
                    标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载(缓存)一段时间；不过JVM垃圾回收机制可以回收这些Class对象
                分类：
                    --引导类加载器：
                        用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库，该加载器无法直接获取
                    --扩展类加载器：
                        负责jre/lib/ext目标下的jar包或-D java.ext.dirs指定目录下的jar包装入工作库
                    --系统类加载器：
                        负责java -classpath 或 -D java.class.path 所指的目录下的类与jar包装入工作，是最常用的加载器
                    注意：
                        --对于自定义类，使用系统类加载器进行加载
                        --调用系统加载的getParent()，获取扩展类加载器
                        --调用扩展类加载的getParent()，无法获取引导类加载器

    读取配置文件：
        方式：
            (1)此时的文件默认在当前的module下
                Properties pros = new Properties();
                FileInputStream fis = new FileInputStream(配置文件)
                pros.load(fis);
            (2)使用ClassLoader：此时配置文件默认在当前module的src下
                ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
                InputStream is = classLoader.getResourceAsStream(配置文件)
                pros.load(is);

    常用方法：
        --newInstance()：调用此方法，创建对应的运行时类的对象；内部调用了运行时类的空参构造器
            注意：
                （1）创建运行时类的对象，要求：
                    --运行时类必须提供空参的构造器
                    --空参的构造器的访问权限得够，通常设置为public
                （2）javabean中要求提供一个public的空参构造器，原因：
                    --便于通过反射，创建运行时类的对象
                    --便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器 

        --getFields()：获取当前运行时类及其父类中声明为public访问权限的属性
        --getDelaredFields()：获取当前运行时类中声明的所有属性(不包含父类中声明的属性)
        --getMethods()：获取当前运行时类及其父类中声明为public访问权限的方法
        --getDelaredMethods()：获取当前运行时类中声明的所有方法(不包含父类中声明的方法)
        --getConstructors()：获取当前运行时类中声明的public的构造器
        --getDelaredConstructors()：获取当前运行时类中声明的所有的构造器
        --getGenericSuperclass()：获取运行时类的带泛型的父类的泛型
        --getDeclaredConstructor()：调用构造器
        --getPackage()：获取运行时类所在的包

        调用运行时类中的指定属性：
            --创建运行时类的对象
            --通过getDeclaredField(String fieldName)：获取运行时类中指定变量名的属性
            --为了保证当前属性是可访问的，使用setAccessible()置为true
            --获取、修改指定对象的此属性值

        获取指定的某个方法：
            --创建运行时类的对象
            --通过getDelaredMethod(获取的方法名称，获取方法的形参列表)
            --为了保证当前属性是可访问的，使用setAccessible()置为true
            --调用方法invoke(方法的调用者，给方法形参赋值的实参 )

动态代理：

    说明：是指客户通过对代理类来调用其他对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象

    使用场景：
        --调试
        --远程方法调用

    区别：
        --静态代理：代理类与被代理类在编译期间，就确定下来了

    实行方法：
        --创建接口与被代理类
        --创建InvocationHandler的接口类，重写invoke函数
        --创建代理类（每次调用代理类时，会跳转到接口类的invoke方法，从而调用被代理类当中的方法）

    优点：相比于静态代理，其抽象角色中(接口)声明的所有方法都被转移到调用处理器一个集中的方法中处理，可以更加灵活和统一的处理众多的方法</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/27/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" data-id="ckp27pssp000hn8ub9adm1tp1" data-title="Java高级编程" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2021-03-22T06:51:03.838Z" itemprop="datePublished">2021-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="设计模式"><a href="#设计模式" class="headerlink" title="#设计模式"></a>#设计模式</h2><p>##单例设计模式<br>    描述：采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，能够减少系统性的开销<br>    实现方法：<br>        1.饿汉式：其是线程安全的，但加载时间相对更长<br>            （1）私有化类的构造器<br>            （2）内部创建类的对象（也必须声明为静态）<br>            （3）提供公共的静态方法，返回类的对象<br>        2.懒汉式：能够延迟对象的创建，但目前是线程不安全的<br>            （1）私有化类的构造器<br>            （2）声明当前类对象，没有初始化（此对象也须声明为static）<br>            （3）声明public、static的返回当前类对象的方法</p>
<hr>
<p>##模板方法设计模式<br>    描述：当功能内部一部分实现是确定的，一部分是现实不确定的。这时可以把不确定的部分暴露出去，让子类去实现，这是一种模板模式</p>
<hr>
<p>##代理设计模式<br>    描述：代理设计就是为其他对象提供一种代理以控制对这个对象的访问<br>    应用场景：<br>        安全代理：屏蔽对真实角色的直接访问<br>        远程代理：通过代理类处理远程方法调用(RMI)<br>        延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象<br>    分类：<br>        静态代理：静态定义代理类<br>        动态代理：动态生成代理类</p>
<hr>
<p>##工厂设计模式<br>    描述：实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="ckp27pssl000dn8ube17hdr5y" data-title="设计模式" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-STL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/15/STL/" class="article-date">
  <time class="dt-published" datetime="2021-03-15T12:07:43.502Z" itemprop="datePublished">2021-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/15/STL/">STL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="STL"><a href="#STL" class="headerlink" title="#STL"></a>#STL</h2><h2 id="stl的使用"><a href="#stl的使用" class="headerlink" title="##stl的使用"></a>##stl的使用</h2><p>###pair的使用</p>
<pre><code>定义：
    （1）pair&lt;数据类型,数据类型&gt; p;
    （2）pair&lt;int,int&gt; p(1,5),直接初始化其内容
    （3）pair&lt;int,int&gt; p[maxnum]，定义了一个pair类型数组

访问：
    通过first与second访问其前后的内容
使用：
    （1）向pair数组里面插入值
        （a）map&lt;int,int&gt; mp;
            mp.insert(make_pair(1,2));
        （b）pair&lt;int,int&gt; p[maxnum];
            p[i]=&#123;1,2&#125;;
注意：可以直接使用关系运算符进行比较，当first相同时会通过判别second的大小来比较</code></pre>
<hr>
<p>###set的使用</p>
<pre><code>说明：
    （1）是一种包含已排序对象的关联容器，set集合容器实现了红黑树的平衡二叉搜索树的数据结构，在插入元素时，会自动调整二叉树的排序，把元素放到适当的位置，他不会插入相同键值的元素，而采取忽略处理
    （2）平衡二叉树的检索使用中序遍历算法，检索效率高于vector\deque\list等容器
    （3）对于该容器中的简直，不可直接去修改，应该先删除该键值，再插入新的键值
    （4）不提供直接存取元素的任何操作函数，只能通过迭代器进行间接存区，而且从迭代器角度来看，元素值是常数
    （5）元素比较动作只能用于型别相同的容器(即元素和排序准则必须相同)

常用方法：
    begin()：返回指向第一个元素的迭代器
    clear()：清除所有元素
    count()：返回某个值元素的个数
    end()：返回指向最后一个元素下一个位置的迭代器
    equal_range()：返回集合中与给定值相等的上下限的两个迭代器
    erase()：删除集合中的元素 find()：返回一个指向被查找到元素的迭代器 get_allocator()：返回集合的分配器
    insert()：在集合中插入元素 lower_bound()：返回指向大于（或等于）某值的第一个元素的迭代器
    key_comp()：返回一个用于元素间值比较的函数 max_size()：返回集合能容纳的元素的最大限值
    rbegin()：返回指向集合中最后一个元素的反向迭代器 rend()：返回指向集合中第一个元素的反向迭代器 size()：集合中元素的数目
    swap()：交换两个集合变量 upper_bound()：返回大于某个值元素的迭代器 value_comp()：返回一个用于比较元素间的值的函数</code></pre>
<p>###其他函数</p>
<p>iterator unique(iterator it_1,iterator it_2)：元素去重(删除相邻的重复元素(只保留一个))<br>    说明：其去重过程实际上就是不停的把后面不重复的元素移到起那面，即使用不重复的元素占领重读元素的位置，容器的长度并没有发生变化</p>
<p>lower_bound(iteraror it_1,iterator it_2,x)：返回指向a中第一个大于/等于x的元素迭代器<br>upper_bound(iteraror it_1,iterator it_2,x)：返回指向a中第一个大于x的元素迭代器<br>    注意：it_1到it_2之间的区域需要为一个元素(从小到大)排列的vector的一部分，若添加compare函数找小于等于或小于x的元素，则需要时从大到小的顺序</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/15/STL/" data-id="ckp27pss60002n8ubf4sx3t60" data-title="STL" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-algorithm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/15/algorithm/" class="article-date">
  <time class="dt-published" datetime="2021-03-15T12:05:55.901Z" itemprop="datePublished">2021-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/15/algorithm/">algorithm</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="algorithm"><a href="#algorithm" class="headerlink" title="#algorithm"></a>#algorithm</h2><h2 id="算法学习"><a href="#算法学习" class="headerlink" title="##算法学习"></a>##算法学习</h2><p>###快速排序</p>
<pre><code>void quickSort(vector&lt;int&gt;&amp; arr,int left,int right)&#123;

    if(left&gt;=right)
        return;
    &lt;!--确定目标数与比较数的位置--&gt;
    int oldLeft = left,oldRight = right;

    &lt;!-- 用于记录序列是否排序完毕 --&gt;
    bool judge = true;
    int    target = arr[left];

    &lt;!-- 通过左右往返比较，确定目标值在序列当中的位置 --&gt;
    while(left&lt;right)&#123;
        while(left&lt;right &amp;&amp; arr[right]&gt;=target)&#123;
            right--;
            judge=false;
        &#125;
        arr[left] = arr[right];

        while(left&lt;right &amp;&amp; arr[left]&lt;=target)&#123;
            left++;
            judge=false;
        &#125;
        arr[right] = arr[left];
    &#125;
    arr[left] = target;

    &lt;!-- 将目标数左右两侧的序列分开进行排序 --&gt;
    if(!judge)&#123;
        quickSort(arr,oldLeft,left-1);
        quickSort(arr,left+1,oldRight);
    &#125;
    return ;
&#125;</code></pre>
<hr>
<p>###堆排序</p>
<pre><code>void adjustPos(vector&lt;int&gt;&amp; args,int markPos,int size)
&#123;
    &lt;!-- 左右叶节点  --&gt;
    int left = 2*markPos+1;
    int right = 2*markPos+2;

    &lt;!-- 记录最值位置，比较左右结点与根节点的大小  --&gt;
    int maxNums=markPos;
    if(left&lt;size &amp;&amp; args[left]&gt;args[maxNums])
        maxNums = left;
    if(right&lt;size &amp;&amp; args[right]&gt;args[maxNums])
        maxNums = right;
    if(maxNums!=markPos)&#123;
        swap(args[maxNums],args[markPos]);    
        adjustPos(args,maxNums,size);
    &#125;
    return ;
&#125;
void heapSort(vector&lt;int&gt;&amp; args)&#123;
    int markNode=args.size()/2-1;        &lt;!-- 最后一个非叶子节点位置 --&gt; 

    &lt;!-- 通过遍历非叶子结点，将其构造成大顶堆（升序）/小顶堆（降序） --&gt; 
    for(int i=markNode;i&gt;=0;i--)&#123;
        adjustPos(args,i,args.size());
    &#125;

    &lt;!-- 每次得到根节点为最大值  --&gt;
    for(int i=args.size()-1;i&gt;=1;i--)&#123;
        swap(args[i],args[0]);
        adjustPos(args,0,i);
    &#125;
    return ;
&#125;</code></pre>
<p>###哈希表</p>
<p>###优先队列</p>
<pre><code>功能：在优先队列中，元素被赋予优先级，当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出的行为特征

实现：
    class prorityQueue&#123;
        public:
            prorityQueue()&#123;

            &#125;
            &lt;!-- 对于基本类型的大/小顶堆  --&gt;
            void bigTopPile()&#123;
                &lt;!-- 等同于priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; a
                若要其置成小顶堆则
                    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; --&gt;
                priority_queue&lt;int&gt; a;          
                int s=0;
                while(cin&gt;&gt;s)&#123;
                    a.push(s);
                &#125;
                while(!a.empty())&#123;
                    cout&lt;&lt;a.top()&lt;&lt;&quot; &quot;;
                    a.pop();
                &#125;
                return ;
            &#125;

            &lt;!-- 使用pair做优先队列元素，先比较第一个元素，第一个相等比较第二个 --&gt;
            void pairPriorityQueue(int nums)&#123;
                priority_queue&lt;pair&lt;int,string&gt; &gt; pq;
                int pos;
                string posStr;
                pair&lt;int,string&gt; p1[nums];
                int i=0;
                while(cin&gt;&gt;pos&gt;&gt;posStr)&#123;
                    p1[i]=&#123;pos,posStr&#125;;
                    pq.push(p1[i]);
                    i++;
                &#125;
                while(!pq.empty())&#123;
                    cout&lt;&lt;pq.top().first&lt;&lt;&quot; &quot;&lt;&lt;pq.top().second&lt;&lt;endl;
                    pq.pop();
                &#125;
                return ;

            &lt;!-- 用自定义的类型做优先队列元素 --&gt;

            &#125;
    &#125;;</code></pre>
<p>###并查集</p>
<pre><code>作用：主要可以用于解决一些元素分组的问题，管理一系列不相交的集合
功能：
    （1）合并：把两个不相交的集合合并为一个集合
    （2）查询：查询两个元素是否在同一个集合中
实现：
    MergeQurey()&#123;
        nums=0;
        &lt;!-- 使用两个数组分别来记录当前点所连接的根节点，以及当前节点深度 --&gt;
        vector&lt;int&gt; t1(10001,0),t2(10000,1);
        pre = t1;
        rank = t2;
        for(int i=0;i&lt;10001;i++)
            pre[i]=i;
    &#125;
    &lt;!-- 用于搜寻当前结点的根节点 --&gt;
    int find(int j)&#123;
        if(pre[j] == j)
            return j;
        else
            return find(pre[j]);
    &#125;
    &lt;!-- 合并两个节点,比较两个节点的深度,尽量由深度短的节点,指向深度深的节点,减少节点长度,降低搜寻长度 --&gt;
    void orderMerge(int i,int j)&#123;
        int x= find(i),y = find(j);
        if(rank[x] &lt;= rank[y])&#123;
            pre[x] = y;
        &#125;else&#123;
            pre[y] = x;
        &#125;
        &lt;!-- 当两个节点深度相同，则二者相连 --&gt;
        if(rank[x] == rank[y] &amp;&amp; x!=y)
            rank[y]++; 
    &#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/15/algorithm/" data-id="ckp27pss70003n8ub08y2coi4" data-title="algorithm" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-JavaLearing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/08/JavaLearing/" class="article-date">
  <time class="dt-published" datetime="2021-03-08T06:43:23.566Z" itemprop="datePublished">2021-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<p>title: JavaLearing<br>tags: </p>
<hr>
<h2 id="Java学习"><a href="#Java学习" class="headerlink" title="#Java学习"></a>#Java学习</h2><p>##编程基础</p>
<hr>
<p>###基础知识杂记<br>1.进制转换</p>
<pre><code>二进制：0b开头
八进制：0开头
十六进制：0x开头</code></pre>
<p>2.运算符<br>    位运算符：</p>
<pre><code>    操作的都为整型数据
    右移运算符根据最高位的数来补充（&gt;&gt;&gt;都用0补）
    ~：正(负)数取反，各二进制码按补码各位取反
    运算符优先级：</code></pre>
<p>3.Scanner</p>
<pre><code>包：java.util.Scanner
对象生成：Scanner scanner = new Scanner(System.in);

int型数据：nextInt()
double型数据：nextDouble()
float型数据：nextFloat()
boolean型数据：nextBoolean()
char型数据：Scanner没有提供相关的方法，只能通过获取一个字符串，再通过String当中的charAt()获取

注意：需要根据相应的方法来输入指定类型的值，如果输入的数据类型与要求的类型不匹配时，会报异常</code></pre>
<p>4.条件转换语句</p>
<pre><code>switch结构中的表达式所允许的数据类型：
    byte、short、char、int、枚举类型（JDK5.0新增）、String类型（JDK7.0新增）</code></pre>
<p>5.可变个数形参(jdk5.0新增的内容)</p>
<pre><code>格式：数据类型 ... 变量名
使用：其性质与数组相同
注意：
    (1)    则其与本类名中方法名相同，形参类型也相同的数组之间不构成重载，二者不能共存
    (2)    在形参当中使用，必须声明在末尾
    (3)    最多只能声明一个可变形参</code></pre>
<p>6.Java中的参数传递机制：值传递</p>
<pre><code>如果参数是基本数据类型，此时实参赋给形参的是实参的真实存储的数据值
如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值 </code></pre>
<hr>
<p>###面向对象（程序设计要求高内聚、 低耦合）</p>
<p>1.对象的内存解析：</p>
<pre><code>堆：所有的对象实例以及数组都要在堆上分配
栈（虚拟机栈）：用于存储局部变量等
方法区：用于存储已被虚拟机加载的类信息、常量、静态、变量、即使编译器编译后的代码等数据
类属性：在内存当中加载到堆空间中
局部变量：在内存当中加载到栈空间中</code></pre>
<p>2.封装性：</p>
<pre><code>访问权限：用于修饰类以及类的内部结构：属性、方法、构造器、内部类
    (1)    private：类内部
    (2)    default（缺省）：private + 同一个包 
    (3)    protected：default + 不同包的子类
    (4)    public：proctected + 同一个工程
    注意：对于class的权限修饰只可以用public和default，public类可以在任意地方被访问，default类只可以被同一个包内部的类访问</code></pre>
<p>3.继承性：</p>
<pre><code>格式：class A extends B（子类A继承父类B后，子类A中就获取了父类B中声明的结构、属性和方法 ）
        A:子类、派生类、subclass
        B:父类、超类、基类、superclass

使用：
    （1）一个类只能有一个父类，java中的单继承性 
    （2）一个父类可以派生出多个子类
    （3）子父类是相对的
    （4）子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法

注意：
    （1）父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私 有的结构，只因为封装性的影响，使得子类不能直接调用父类的结构
    （2）如果没有显示的声明一个类的父类，则此类继承于java.lang.Object类（注：所有的java类，处java.lang.Object类之外，都直接或简介的继承于java.lang,Object类，也就意味着，所有Java类具有java.lang.Object类生命的功能）</code></pre>
<p>4.多态性：父类的引用指向子类的对象</p>
<pre><code>使用：
    （1）虚拟方法调用：子类中定义了伊夫雷同名同参数的方法，在多态情况下，将此时父类的方法成为虚拟方法，父类根据赋值给他的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期时无法确定的
    （2）有了对象多态性以后，在编译期中，我们只能调用父类中声明的方法，但在运行期，实际执行的时子类重写父类的方法
    （3）对象的多态性只适用于方法， 不适用于属性
    （4）使用对象的多态性时，内存实际上是加载了子类特有的属性和方法，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法，子类特有的属性和方法不能调用
    （5）可以使用强制类型转换向下转型，赋给子类对象（注意：使用强制类型转换，可能会出现ClassCastException异常，我们可以使用instanceof关键字进行判断）</code></pre>
<p>5.方法的重写（override/overwrite）：</p>
<pre><code>功能：重写后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的时子类重写父类的方法，进行覆盖操作
规定：
    （1）子类重写方法的权限修饰符不小父类被重写的方法的权限修饰符
    （2）返回值类型
        父类为void--------&gt;子类void
        父类为A类型-------&gt;子类为A类或A类的子类
        父类为基本数据类型---------&gt;子类为相同的基本数据类型
    （3）子类重写的方法抛出异常 类型不大于父类被重写的方法抛出的异常类型
注意：子类不能重写父类中声明为private的方法</code></pre>
<p>6.子类对象实例化的全过程</p>
<pre><code>（1）从结果上看：（继承性）
    子类继承父类够，就获取了父类中声明的属性或方法
    创建子类对象，在堆空间中就会加载所有父类中生命的属性
（2）从过程上看：
    当我们通过子类的构造器创建子类对象时，一定会直接或间接的调用其父类的构造器，进而调用父类的父类构造器，直到调用了java.lang,Object类中的空参的构造器为止。因此我们才可以看到内存中有父类的结构，子类对象才可以考虑进行调用</code></pre>
<p>7.关键字</p>
<pre><code>this关键字：
    功能：用来修饰属性、方法、构造器，可以理解为当前对象或当前正在创建的对象
    使用：
        在类的构造器和方法中我们可以使用“this.属性”或“this.方法”的方式，来调用当前正在创建的对象属性或方法/已存在的对象属性或方法，同时我们可以通过使用“this（形参列表）”的方式，来调用本类中指定的其他构造器，但是不能调用自己这个构造器 


package关键字：
    功能：为了更好的实现项目中类的管理
    使用：
        （1）使用其声明类或接口所属的包，声明在源文件的首行
        （2）属性名中每“.”一次，代表一层文件目录
        （3）同一个包下，不能命名同名的接口或类

import关键字：
    功能：在源文件中显式的使用import结构导入指定包下的类、接口 
    使用： 
        （1）声明在包的声明和类的声明之间
        （2）使用“xxx.*”的方式，表示可以导入xxx包下的所有结构
        （3）如果使用的类或接口是java.lang包下定义的或者是在本包下定义的，则可以省略import结构
        （4）如果在源文件中，使用了不同包下的同名类，则必须至少有一个需要以全类名的方式显示
        （5）使用“xxx.*”方式表明可以调用xxx包下的所有结构，但是如果使用的是xxx子包下的结构，则仍需导入 
        （6）import static：导入指定类或接口中的静态结构

super关键字（可以理解为父类的）
    功能：
        （1）可以在子类的方法或构造器当中，通过使用“super.属性”或“super.方法”的方式，显式的调用父类中声明的属性或方法，但是通常对其进行省略
        （2）当子类和父类中定义了同名的属性时，想要在子类当中调用父类中声明的属性，则必须显式的使用“super.属性”的方法，表明调用的时父类中声明的属性
        （3）当子类重写了父类中的方法后，若是需要在子类当中调用父类的方法时，则必须显式的使用“super.方法”的方式，表明调用的是父类被重写的方法
        （4）可以在子类的构造器中显式的使用“super(形参列表)”的方法调用父类中声明的指定构造器（注意：必须声明在子类构造器的首行，同时对于this(形参列表)或super(形参列表)，二者不能同时出现）
        （5）在构造器的首行中，没有显式的声明“this(形参列表)”或“super(形参列表)”，则默认调用的是父类中空参的构造器
        （6）在类的多个构造器中，至少有一个类的构造器实用了“super(形参)”，调用父类中的构造器

instanceof关键字
    功能：判断指定对象是否是指定类的实例
    格式：a instanceof A（a对象 A类）

static关键字：
    功能：静态的，可以用来修饰属性、方法、代码块、内部类
    使用：
        （1）属性：是否使用static修饰，分为静态属性(类变量)和非静态属性(实例变量)
                实例变量：所创建的每个对象都独立拥有一套类中的非静态属性
                静态变量：所创建的多个对象都共享一个静态变量，当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，进行了修改。同时，静态变量随着类的加载而加载，其加载要早于对象的创建，则可以通过 “ 类.静态变量 ” 的方式来进行调用
        （2）方法：其使用方法与属性一致
                注意：
                    a.在静态方法中，只能调用静态的方法或属性
                    b.在静态方法中，不可以使用this关键字、super关键字

final关键字：
    功能：可以用来修饰类、方法、变量
    使用：
        （1）用来修饰类，此类不能被其他类所继承
        （2）用来修饰方法，表明此方法不能被重写
        （3）用来修饰变量，此时变量称为“常量 ”，其赋值的位置有显式初始化、代码块中初始化、构造器中初始化。当使用final修饰形参时，表明此形参是一个常量，当我们调用此方法时，给常量形参赋一个实参，一旦赋值以后，就只呢在方法体内使用此形参，但不能进行重新赋值
        （4）static final用来修饰属性：全局常量

abstract关键字： 
    功能：可以用来修饰的类和方法 
    使用：
        修饰对象为类： 
            （1）此类不能实例化
            （2）此类中一定有构造器，便于子类实例化时调用（因此，在开发中都会提供抽象类的子类，让子类对象完成实例化，完成相关操作） 
        修饰对象为方法：
            （1）抽象方法只有方法的声明，没有方法体 
            （2）包含抽象方法的类，一定是个抽象类，而抽象类中可以没有抽象方法
            （3）若子类重写了父类中的所有抽象方法后，此子类方可实例化，若没有重写完父类中所有的抽象方法，此子类也是一个抽象类，需要使用abstract修饰 
    注意：
        （1）不能用来修饰属性、构造器等结构 
        （2）不能用来修饰私有方法、静态方法、final方法、final类

mian()方法
    功能： 
        （1）作为程序的入口
        （2）一个普通的静态方法
        （3）可以作为与控制台交互的方式 </code></pre>
<p>8.代码块（初始化块）</p>
<pre><code> 作用：用来初始化类、对象
 使用：
     （1）代码块如果有修饰的话，只能使用static
     （2）对于静态代码块：初始化类的信息 
             a.内部可以有输出语句
             b.随着类的加载而执行，而且只会执行一次
             c.如果类中定义了多个静态代码块，则按照声明的先后顺序执行
             d.只能调用静态结构
         对于非静态代码块：可以在创建对象时，对对象的等进行初始化
             a.内部可以有输出语句
             b.随着对象的创建而执行，每创建一次对象执行一次
             c.按照声明的先后顺序执行</code></pre>
<p>9.接口(interface)：Java中，接口和类是并列的两个结构</p>
<pre><code>使用：
    （1）在JDK7及以前：只能定义全局常量(public static final)和抽象方法(public abstract)，在JDK8以后：增加定义静态方法、默认方法
    （2）接口中不能定义构造器，意味着其不能实例化
    （3）Java开发中，接口通过让类去实现(implements)的方式来使用实例化，如果实现类覆盖了接口中所有的抽象方法，则实现类就可以实例化，若没有完全覆盖，则仍为抽象类
    （4）Java类中可以实现多个接口（弥补Java当中单继承性的局限性）
        格式：class AA extends BB implements CC,DD
    （5）接口与接口之间可以继承，而且可以多继承
    （6）接口中定义的静态方法，只能通过接口来调用
    （7）通过实现类的对象，可以调用接口中的默认方法。如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法
    （8）对于方法的类优先原则：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的方法，那么子类再没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法
    （9）接口冲突：在实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么实现类没有重写此方法的情况下，会报错。解决接口冲突则需在实现类当中重写此方法
    （10）在子类(或实现类)的方法当中调用父类、接口被重写的方法
            自己重写的方法：use();
            父类中声明的方法：super.use();
            接口中的默认方法：XXX.super.use()</code></pre>
<p>10.内部类</p>
<pre><code>描述：在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类
分类：
    （1）成员内部类(静态、非静态)：
        a.作为一个类：
            类内可以定义属性、方法、构造器等
            可以被final修饰，表示此类不能被继承
            可以被abstract修饰
        b.作为外部类的成员：
            可以调用外部类的结构
            可以被static修饰
            可以被4种不同的权限修饰

    （2）局部内部类(方法内、代码块内、构造器内)：在局部内部类的方法中，如果调用及局部内部类所声明的方法中的局部变量，要求此局部变量声明为final
使用：
    （1）实例化成员内部类对象
        example ：Person.Bird bird = new p.Bird()</code></pre>
<hr>
<p>###异常处理(抓抛模型)</p>
<pre><code>方法：
    （1）try-catch-finally：
            使用：
                try&#123;
                    可能出现异常的代码
                &#125;catch(异常类型1 变量名1)&#123;
                    处理异常的方式
                &#125;
                ....
                finally&#123;
                    一定会被执行的代码(即使catch当中出现异常，或try当中出现return语句)
                &#125;

        注意：
            a.finally是可选的
            b.catch中的若异常类型如果满足子父类关系，则要求子类一定声明在父类上面。否则，报错。
            c.使用该异常处理方式，处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错
            d.开发中，由于运行时异常比较常见，所以通常不针对运行时异常编写 方法来处理

    （2）throws+异常类型：
            使用：
                （1）写在方法的声明处，指明方法执行时，可能会抛出的异常类型。一旦方法体执行时出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码就不再执行
                （2）如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws

    （3）throw关键字：通过throw new 异常类的方法，从而可以手动生成异常对象，声明在方法体内

    （4）自定义异常类
            使用：
                （1）继承与现有的异常结构：RuntimeExeption\Exception
                （2）提供全局常量：serialVersionUID
                （3）提供重载的构造器</code></pre>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/08/JavaLearing/" data-id="ckp27pss30001n8ub7uq2cq83" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-后端开发路线" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF/" class="article-date">
  <time class="dt-published" datetime="2021-03-01T09:14:16.000Z" itemprop="datePublished">2021-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF/">后端开发路线</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="后端开发路线"><a href="#后端开发路线" class="headerlink" title="#后端开发路线"></a>#后端开发路线</h2><p>##编程基础</p>
<hr>
<p>###Java语言</p>
<p>1.语言基础：</p>
<pre><code>基础语法    面向对象    接口    容器    异常    泛型    反射        注释        I/O</code></pre>
<p>2.JVM虚拟机：</p>
<pre><code>类加载机制
字节码执行机制
JVM内存模型
GC垃圾回收
JVM性能监控与故障定位
JVM调优</code></pre>
<p>3.多线程/并发：</p>
<pre><code>并发编程基的基础
线程池
锁
并发容器
源子类
JUC并发工具类</code></pre>
<hr>
<p>###数据结构和算法</p>
<hr>
<p>###计算机网络</p>
<pre><code>1.ARP协议
2.IP协议、ICMP协议
3.TCP、UDP协议
4.DNS/HTTP/HTTPS协议
5.session/Cookie</code></pre>
<hr>
<p>###SQL/数据库</p>
<pre><code>1.SQL语句的书写
2.SQL语句的优化
3.事务、隔离级别
4.索引</code></pre>
<hr>
<p>###操作系统</p>
<pre><code>1.进程、线程
2.并发、锁
3.内存管理和调度
4.I/O原理</code></pre>
<hr>
<p>###设计模式：<br>    单例    工厂    代理    策略    模板方法    观察者    适配器    责任链    建造者</p>
<hr>
<p>##应用框架</p>
<hr>
<p>###Spring家族框架</p>
<p>1.Sprng</p>
<pre><code>IoC AOP</code></pre>
<p>2.SPringMVC</p>
<p>3.Spring Boot</p>
<pre><code>自动适配、开箱即用
整合Web
整合数据库（事务问题）
整合权限：
    Shiro\Spring Security</code></pre>
<p>4.整合各种中间件</p>
<pre><code>Redius    MQ    RPC框架    NIO框架</code></pre>
<hr>
<p>###服务器软件<br>1.web服务器</p>
<pre><code>Nginx</code></pre>
<p>2.应用服务器</p>
<pre><code>Tomcat    Jetty    Undertow</code></pre>
<p>3.中间件</p>
<pre><code>缓存：
    Redis：
        5大基础数据类型    事务        管道        持久化    集群

消息队列：
    RocketMQ    RabbitMQ    Kafa

RPC框架：
    Dubbo    gRPC    Thrift    Spring-Cloud    Netty</code></pre>
<p>4.数据库框架</p>
<pre><code>ORM层框架：
    Mybatis    Hibermate    JPA

连接池：
    Druid    HikariCP    C3P0

分库分表：
    MyCAT    Sharding-JDBC    Shardin-Sphere</code></pre>
<p>5.搜索引擎</p>
<pre><code>ElasticSearch    Soir</code></pre>
<p>6.分布式/微服务</p>
<pre><code>服务发现/注册：
    Eureka    Consul    Zookeeper    Nacos

网关：
    Zuui    Gateway

服务调用
    Ribbon    Feign</code></pre>
<p>7.熔断/降级</p>
<pre><code>Hystrix</code></pre>
<p>8.配置中心</p>
<pre><code>Config    Apollp    Nacos</code></pre>
<p>9.认证/鉴权</p>
<pre><code>Spring-Security    OAuth2    SSO单点登录</code></pre>
<p>10.分布式事务</p>
<pre><code>JTA接口：
    Atomiikos组件

2PC/3PC
XA模式

TCC模式：
    tcc-transaction    ByteTCC    EasyTransaction    Seata

SAGA模式：
    ServiceComb    Seate

LCN模式：
    tx-lcn</code></pre>
<p>11.任务调度</p>
<pre><code>Quartz    Elastic-Job</code></pre>
<p>12.链路追踪和监控</p>
<pre><code>Zipkin    Sleuth    Skywalking</code></pre>
<p>13.日志分析和监控</p>
<pre><code>ELK：
    ElasticSearch    Logstash    Kibana</code></pre>
<p>###虚拟化/容器化</p>
<p>1.容器技术</p>
<pre><code>Docker</code></pre>
<p>2.容器编排技术</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/01/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E8%B7%AF%E7%BA%BF/" data-id="ckp27pss90005n8ub6aqwhbrd" data-title="后端开发路线" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络——网络层</a>
          </li>
        
          <li>
            <a href="/2021/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">计算机网络——数据链路层</a>
          </li>
        
          <li>
            <a href="/2021/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/">计算机网络——物理层</a>
          </li>
        
          <li>
            <a href="/2021/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机网络</a>
          </li>
        
          <li>
            <a href="/2021/05/11/java%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/">Java编程杂记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>