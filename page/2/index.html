<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-OS/操作系统—进程管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T08:18:57.033Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">操作系统——进程管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="#操作系统"></a>#操作系统</h2><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="##进程管理"></a>##进程管理</h2><p>###进程</p>
<pre><code>定义（体现的是动态性）：
    --进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
    --进程是程序的一次执行过程
    --进程是一个程序及其数据在处理及上顺序执行时所发生的活动
    --进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位
    --进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立

组成： 程序段、数据段、PCB(进程控制块，其是进程存在的唯一标志)三部分组成了进程实体(进程映像)，一般情况下，就把进程实体简称为进程；进程实体是静态的，进程是动态的 

 组织方式：
     （1）链接方式：
         --按照进程状态将PCB分为多个队列，操作系统持有指向个个队列的指针
     （2）索引方式：
         --根据进程状态的不同，建立几张索引表，操作系统持有指向各个索引表的指针

 特征：
     （1）动态性：进程最基本的特征
     （2）并发性
     （3）独立性：晋城市系统进行资源分配、调度的独立单位
     （4）异步性：各进程以不可预知的速度向前推进，可能导致运行结果的不确定性
     （5）结构性

 进程的状态
     （1）运行态(Running)：占有CPU，并在CPU上运行，单核处理机环境下，每一时刻最多只有一个进程处于运行态
     （2）就绪态(Ready)：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行；进程已经拥有了除处理及之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行
     （3）阻塞态(Waiting/Blocked，又称等待态)：因等待某一件事而暂时不能运行
     （4）创建态(New，新建态)：进程正在被创建，操作系统为进程分配资源、初始化PCB
     （5）终止态(Terminated，结束态)：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

 进程控制：
     （1）创建
     （2）终止
     （3）阻塞
     （4）唤醒
     （5）切换

 进程通信：
     说明：是指进程之间的信息交换
     （1）共享存储：
         --基于数据结构的共享：速度慢，限制多，是一种低级通信方式
         --基于存储区的共享：速度更快，是一种高级通信方式
         ps：两个进程对共享空间的访问必须是互斥的（互斥操作通过操作系统提供的工具实现）

     （2）消息传递
         说明：进程间的数据交换以格式化的消息为单位；进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换
         --直接通信方式：消息直接挂到接收进程的消息缓冲队列上
         --间接通信方式（信箱通信方式）：消息要先发送到中间实体(信箱)中

     （3）管道通信：
             --“管道”是指用于连接读写进程的一个共享文件(pipe文件)，其实就是在内存中开辟一个大小固定的缓冲区
             --管道只能采用半双工通信，某一时间段内只能实现单向的传输；如果需要实现双向同时通信，则需要设置两个管道
             --各进程要互斥的访问管道
             --数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待都进程将数据取走。当都进程将数据全部取走后，管道变空，此时读进程的read()系     统调用统调用统的调用将被阻塞
             --数据一旦被读出，就从管道中被抛弃，意味着读进程最多只能有一个，否则可能会有读错数据的情况</code></pre>
<hr>
<p>###线程</p>
<pre><code>定义：
    --线程是一个基本的CPU执行单元，也是程序执行流的最小单元
    --线程是程序执行流的最小单元
    --线程可以理解为“轻量级进进程”

与进程的区别：
    --进程是资源分配的基本单位，线程是调度的基本单位

属性：
    --线程是处理机调度的单位
    --多CPU计算机中，各个线程可以占用不同的CPU
    --每个线程都有一个线程ID、线程控制块(TCB)
    --线程几乎不拥有系统资源
    --统一进程的不同线程间共享进程的资源
    --由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
    --同一进程中的线程切换，不会引起进程切换
    --不同进程中的线程切换，会引起进程切换
    --切换同进程内的线程，系统开销很小；切换进程，系统开销较大

实现方式：

    --用户级线程：
        （1）说明：
            --由应用程序通过线程库实现，所有线程管理工作都有应用程序负责(包括线程切换)
            --用户级线程中，线程切换在用户态下即可完成，无需操作系统干预
            --用户级线程对用户不透明，对操作系统透明

    --内核级线程：
        （1）说明：
            --内核级线程的管理工作由操作系统内核完成
            --内核级线程的切换需要在核心态下才能完成
            --内核级线程对用户透明，对操作系统不透明
            --内核线程是处理机分配的单位

多线程模型：

    --多对一模型：多用户对单内核，每个用户进程只对应一个内核级线程
        advantage：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
        disadvantage：当一个用户线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上并行运行

    --一对一模型：单用户对单内核
        advantage：当一个线程阻塞后，别的线程还可以继续执行，并发能力强；多线程可在多核处理机上并发执行
        disadvantage：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大

    --多对多模型：n用户对m内核，每个用户进程对应m个内核级线程
        action：克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的特点</code></pre>
<hr>
<p>###处理机调度：</p>
<pre><code>说明：处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理及分配给它运行，以实现进程的并发执行
分层：
    （1）高级调度(作业调度)：主要是指调入的问题
        --按一定的原则从外存上处于后备队列的作业中挑选一个(或多个)作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB)，以使得其获得竞争处理机的权力
        --高级调度是辅存与内存之间的调度，作业调入时会建立相应的PCB，作业调出时才撤销PCB

    （2）中级调度(内存调度)：
        --将暂时不能运行的进程调至外存等待，等它重新具备了运行条件且内存稍有空闲时，再重新调入内存；提高内存利用率和系统吞吐量
        --暂时调到外存等待的进程状态为挂起状态，PCB并不会一起调到外存，而是会常驻内存，PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统同过内存中的P     CB来保持对各个进程的监控、管理；被挂起的进程PCB会被放到挂起队列中
            &lt;!-- 
                挂起状态：指的是暂时调到外存等待的进程状态，为减轻系统负载，提高资源利用率
                    分类：
                        --就绪挂起
                        --阻塞挂起 
                    注意:
                        --&quot;挂起&quot;和&quot;阻塞&quot;两种状态都是暂时不能获得CPU的服务,但挂起状态是将进程映像调到外存去了,而阻塞态下进程映像还在内存中
            --&gt;

    （3）低级调度(进程调度)：
        --说明：
            （1）其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它
            （2）进程调度是操作系统中最基本的一种调度

        --过程：
            （1）队员来运行进程的各种数据的保存
            （2）对新的进程各种数据的恢复

        --调度时机：
            （1）需要进行进程调度和切换：
                --当前运行进程主动放弃处理机：
                    a.进程正常终止
                    b.运行过程中发生异常而终止
                    c.进程主动请求阻塞(如 等待I/O)
                --当前运行的进程被动放弃处理机：
                    a.分配给进程的时间片用完
                    b.有更紧急的事需要处理(如I/O中断)
                    c.有更高优先级的进程进入就绪队列
            （2）不能进行进程调度与切换
                --在处理中断过程中。
                --进程在操作系统内核程序临界区中
                    &lt;!--
                        临界资源：一个时间段内只允许一个进程使用的资源，各进程需要互斥地访问临界资源
                        临界区：访问临界资源的那段代码
                      --&gt;
                --在原子操作过程中

        --调度方式：
            （1）非剥夺调度方式(非抢占方式)：只允许进程主动放弃处理机
                特点：实现简单，系统开销小，但无法处理紧急任务；适合于早期的批处理系统
            （2）剥夺调度方式(抢占方式):允许进程被动放弃处理机
                特点：可以优先处理更紧急的进程，也可以实现让各进程按时间片轮流执行的功能(通过时钟中断)；适合于分时操作系统、实时操作系统

调度指标：
    （1）CPU利用率：指CPU“忙碌”的时间占总时间的比例
    （2）系统吞吐量：单位时间内完成作业的数量
    （3）周转时间：是指从作业被提交给系统开始，到作业完成为止的这段时间间隔
    （4）等待时间：指进程/作业处于等处理机状态事件之和
    （5）响应时间：只从用户提交请求到首次产生相应所用的时间

调度算法：
    （1）先来先服务(FCFS)
            --规则：按照作业/进程到达的先后顺序进行服务
            --使用：
                a.用于作业调度时，考虑的是哪个作业先到达后备队列
                b.用于进程调度时，考虑的是哪个进程先到达就绪队列
            --特性：
                a.非抢占式算法
                b.公平，算法实现简单
                c.对长作业有利，对短作业不利

    （2）短作业优先(SJF)
            --规则：最短的作业/进程优先得到服务（是指要求服务时间最短）
            --使用：既可用于作业调度，也可用于进程调度
            --特性：
                a.SJF和SPF(短进程优先算法)是非抢占式算法，而SRTM(最短剩余时间优先算法)是抢占式算法
                b.“最短的”平均等待时间、平均周转时间
                c.不公平，作业/进程的运行时间是由用户提供的，并不一定真是，不一定能做到真正的短作业优先
                d.会导致饥饿现象，如果一直得不到服务，则称为“饿死 ”

    （3）高响应比优先(HRRN)
            --规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务
                &lt;!--
                    响应比 = (等待时间+要求服务时间)/要求服务时间 
                 --&gt;
            --使用：既可以用于作业调度,也可以用于进程调度 
            --特性：
                a.非抢占式算法
                b.综合考虑了等待时间和运行时间(要求服务时间);等待时间相同时,要求服务时间短的优先;要求服务时间相同时,等待时间长的优先 

    （4）时间片轮转算法(RR)
            --规则：按照各进程到达就绪队列的顺序，轮转让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队；如果两个进程在同一时刻到达，则默认新到达的进程先进就绪队列
            --使用：用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)
            --特性：
                a.抢占式算法；由时钟装置发出时钟中断来通知CPU时间片已到
                b.公平且响应快，适用于分时操作系统
                c.由于高频率的进程切换，因此有一定开销，不区分任务的紧急程度

    （5）优先级调度算法
            --规则：没个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程
            --使用：既可以用于作业调度，也可以用于进程调度
            --特性:
                a.具有抢占式和非抢占式
                b.用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各个作业/进程的偏好程度
                c.若源源不断地有高优先级进程到来，则可能导致饥饿

    （6）多级反馈队列调度算法
            --规则：
                a.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
                b.新进程到达时先进入第一级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级地队列，则重新放回该队列队尾
                c.只有第k级队列为空时，才会为k+1级队头地进程分配时间
                d.对各类进程相对公平(FSFC优点)；每个新到达地进程都可以很快得到响应(RR优点)；短进程都只用较少的时间就可完成(SPF优点)；不必实现估计进程的运行时间(避免用户作假)；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程(拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O进程就可以保持较高优先级)
                e.可能会产生饥饿现象</code></pre>
<hr>
<p>###进程同步和互斥</p>
<pre><code>进程同步：
    （1）说明：要让各并发进程按要求有序地推进
进程互斥：
    （1）说明：指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待，当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源
    （2）过程：
        --进入区：负责检查是否可以进入临界区，若可以，则应设置正在访问临界资源的标志，以阻止其他进程同时进入临界区
        --临界区：访问临界资源的代码
        --退出区：负责解除正在访问临界资源的标志
        --剩余区：做其他处理
        注意：
            进入去和退出区是负责实现互斥的代码段

    （3）原则：
        --空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
        --忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待
        --有限等待：对请求访问的进程，应保证能在有限的时间内进入临界区(保证不会饥饿)
        --让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待

    （4）软件实现方法：
        --单标志法：
            a.思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程进入临界区的权限只能被另一个进程赋予
        --双标志先检查法：
            a.思想：色织一个布尔型数组flag[]，数组中各个元素用来标记个进程想进入临界区的医院。每个进程在进入临界区之前先检查当前有没有别的想进入临界区，若没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区
            b.缺点：违反“忙则等待”原则
        --双标志后检查法：
            a.思想：先上锁后检查
            b.缺点：违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象
        --Peterson算法：
            a.思想：如果双方都争着进入临界区，则主动让对方先使用临界区
            b.缺点：未遵循让权等待

    （5）硬件实现方法：
        --中断屏蔽方法：
            a.思想：利用“开/关中断指令”实现（与原语的实现思想相同）
            b.过程：
                --关中断：关中断后即不允许当前进程被中断，也必然不会发生进程切换
                --临界区
                --开中断：直到而当前进程访问完临界区，在执行开中断指令，才有可能有别的进程上处理机并访问临界区
            c.优缺点：
                --简单、高效
                --不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)

        --TestAndSet指令(TestAndSetLock指令/TS指令)：
            a.思想：TSL指令是用硬件实现的，执行的过程不允许被中断
            b.优缺点：
                --实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
                --不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”

        --Swap指令(Exchange指令/XCHG指令)：
            a.思想：Swap指令是用硬件实现的，执行的过程不允许被中断
            b.优缺点：
                --实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
                --不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”</code></pre>
<hr>
<p>###信号量机制</p>
<pre><code>说明：进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步
    &lt;!-- 信号量：用来表示系统中某种资源的数量 --&gt;

使用：通过wait(S)和signal(S)原语，也就是PV操作，实现系统资源的“申请”和“释放”

分类：
    --整型信号量：用来表示系统中某种资源的数量 
        使用：通过该信号量表示系统中的资源，当所需资源大于0，则获取资源，当资源小于等于0，则循环等待
        缺点：存在“忙等”问题
    --记录型信号量：用记录型数据结构表示的信号量
        使用：在记录型数据结构当中有着等待队列，每次进行P操作时，对所需资源数-1，若所需资源数小于0，则将其阻塞，加入到等待队列当中（运行态-&gt;阻塞态）；在执行释放操作时，对所需资源数加1，若当前所需资源数仍然小于等于0，说明当前等待队列中还有阻塞进程，则分配资源给该进程（阻塞态-&gt;就绪态）

注意：实现互斥的P操作一定要在实现同步的P操作之后</code></pre>
<hr>
<p>###管程</p>
<pre><code>说明：是一种特殊的软件模块
组成：
    （1）局部于管程的共享数据结构说明
    （2）对该数据结构进行操作的一组过程
    （3）对局部于管程的共享数据设置初始值的语句
    （4）管程有一个名字

基本特征：
    （1）局部于管程的数据只能被局部于管程的过程访问
    （2）一个进程只有通过调用管程内的过程才能进入管程访问共享数据
    （3）每次仅允许一个进程在管程内执行某个内部过程（这种互斥特性是由编译器负责是实现的）
    （4）可在管程中设置条件变量及等待/唤醒操作以解决同步问题，可以让一个进程或线程在条件变量上等待(此时，该进程应先释放管程的使用权)，可以通过唤醒操作将等待在条件变量上的线程或进程唤醒</code></pre>
<hr>
<p>###死锁</p>
<pre><code>说明：在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象

条件：
    （1）互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁
    （2）不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放
    （3）请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放
    （4）循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程所获得的资源同时被下一个进程所请求
    注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁

处理：
    （1）预防死锁：破坏死锁产生的四个必要条件中的一个或几个
            --破坏互斥条件：将互斥使用的资源改造为允许共享使用，如SPOOLing技术将打印机改为共享设备
                缺点：并不是所有的资源都可以改造成可共享使用的资源

            --破坏不剥夺条件：
                缺点：
                    a.实现起来比较复杂
                    b.释放获得的资源可能造成前一阶段工作的失效，因此这种方法一般只适用于易保存和恢复状态的资源，如CPU
                    c.反复地申请和释放资源会增加系统开销，降低吞吐量
                    d.可能会导致饥饿现象

            --破坏请求和保持条件：采用静态分配方法；即进程在运行前一次申请完它所需要地全部资源，在它地资源未满足前，不让其投入运行，一旦投入运行后，指定资源就一直归其使用，该进程就不会在请求别的任何资源
                缺点：
                    a.可能会造成严重的资源浪费，资源利用率极低
                    b.可能导致某些进程饥饿

            --破坏循环等待条件：可采用顺序资源分配法；给系统中的资源编号，规定每个进程必须按编号递增地顺序请求资源，同类资源一次申请完
                缺点：
                    a.不方便增加新的设备，因为可能需要重新分配所有编号
                    b.进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费
                    c.必须按规定次序申请资源，用户编程麻烦

    （2）避免死锁：如银行家算法
            &lt;!-- 安全状态:指如果系统按照这种序列分配资源,则每个进程都能顺利完成;只要找出一个安全序列,系统就是安全状态;如果系统处于安全状态,就一定不会发生死锁;如果处于不安全状态,就可能发生死锁 --&gt;
            银行家算法:
                a.思想:在进程提出资源申请时,先预判此次分配是否会导致系统进入不安全状态,如果会进入不安全状态,就暂时不答应这次的请求,让该进程先阻塞等待
                b.步骤:
                    1-检查此次申请是否超过了之前声明地最大需求数
                    2-检查此时系统剩余地可用资源是否还能满足这次请求
                    3-试探着分配,更改各数据结构
                    4-用安全性算法检查此次分配是否会导致系统进入不安全状态
                    &lt;!-- 安全性算法:检查当前地剩余可用资源是否能满足某个进程的最大需求,如果可以,就把该进程加入安全序列,并把该进程持有的资源全部回收,不断重复 --&gt;

    （3）死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁
            --死锁的检测:
                a.条件:
                    1-用某种数据结构来保存资源的请求和分配的信息
                    2-提供一种算法,利用上述信息来检测系统是否已进入死锁状态
                b.资源分配图:
                    1-结点:进程结点\资源结点
                    2-边:
                        --请求边:进程结点--&gt;资源结点
                        --分配边:资源结点--&gt;进程结点
                c.死锁检测算法:
                    1-方法:依次消除与不阻塞进程相连的边,直到无边可消
                        &lt;!-- 
                            所谓不阻塞进程是指申请的资源数还足够的进程 
                            --&gt;
                    2-结果:用死锁检测算法花间资源分配图后,还连着那些进程就是死锁进程

            --死锁的解除:
                a.资源剥夺法:挂起(暂时放到外存上)某些死锁进程,并抢占它的资源,将这些资源分配给其他的死锁进程,但是应防止被挂起的进程长时间得不到资源而饥饿
                b.撤销进程法(终止进程法):强制撤销部分\甚至全部死锁进程,并剥夺这些进程的资源
                    优缺点:实现简单,但是付出的代价可能会很大
                c.进程回退法:让一个或多个死锁进程回退到足迹避免死锁的底部,这就要求系统要记录进程的历史信息,设置还原点</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" data-id="ckp6d4twx000im0ubhkszavq1" data-title="操作系统——进程管理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-OS/操作系统—内存管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T08:17:30.054Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/07/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">操作系统——内存管理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="#操作系统"></a>#操作系统</h2><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="##内存管理"></a>##内存管理</h2><p>###内存基础知识</p>
<pre><code>说明:是用于存放数据的硬件(程序执行前需要先放到内存中才能被CPU处理)

链接方式：由目标模块生成装入模块，链接后形成完整的逻辑地址

    （1）静态链接：在程序运行之前先将各模块及它们所需的库函数连接成一个完整的可执行文件(装入模块)，之后不再拆开
    （2）装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式
    （3）运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。
            优点：便于修改和更新，便于实现对目标模块的共享

装入方式:将装入模块装入内存，装入后形成物理地址

    （1）绝对装入:
            --实现：编译时产生绝对地址
                    &lt;!-- 只适用于单道程序环境 --&gt;

    （2）静态重定位(可重定位装入)：
        --实现：装入时将逻辑地址转换为物理地址
                &lt;!-- 要求：作业在装入内存时，必须分配其要求的全部内存空间，若空间不足，则不能装入改作业；同时一旦进入内存后，在运行期间就不能在移动，也不能再申请内存空间 --&gt;

    （3）动态重定位(动态运行时装入)：
        --实现：运行时将逻辑地址转换为物理地址，需设置重定位寄存器
                    &lt;!-- 重定位寄存器:存放装入模块存放的起始地址 --&gt;
        --优点：
            a.可以将程序分配到不连续的存储区中
            b.程序运行前只需要装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存
            c.便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</code></pre>
<hr>
<p>###内存管理</p>
<pre><code>管理者：操作系统

功能：
    （1）内存空间的分配与回收

            --连续分配管理方式：
                a.说明：指为用户进程分配的必须是一个连续的内存空间
                b.分类：
                        &lt;!-- 
                            内部碎片:分配给某进程的内存区域中,有部分没有使用
                            外部碎片:是指内存中的某些分区由于太小而难以利用
                         --&gt;
                    1-单一连续分配
                        --分区方式：
                            1.系统区：通常位于低地址部分，用于存放操作系统相关数据
                            2.用户区：用于存放用户进程相关数据，内存中只能有一道用户程序，用户程序独占整个用户区空间
                        --优点：
                            1.实现简单
                            2.无外部碎片；
                            3.可以用覆盖技术扩充内存
                            4.不一定需要采取内存保护
                        --缺点：
                            1.只能用于单用户、单任务的操作系统中
                            2.有内部碎片
                            3.存储器利用率低

                    2-固定分区分配
                        --分区方式：将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业
                            &lt;!-- 
                                对于分区大小相同：适合用于用一台计算机控制多个相同对象的场合,但是缺乏灵活性
                                对于分区大小不相等：增加了灵活性，可以满足不同大小的进程需求
                            --&gt;
                        --优点:实现简单,无外部碎片
                        --缺点:
                            1.当用户程序太大时,可能所有分区都不能满足需求,此时不得不采用覆盖技术来解决,但这又会降低性能
                            2.会产生内部碎片,利用率低
                        --注意：操作系统需要建立分区说明表，来实现各个分区的分配与回收

                    3-动态分区分配(可变分区分配)
                        --分区方式:在进程装入内存时,根据进程大小动态地建立分区
                        --记录内存的数据结构:
                            1.空闲分区表
                            2.空闲分区链
                        --优点:没有内部碎片
                        --缺点:存在外部碎片,可以使用紧凑技术来解决

                        --动态分区分配算法:
                            1.首次适应算法:从低地址开始查找,找到第一个满足大小的空闲分区
                            2.最佳适应算法:优先使用更小的空闲区,空闲分区按容量递增次序链接,每次分配内存时顺序查找空闲分区链/表
                                &lt;!-- 会产生很多的外部碎片 --&gt;
                            3.最坏适应算法:优先使用更大的空闲区,空闲区按容量递减次序链接,顺序查找
                                &lt;!-- 会导致较大的连续空闲区被迅速用完,导致之后&quot;大进程&quot;到达,没有内存分区可以使用 --&gt;
                            4.邻近适应算法:空闲分区以地址递增的顺序排列,每次分配内存从上次查找结束的位置开始查找

            --非连续分配管理方式
                a.分类：
                    1-分页存储管理：
                        --分区方式：操作系统以页框为单位为各个进程分配内存空间，进程的每个页面分别放入一个页框中，进程的页面与内存的页框有一一对应的关系；各个页面不必连续存放，也不必按先后顺序来
                            &lt;!-- 
                                页框（页帧/内存块/物理块）：内存空间所被分为一个个等大的分区，从0开始；页框不能太大，否则可能产生过大的内部碎片
                                页（页面）：用户进程的地址空间所被分为一个个与页框等大的区域，从0开始
                                页表：记录进程页面和实际存放内存块之间的对应关系，一个进程对应一张页表，进程的每一页对应一个页表项，每个页表项由“页号”和“块号”组成，每个页表项的长度是相同的，页号是“隐含”的
                             --&gt;
                        --逻辑地址结构（以32位为例）：
                            a.0~11位存放的是页内偏移量
                            b.12~31位存放的是页号

                        --基地址变换机构：可以借助进程的页表将逻辑地址转换为物理地址
                            &lt;!-- 快表的结构有效的增加了查询的速度  --&gt;

                    2-分段存储管理：
                        --分区方式：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名，每段从0开始编制；内存分配是以段为单位分配，每个段在内存中占据连续空间，但各段之间可以不相邻
                        --段表：
                            a.每个段对应一个段表项，其中记录了该段在内存中的起始位置和段的长度
                            b.各个段表的长度是相同的
                            c.段号是可以隐含的，不占存储空间

                    3-段页式管理方式：
                        --分区方式：分段+分页
                        --逻辑地质结构：段号、页号、页内偏移量
                        --段表：每个段对应一个段表项，各段表项长度相同，由段号(隐含)、页表长度、页表存放地址组成
                        --页表：每个页对应一个页表项，各个页表项长度相同，由页号(隐含)、页面存放的内存块号组成

                b.注意：
                    --分页对用户不可见，分段对用户可见
                    --分页的地址空间是一维的，分段是二维的
                    --分段更容易实现信息的共享和保护（纯代码/可重入代码可以共享）
                    --分页(单级页表)、分段访问一个逻辑地址都需要两侧访问，分段存储中也可以引入快表机构




    （2）对内存空间进行扩充

            --覆盖技术：
                a.实现：通过对内存设置固定区和覆盖区，对不能被同时访问的程序段共享同一个覆盖区
                &lt;!-- 缺点：对用户不透明，且需要由程序员声明覆盖结构，增加了用户编程的负担 --&gt;

            --交换技术
                a.实现：将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存
                &lt;!-- 
                    文件区：主要用于存放文件，主要追求存储空间的利用率，因此文件区空间的管理采用离散分配方式
                    对换区：其空间占磁盘空间的小部分，被换出的进程数据就存放在对换区，对换区采用连续分配方式(主要是为了追求换入换出速度)
                     --&gt;
                b.交换条件：通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停
                c.注意：PCB会常驻内存，不会换出外存

            --虚拟存储技术
                a.实现：虚拟内存的实现要建立在离散分配的内存管理方式基础上
                    --请求调页(或请求调段)
                    --页面置换(或段置换)
                        1-最佳置换算法(OPT)
                            说明：每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，可以保证最低的缺页率
                        2-先进先出置换算法(FIFO)
                            说明：每次选择淘汰的页面是最早进入内存的页面
                            特点：实现简单，但算法性能差，会产生Belady异常
                                &lt;!-- Belady异常：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象 --&gt;
                        3-最近最久未使用置换算法(LRU)
                            说明：每次淘汰的页面是最近最久未使用的页面
                            实现：赋予每个页面对应的页表项中，用访问字段记录该页面上次被访问以来所经历的时间t
                            特点：性能好，但是实现困难，开销大
                        4-时钟置换算法(CLOCK)：
                            实现：为每个页面设置一个访问位，再将内存中的也买你都通过链表指针连接成一个循环队列，当被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将其置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问未依次置为0后，再进行第二轮扫描

                        5-改进型的时钟置换算法
                            说明：在原来的时间置换算法的基础上，优先淘汰没有修改过的页面，避免I/O操作
                            实现：增加一个修改位，0表示没有被修改，反之，被修改过
                            特点：实现简单，算法开销小，性能也不错，但未考虑是否被修改过

                    --页面分配、置换策略
                        1-驻留集：指请求分页存储管理中给进程分配的物理块的集合

                    --操作：
                        1-页表机制：在基本分页的基础上增加了状态位、访问字段、修改位、外村地址
                        2-缺页中断机制：找到页表项后检查页面是否已在内存，若没在则会产生缺页中断
                            说明：
                                --将目标页面调入内存，有必要时还要换出页面
                                --缺页中断属于内中断，属于内中断中的“故障”，即可能被系统修复的异常
                                --一条指令在执行过程中可能产生多次缺页中断

    （3）实现地址转换（三种装入方式）
    （4）内存保护
            --方法：
                a.在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程指令要访问某个地址，CPU检查是否越界
                b.采用重定位寄存器(基地址寄存器)和界地址寄存器(限长寄存器)进行越界检查。重定位寄存器其中存放的是进程的起始物理地址。界地址寄存器存放的是进程的最大逻辑地址</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" data-id="ckp6d4tw00004m0ubd1j3frje" data-title="操作系统——内存管理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-OS/操作系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/29/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2021-04-29T11:31:00.942Z" itemprop="datePublished">2021-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/29/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="#操作系统"></a>#操作系统</h2><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="##基础知识"></a>##基础知识</h2><p>###操作系统</p>
<pre><code>定义：
    是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，是计算机系统中最基本的系统软件

功能：
    --作为系统资源的管理者：
        （1）处理机管理
        （2）存储器管理
        （3）文件管理
        （4）设备管理

    --作为永和和计算机硬件之间的接口：
        （1）命令接口：允许用户直接使用
            --联机命令接口
            --脱机命令接口
        （2）程序接口：允许用户通过程序间接使用，由一组系统调用组成，即系统调用=程序接口
        （3）GUI(图形用户界面)

特征：
    --并发：
        定义：指两个或多个事件在同一时间间隔内发生；这些事件在宏观上是同时发生的，但微观上是交替发生的；并发性是指计算机系统中同时存在着多个运行着的程序
        区别：并行是指两个或多个事件在同一时刻同时发生

    --共享：
        定义：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用；共享性是指系统中的资源可供内存中多个并发执行的进程共同使用 
        方式：
            （1）互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段内只允许一个进程访问该资源
            （2）同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对其进行访问

    --虚拟：
        定义：是指把一个物理上的实体变为若干个逻辑上的对应物；物理实体是实际存在的，而逻辑上对应物使用户感受到的

    --异步：
        定义：是指在多道程序环境下，郧西多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进

发展：
    --手工操作阶段
    --多道批处理系统：
        多道程序并发执行，共享计算机资源。资源利用率大幅提升，cpu和其他资源保持“忙碌”状态，系统吞吐量增大，但是用户响应时间长，没有人机交互功能
    --分时操作系统：
        计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互，用户请求可被即时相应，解决了人机交互问题，但不能优先处理一些紧急任务
    --实时操作系统：
        能够优先响应一些紧急任务，某些紧急任务不需要时间片排队；在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件，其主要特点是及时性和可靠性
        注意：
            --硬实时系统：必须在绝对严格的规定时间内完成
            --软实时系统：能接受偶尔违反时间规定

运行机制和体系结构

    --两种处理器状态---&gt;用PSW(程序状态寄存器)中的某标志位来标识房前处理器状态0为用户，1为核心：
        （1）用户态(目态)：此时CPU只能执行非特权指令
        （2）核心态(管态)：特权指令、非特权指令都可执行

    --两种程序：
        （1）内核程序：是系统的管理者，可以执行所有指令，运行在核心态中
        （2）应用程序：只能执行非特权指令，运行在用户态

    --内核：
        说明：是计算机上配置的底层软件，是操作系统最基本、最核心的部分
        分类：
            --大内核：
                说明：将操作系统的主要功能模块都作为系统内核，运行在核心态
                特点：高性能；内核代码庞大，结构混乱，难以维护
            微内核：
                说明：只把最基本的功能保留在内核
                特点：内核功能少，结构清晰，方便维护；需要频繁的在核心态和用户态之间切换，性能底

        功能：
            （1）时钟管理：实现计时功能
            （2）中断处理：负责实现中断机制
            （3）原语：是一种特殊的程序，处于操作系统最底层，是最接近硬件的部分；这种程序的运行具有原子性(运行不可中断)；运行时间较短、调用频繁
            （4）对系统资源尽心管理的功能
                --进程管理
                --存储器管理
                --设备管理

中断和异常（是为了实现多道程序并发执行而引入的一种技术）：
    说明：
        --中断发生时，CPU立即进入核心态
        --中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理
        --对不同的中断信号，会进行不同的处理

    分类（分类的标准--&gt;根据信号的来源：内中断是来自于CPU内部，与当前执行的指令有关，外中断是来自于CPU外部，与当前执行的指令无关）：
        --内中断(异常/例外、陷入)：
            （1）自愿中断：指令中断
            （2）强迫中断：硬件故障、软件中断

        --外中断(中断，狭义的中断)：
            （1）外设请求
            （2）人工干预

    注意：用户态-&gt;核心态 是通过中断实现的，并且中断是唯一途径；而 核心态-&gt;用户态 的切换是通过执行一个特权指令，将程序状态字(PSW)的标志位设置为&quot;用户态&quot;

系统调用：

    说明：系统调用相关处理设计到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下进行
    作用：可以保证系统的稳定性和安全性，防止用户进行非法操作

    分类
        --按功能：
            （1）设备管理
            （2）文件管理
            （3）进程管理
            （4）进程通信
            （5）内存管理

    过程：
        （1）传递系统调用参数
        （2）执行陷入指令(用户态)
        （3）执行系统调用相应服务程序(核心态)
        （4）返回用户程序
        注意：
            --陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内终端，从而CPU进入核心态
            --发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行
            --陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/29/OS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="ckp6d4tw60007m0ubg0kbfi0u" data-title="操作系统" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java/Java8新特性" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/28/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" class="article-date">
  <time class="dt-published" datetime="2021-04-28T13:02:09.853Z" itemprop="datePublished">2021-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/28/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/">Java8新特性</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>#java8</p>
<pre><code>优点：
    --速度更快
    --代码更少(增加了新的语法：Lambda表达式)
    --强大的Stream API
    --便于并行
    --最大化减少空指针异常：Optional
    --Nashorn引擎，允许在JVM上运行JS应用</code></pre>
<hr>
<p>##Lambda表达式</p>
<pre><code>说明：是一个匿名函数，可以将其理解为一段可以传递的代码，使用它可以写出更简洁、更灵活的代码
本质：作为函数式接口的一个实例
    函数式接口：
        说明：只包含一个抽象方法的接口

        使用：
            --可以在接口上使用@Funtionallnterface注解，检查其是否是一个函数式接口，同时javadoc也会包含一条声明，说明这个接口是一个函数式接口

        常用的四大核心函数式接口：
            --Consumer&lt;T&gt;消费型接口：
                void accept(T t)
            --Suppelier&lt;T&gt;供给型接口：
                T get()
            --Function&lt;T,R&gt;函数型接口：
                R apply(T t)
            --Predicate&lt;T&gt;断定型接口：
                boolean test(T t)


格式：
    -&gt; ：Lambda操作符或箭头操作符
    -&gt; 左边：Lambda形参列表(其实就是接口中的抽象方法的形参列表)
    -&gt; 右边：Lambda体(其实就是重写的抽象方法的方法体)

    使用：
        接口名 r1 = (形参列表) -&gt; &#123;
            执行语句
        &#125;；
    注意:
        --Lambda形参列表等等参数类型可以省略(类型推断);如果Lambda形参列表只有一个参数，其括号可以省略
        --Lambda体应使用一对&#123;&#125;包裹；如果Lambda体只有一条执行语句(可能是return语句)，省略这一对&#123;&#125;和return关键字

方法引用
    说明：通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖
    要求：
        实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致
    格式：
        使用操作符“::”将类(或对象)与方法名分隔开来
    使用情景：
        当要传递给Lambda体的操作，已经有实现的方法
    具体情况：
        --对象::非静态方法
        --类::静态方法
        --类::非静态方法

构造器引用：
    要求：和方法引用类似，函数式接口的抽象方法的形参列表的构造器的形参列表一致；抽象方法的返回值类型即为构造器所属的类的类型</code></pre>
<p>##Stream API</p>
<pre><code>执行步骤：
    --Stream实例化：
        （1）通过集合：
            --default Stream&lt;E&gt; stream()：返回一个顺序流
            --default Stream&lt;E&gt; parallelStream()：返回一个并行流
        （2）通过数组：
            --调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)：返回一个流
        （3）通过Stream的of()
        （4）创建无限流：可以使用静态方法Stream.iterate()和Stream.generate()创建无限流
            --迭代：public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed,final UnaryOperator&lt;T&gt; f)
            --生成：public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)

    --中间操作
        （1）筛选与切片
            --filter(Predicate p)：接收Lambda，从流中排除某些元素
            --Limit(n)：截断流，使其元素不超过给给定数量
            --skip(n)：跳过元素，返回一个扔掉了前n个元素的流。若流中的元素不足n个，则返回一个空流
            --distinct()：筛选，通过流所生成元素的hashCode()和equals()去除重复的元素
        （2）映射
            --map(Function f)：接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素
            --flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个
        （3）排序：对于自定义类一定要进行对于Comparable接口的实现或定制排序
            --sorted()：产生一个新流，其中按自然顺序排序
            --sorted(Comparator com)：产生一个新流，其中按比较器顺序排序

    --终止操作
        （1）匹配与查找
            --allMatch(Predicate p)：检查是否匹配所有元素
            --anyMatch(Predicate p)：检查是否至少匹配一个元素
            --noneMatch(Predicate p)：检查是否没有匹配的元素
            --findFirst()：返回第一个元素
            --findAny()：返回当前流中的任意元素
            --cout()：返回流中元素的总个数
            --max/min(Comparator c)：返回流中最大值/最小值
            --foreach(Consumer c)：内部迭代（使用Collection接口需要用户去做迭代称为外部迭代）

        （2）归约
            --reduce(T identify,BinaryOperator)：可以将流中元素反复结合起来，得到一个值，返回T类型数据
            --reduce(BinaryOperator)：可以将流中元素反复结合起来，得到一个值，返回Optional&lt;T&gt;类型数据

        （3）收集
            --collect(Collector c)：将流转换为其他形式；接受一个Collector接口的实现，用于给Stream中元素做汇总的方法
                注意：Collector接口中方法实现决定了如何对流执行收集的操作；另外，Collectors实用类提供了很多的静态方法，可以方便的创建常见收集器实例

注意：
    --Stream是对数据的运算，与CPU相关；集合关注的是数据的存储，与内存相关
    --Stream自己不会存储元素
    --Stream不会改变源对象，但是会返回一个持有结果的新Stream
    --Stream操作是延迟执行，意味着其会等到需要结果的时候才执行</code></pre>
<p>##Optional类</p>
<pre><code>说明：Optional&lt;T&gt;类(java.util.Optional)是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在

常用方法：
    --创建Optional类对象的方法：
        Optional.of(T t)：创建一个Optional实例，t必须非空
        Optional.empty()：创建一个空的Optional对象
        Optional.ofNullable(T t)：t可以为null

    --判断Optional容器中是否包含对象：
        boolean isPresent()：判断是否包含对象
        void ifPresent(Conmuser&lt;?super T&gt; consumer)：如果有值，就执行Consumer接口的实现代码，并且该值会作为参数传给它

    --获取Optional容器的对象：
        T get()：如果调用对象保函值，返回该值，否则抛异常
        T orElse(T other)：如果有值则将其返回，否则返回指定的other对象
        T orElseGet(Supplier&lt;? extends T&gt; other)：如果有值则将其返回，否则返回由Supplier接口实现提供的对象
        T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)：如果有值则将其返回，否则抛出由Supplier接口实现提供的异常</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/28/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" data-id="ckp6d4tw70008m0ubgqvdc3dl" data-title="Java8新特性" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java/java简单类库的使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/Java/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T06:27:24.916Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/06/Java/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/">Java类库与基本操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简单的类库使用"><a href="#简单的类库使用" class="headerlink" title="#简单的类库使用"></a>#简单的类库使用</h2><p>###数字</p>
<pre><code>Math.random():令系统随机选取大于等于0.0且小于1.0的伪随机double值
    Math.random()*(n-m)+m：返回指定范围的随机数（m-n之间）的公式</code></pre>
<hr>
<p>###字符</p>
<pre><code>string.equals():判断二者是否相同 </code></pre>
<hr>
<p>###Arrys工具类</p>
<pre><code>Ops:java.util.Arrays
Using:
    sort():快速排序
    binary():二分查找
    equals():判断两个数组是否相同
    fill(int[] a,int val):将指定值填充到数组之中</code></pre>
<hr>
<p>###JavaBean:是一种Java语言写成的可重用组件（也是一个Java类）</p>
<pre><code>特征：
    （1）类是公共的
    （2）有一个无参的公共的构造器
    （3）有属性，且对应的get、set方法
功能：
    可以将功能、处理、值、数据库访问和其他任何可以用Java代码创造对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。</code></pre>
<hr>
<p>###UML类图</p>
<pre><code>结构：
    类名
    属性（属性名：属性类型）
    方法（方法的类型 方法名(参数名：参数类型)：返回值类型）注：若方法有下划线表示为构造器
    ‘+’表示public,‘-’表示private，‘#’表示proctected</code></pre>
<hr>
<p>###Object类（是所有java类的根父类，如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类） </p>
<pre><code>（1）equals()： 比较二者是否相同

    使用：
        （1）是一个方法，并不是运算符
        （2）只能适用于引用数据类型
        （3）Object类中定义的equals()和==的作用是相同的，比较两个对象的地址值是否相同
        （4）在String、Data、File、包装类等都重写了Object类中的equals()方法，重写后，比较的是两个对象的实体内容

    与“==”的却别：
        ==：
            （1）可以使用在基本数据类型 变量和引用数据类型变量中
            （2）如果比较的是基本数据类型变量，比较二者保存的数据是否相同（不一定要类型相同）
                如果比较的是引用数据类型变量，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体

（2）toString()：

    使用：
        a.当输出一个对象的引用时，实际上就是调用当前对象的toString()方法
        b.String、Date、File、包装类等都重写了Object类中的toString()方法</code></pre>
<hr>
<p>###包装类(Wrapper)的使用</p>
<pre><code>功能：java提供了8种数据类型对应的包装类，使得基本数据类型的变量具有类的特征
使用：
    （1）基本数据类型、包装类、String三者之间的相互转换
        基本数据类型-----&gt;包装类：调用包装类的构造器
        包装类-----&gt;基本数据类型：调用包装类Xxx的xxxValue()
        基本数据类型、包装类----&gt;String类型：调用String重载的valueOf(Xxx xxx)
        String类型-------&gt;基本数据类型、包装类：调用包装类的parseXxx(String s)
    注意：
        自动装箱：可以直接将基本数据类型赋给包装类，可以提高效率（只可以赋值到-128到127，当大于这个数则会通过d调用构造器来创建对象）
        自动拆箱：直接将包装类赋给基本数据类型</code></pre>
<hr>
<p>###Vector类的使用</p>
<pre><code>功能：代替数组进行处理
使用：
    （1）addElement(Object ob)：给向量添加元素
    （2）elementAt(0)：取出向量中的元素，返回值是Object类型
    （3）size()：计算向量长度 </code></pre>
<hr>
<p>###JDK8日期时间API</p>
<pre><code>1.LocalDate\LocalTime\LocalDateTime
    实例化：
        now(Zoneid zone)：静态方法，根据当前时间创建对象/指定时区的对象
        of()：静态方法，根据指定日期/时间创建对象，不存在偏移量

    使用方法：    
        getDayOfMonth()/getDayOfYear()：获得月份太难书(1-31)/获得年份天数(1-366)
        getDayOfWeek()：获取星期几(返回一个DayOfWeek枚举值)
        getMonth()：获得月份，返回一个Month枚举值
        getMonthValue()/getYear()：获取月份(1-12)/获取年份
        getHour()/getMinute/getSecond()：获取当前对象对应的时分秒
        withDayOfMonth()/withDayOfYear()/withMonth()/withYear()：将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象

2.Instent类：时间线上的一个瞬时点
    实例化：
        now()：静态方法，返回默认UTC时区的Instant类的对象
        ofEpochMilli(long epochMilli)：静态方法，返回在1970-01-01 00：00：00基础上加上指定毫秒数之后的Instant类的对象

    使用：
        atOffset(ZoneOffset offset)：结合即时的偏移来创建一个OffsetDateTime
        toEpochMilli()：返回1970-01-01 00：00：00到当前时间的毫秒数，即为时间戳（ofEpochMilli：通过给定的毫秒数，获取Instant实例）

3.DateTimeFormatter类：该类提供了三种格式化方法
    使用：
        ofPattern(String pattern)：静态方法，返回一个指定字符串格式的DateTimeFormatter
        format(TemporalAccessor t)：格式化一个日期、时间，返回字符串
        parse(CharSequence text)：将指定格式的字符序列解析为一个日期、时间

4.Date类
    位置：java.util.Date
    使用：使用其空参构造器创建一个对应当前时间的Date对象，也可以给其构造器赋指定毫秒数
        a.toString()：显式当前的年月日时分秒
        b.getTime()：获取当前Date对象对应的时间戳

5.java.sql.Date
    说明：对应这数据库中的日期类型变量，该类时System类的子类
    实例化：java.sql.Date date = new java.sql.Date(毫秒数)

6.java.text.SimpleFormat类
    说明：是一个不与语言环境有关的方式来格式化和解析日期的具体类
    解析：文本--&gt;日期
    使用：
        a.格式化：日期----&gt;字符串
            String对象 = (SimpleFormat对象).format(Date对象)
        b.解析：格式化的逆过程，字符串----&gt;日期
            解析的String对象需要为&quot;年份-月份-日期 上下午 时:分&quot;
            通过指定格式实例化的方法，可以指定转换的日期格式：Date对象 = SimpleDateFormat对象.parse(&quot;指定格式时间的字符串&quot;)
                要求：字符串必须时符合SimpleDateFormat识别的格式(通过构造器参数体现，否则抛异常)

7.java.util.Calendar(日历)类
    说明：是一个抽象基类，主要用于完成日期字段之间相互操作的功能
    实例化：通过调用它的子类GregorianCalendar的构造器/使用Calendar.getInstance()方法
    常用方法：
        get()：获取常用的时间属性信息
        set()：将指定的时间属性设置成新的值
        add()：在原有的基础属性的值上添加
        getTime()：日历类-----&gt;Date
        setTime()：Date-----&gt;日历类
    注意：月份从0开始，星期从1(星期日)开始

8.其他的时间类
    ZoneId：该类中包含了所有的时区信息】
    ZonedDateTime：一个在ISO-8601日历系统时区的日期时间
    Clock：使用时区提供堆当前即时、日期和时间的访问的时钟
    Duration：用于计算两个&quot;时间&quot;间隔
    Period：用于计算两个&quot;日期&quot;间隔
    TemporalAdjuster：时间校正器。
    TemporalAdjusters：该类通过静态方法(firstDayOfXxx() / lastDayOfXxx() / nextXxx())提供了大量的常用TemporalAdjust的实现</code></pre>
<hr>
<p>###java比较器</p>
<pre><code>Comparable接口：自然排序
    包：java.lang.Comparable
    使用：
        1.像String、包装类等实现了Comparable接口，重写了compareTo()方法，给出了比较两个对象的大小，进行从小到大的排序
        2.重写compareTo()的规则
            当前对象&gt;形参对象，返回正整数，&lt;返回负整数，相等返回0
        3.对于自定义类，如果说需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法，在CompareTo(obj)方法中指明如何排序

Comparator接口：定制排序、
    包：java.lang.Comparator
    使用：可以使用匿名的方式，重写conpare方法</code></pre>
<p>###System类</p>
<pre><code>说明：代表系统，系统级的很多属性和控制方法都放置在该类的内部
包：java.lang
使用：
    1.该类的构造器为私有的，所以无法创建该类的对象
    2.内部成员变量和成员方法都为static
常用方法：
    currentTimeMillis()：返回当前的计算机时间
    exit(int status)：退出程序，0表示正常退出，非0表示异常退出，使用该方法可以在图形界面编程中实现程序的退出功能
    gc()：请求系统进行垃圾回收
    getProperty(String key)：获得系统中属性名为key的属性对应的值</code></pre>
<p>###Math类</p>
<pre><code>说明：提供了一系列静态方法用于科学计算，其方法的参数和返回值类型一般为double型
包：java.lang
常用方法：
    abs：绝对值
    sqrt：平方值
    pow(a,b)：a的b次幂
    log：自然对数
    exp：e为底指数
    random：返回0.0到1.0的随机数
    round：将double类型数据转换为long</code></pre>
<p>###BigInteger类</p>
<pre><code>说明：
    可以表示不可变的任意精度的整数，其提供所有Java的基本整数操作符的对应物，并提供java.lang.Math的所有相关方法，还提供：模运算、GCD计算、质数测试、素数生成、位操作以及一些其他操作
包:java.math    
使用：
    构造器：BigInteger(String val)，根据字符串构建BigInteger对象    </code></pre>
<p>###BigDecimal类<br>    说明：表示精度要求比较高的数字，该类支持不可变的、任意精度的有符号十进制定点数<br>    包：java.math<br>    使用：<br>        构造器：BigDecimal(double val/String val)<br>    常用方法：<br>        add：<br>        substract：</p>
<p>###字符串相关的类</p>
<pre><code>（1）string
        特征：
            a.不可被继承：String类是一个final类
            b.内部定义了final char[] value用于存储字符串数据
            c.字符串是支持序列化： String实现了Serializable接口
            d.String可以比较大小： 实现了Comparable接口
            e.不可变性： String代表不可变的字符序列
                体现：
                    1-当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值
                    2-当对现有的字符串进行链接操作时，也需要重新指定内存区域赋值
                    3-当调用replace()方法修改指定字符或字符串时，也需要重新制定内存区域赋值
            f.通过字面量直接赋值(区别于new)的方式给一个字符串复制，此时字符串值生命在方法区的字符串常量池中（字符串常量池中不会存储相同内容的字符串）
            g.通过new+构造器方式的方式直接进行实例化，其数据是存储在堆空间中开辟空间以后对应的地址值所指向的常量池
            h.常量与常量短的拼接结果在常量池，且常量池中不会存在相同内容的常量，只要其中一个是变量，结果就在堆中

        JVM中字符串常量池存放位置：
            jdk1.6（jdk 6.0 ,java 6.0）：字符串常量池存储在方法区(永久区)
            jdk1.7：字符串常量池存储在堆空间
            jdk1.8：字符串常量池存储在方法区(元空间)


        数据类型转换：
            a.String----&gt;基本数据类型、包装类之间的转换：
                调用包装类的静态方法：parseXxx(str)
            b.基本数据类型、包装类----&gt;String:
                调用String重载的valueOf(xxx)
            c.String----&gt;char[]之间的转换
                调用String的toCharArray()
            d.char[]----&gt;String：
                调用String的构造器
            e.Stirng---&gt;byte[](该过程称为编码)：
                调用String的getBytes()：该函数使用默认的字符集，进行转换
            f.byte[]----&gt;String（该过程称为解码）：
                调用String的构造器：使用默认的字符集进行解码

        常用方法：
            string inten()：要求该函 数返回值在常量池当中
            int length()：返回字符串长度
            char charAt(int index)：返回某索引的字符
            boolean isEmpty()：判断是否是空字符串
            String toLowerCase()：使用默认语言环境，将String中的所有字符为小写
            String toUpperCase()：使用默认语言环境，将String中的所有字符转换为大写
            String trim()：返回字符串的副本，忽略前导空白和尾部空白
            boolean equals(Object obj)：比较字符串内容是否相同
            boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写
            String concat(String str)：将指定字符串链接到字符串的结尾，等价于“+”
            int compareTo(String anotherString)：比较两个字符串的大小
            String subString(int beginIndex)：返回一个新的字符串，从beginIndex开始截取
            String substring(int beginIndex,int endIndex)：返回一个新字符串，它是此字符串从beginIndex截取到endIndex

            boolean endWith(String suffix)：测试此字符串是否以指定的后缀结束
            boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始
            boolean startsWith(String prefix,int toffset)：测试此字符串从指定索引开始的子字符串是否以指定字符串开始

            boolean contains(CharSequence s)：当且仅当此字符串包含指定的char值序列时，返回true
            int indexOf(String str)：返回指定字符串在此字符串中第一次出现处的索引
            int indexOf(String str,inr fromIndex)：返回指定字符串在此字符串中第一次出现处的索引，从指定的索引开始
            int lastIndexOf(String str)：返回指定字符串在此字符串中最右边出现处的索引
            int lastIndexOf(String str,int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向操作
                注：indexOf和lastIndexOf未找到，都返回-1
            替换：
                String replace(char oldChar,char newChar)：返回一个新的字符串，他是通过用newChar替换此字符串中出现的所有oldChar得到
                String replace(CharSequence target,CharSequence replacement)：使用指定的字面值替换序列替换此字符串所以匹配字面值目标序列的子字符串
                String replaceAll(String regex,String replacement)：使用给定的replacement替换此字符串所有匹配给顶的正则表达式的子字符串
                String replaceFirst(String regex,String replacement)：使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串
            匹配：
                boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式
            切片：
                String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串
                String[] split(String regex，int limut)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中 

（2）StringBuffer和StringBuilder
        与String的异同点
            a.String：不可变的字符序列，效率最低 
                内存解析:
                    底层使用char[]存储
            b.StringBuffer：可变的字符序列；线程安全的，效率低；
                内存解析：
                    底层使用char[]存储；调用构造器创建字符数组时，默认给数组扩容为16个字符，若给到指定长度，也在原数组上扩容16，但使用length()函数返回的长度不计算这16扩容，若要添加的数据底层数组盛不下，默认情况下，扩容为原来的2倍+2，同时将原有数组中的元素赋值到新的数组中，但这种操作会降低效率
            c.StringBuilder：可变的字符序列；jdk5.0新增，线程不安全的，效率高；
                内存解析：
                    底层使用char[]存储；同StringBuilder一致 

        常用方法：
            append()：提供了很多的append()方法，用于进行字符串拼接
            delete(int start,int end)：删除指定位置的内容
            replace(int start,int end,String str)：把[start,end)位置换位str
            insert(int offset,xxx)：在指定位置插入xxx
            reverse()：把当前字符序列逆转
            setCharAt(int n,char ch)：修改指定位置的字符
            注：
                append和insert时，如果原来的value数组长度不够，可扩容
                以上的方法支持方法链操作
                方法链原理</code></pre>
<hr>
<p>###集合Collections工具类</p>
<pre><code>说明：操作Map和Collection的工具类
常用方法：
    reverse(List)：反转List中元素的顺序
    shuffle(List)：对List集合元素进行随机排序
    sort(List)：根据元素的自然顺序对指定List集合元素按升序排序
    sort(List,Comparator)：根据Comparator产生的顺序对List集合元素进行排序
    Object max/min(Collection)：根据元素的自然顺序，返回给定集合的最大/最小元素
    Obeject max/min(Collection,Comparator)：根据Comparator指定的顺序，返回给定集合中最大/最小的元素
    int frequency(Collection,Object)：返回指定集合中指定元素的出现次数
    void copy(List dest,List src)：将src中的内容赋值到dest中
        注意：
            if( dest.size()&lt;src.size() )
                &lt;!-- 抛异常 --&gt;
            else
                复制成功
    boolean replace(List list,Object oldVal,Object newVal)：使用新值替换List对象

    注：在该类当中有多个synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</code></pre>
<hr>
<p>###日常使用</p>
<p>（1）Eclipse快捷键(可到preference当中的keys进行修改)</p>
<pre><code>（1）补全代码的声明：alt + /
（2）快速修复：ctrl + 1
（3）批量导包：ctrl + shift + o
（4）多行注释：ctrl + shift + /（取消使用 \ ）
（5）复制指定行的代码：ctrl + alt +down 或 ctrl + alt + up
（6）删除指定行的代码：ctrl + d
（7）上下移动代码：alt + up 或 alt + down
（8）切换到下一行代码空位：shift + enter（上一行则 + ctrl）
（9）查看源码：ctrl + 选中指定结构 或 ctrl + shift + t
（10）退回到前一个编辑页面：alt + left（下一个编辑界面则是alt + right）
（11）光标选中指定的类，查看继承树结构：ctrl + t
（12）撤销与反撤销：ctrl + z/y
（13）格式化代码：ctrl + shift +f
（14）在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o
（15）批量修改指定的变量名、方法名、类名等：alt + shift + r
（16）选中结构的大小写的切换：ctrl + shift + x/y
（17）调出生成getter/setter/构造器等结构：alt + shift + s
（18）显示当前选择资源（工程 或 文件）的属性：alt + enter
（19）快速查找.参照选中的word快速定位到下一个：ctrl + k
（20）关闭所有窗口：ctrl + shift + w
（21）查看指定的结构使用过的地方：ctrl + alt + g
（22）查找与替换：ctrl + f
（23）最大化当前的View：ctrl + m
（24）直接定位到当前行的首位：home
（25）直接定位到当前行的末位：end</code></pre>
<p>（2）JUnit单元测试</p>
<pre><code>使用：
    a.选中当当前工程-右键选择：bulid path - add libraries -JUnit 4 - 下一步
    b.创建java类，进行单元测试，要求的Java类要求：1.此类权限为public 2.此类提供公共的无参构造函数
    c.此类中声明单元测试方法：此时的单元测试方法权限是public，没有返回值，没有形参
    d.此单元测试方法需要声明注解：@Test，并在单元测试类中导入：org.junit.Test包 </code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/Java/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" data-id="ckp6d4twz000jm0ubfq1l1pyq" data-title="Java类库与基本操作" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java/java高级编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/27/Java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-03-27T14:37:01.185Z" itemprop="datePublished">2021-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/27/Java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">Java高级编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="高级编程"><a href="#高级编程" class="headerlink" title="#高级编程"></a>#高级编程</h2><p>##基础知识 </p>
<p>1.进程<br>    定义：是程序依次执行过程，或正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程—–生命周期<br>    内容：<br>        （1）进程作为资源分配的单位，系统在运行时回味每个进程分配不同的内存区域 </p>
<p>2.线程</p>
<pre><code>定义：是一个程序内部的一条执行路径

内容：
    （1）线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器，线程切换的开销小
    （2）一个进程中的多个线程共享相同的内存单元/内存地址空间-&gt;它们从同一个堆中分配对象，可以访问相同的变量和对象


生命周期：
    ![avatar](D:/ComputerUse/blog/img/live.jpg)

多线程的创建：
    （1）方式一：继承于Thread类
        使用：
            a.创建一个Thread类的子类
            b.重写Thread类的run()----&gt;将此线程执行的操作声明在run()中
            c.创建Thread类的子类对象
            d.通过此对象调用start()：该函数会启动当前线程，并调用当前线程的run()

    （2）方式二：实现Runnable接口------&gt;该方法的实现没有类单继承的局限性，更适合用来处理多个线程有共享数据的情况
        使用：
            a.创建一个实现了Runnable接口的类
            b.实现类去实现Runnable中的抽象方法：run()
            c.创建实现类的对象
            d.将此对象作为参数传递到Thread类中的构造器中，创建Thread类的对象
            e.通过Thread类的对象调用start()：启动线程，然后调用当前线程的run()-----&gt;调用了Runnable类型的target的run()

    （3）方式三：实现Callable接口
        使用：
            a.创建一个实现Callable的实现类
            b.实现call方法，将此线程需要执行的操作声明在call()中
            c.创建Callable接口实现类的对象
            d.将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象
            e.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
            f.获取Callable中Call方法中的返回值------&gt;可以通过get()得到返回值
        注：
            a.其call()方法，可以有返回值
            b.方法可以抛出异常，被外面的操作捕获，获取异常信息 
            c.支持泛型的返回值
            d.需要借助FutureTask类

    （4）方式四：使用线程池
            作用：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中，可以避免频繁创建销毁、实现重复里哟
            优点：提高响应速度、降低资源消耗、便于线程管理
            使用：
                a.提供指定线程数量的线程池：ExexcutorService service = Exectors.newFixedThreadPool( &lt;!-- 线程数量 --&gt; )
                b.执行指定线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象
                    service.excute( &lt;!-- 实现Runnable接口类的对象 --&gt; )
                    service.submit( &lt;!-- 实现Callable接口类 的对象 --&gt; )
                c.关闭线程池：service.shutdown()
            注：可以通过强制类型转换的方式，将ExecutorService转换成ThreadPoolExecutor类型对象，对线程池的属性进行设置


Thread类常见的方法：
    start()：启动线程，并执行run()方法
    run()：线程在被调度时执行的操作
    String getName()：返回线程的名称
    void setName(String name)：设置该线程的名称
    static Thread currentThread()：返回当前线程，在Thread子类中就是this，通常用于主线程和Runnable实现类
    yeild()：释放当前CPU的执行权
    join()：在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到join的线程执行完，线程a才结束阻塞状态
    stop()：强制线程生命周期结束，不推荐使用
    boolean isAlive()：返回boolean，判断线程是否还活着
    sleep(long millitime)：让当前线程阻塞指定的millitime毫秒
    getPriority()：返回线程优先级
    setPriority(int newPriority)：改变线程的优先级

解决线程的安全问题
    同步机制：
        （1）方式一：同步代码块
                使用：
                    synchronized(同步监视器)&#123;
                        &lt;!-- 需要被同步的代码(即操作共享数据的代码) --&gt;
                    &#125;
                注：
                    a.同步监视器：俗称，“锁”。任何一个类的对象，都可以充当锁。在以上方法中，多个线程必须要共用同一把锁
                    b.在实现Runnable接口创建多线程方式中，可以考虑使用this充当同步监视器

        （2）方式二：同步方法
                使用：通过 synchronized+方法 的来使用
                注：
                    a.同步方法仍然设计到同步监视器，只是不需要我们显式的声明
                    b.非静态的同步方法的同步监视器是this，静态的同步方法的同步监视器是当前类的本身

    Lock锁：
        使用：通过生成ReentrantLock类的对象，手动的启动同步(Lock())，同时结束同步也需要手动的实现(unlock())
        注：
            a.Lock是显式锁，需要进行手动的开启和关闭，synchronized是隐式锁，除了作用域自动释放
            b.Lock只有代码块锁，synchronized有代码块锁和方法所
            c.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性

死锁：
    定义：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己所需要的同步资源，就形成了线程的死锁。出现死锁后，不会出现异常、提示，只是所有的线程都处于阻塞状态，无法继续

线程通信方法：
    方法：
        wait()：执行此方法，当前线程就进入阻塞状态
        notify()：执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，会优先唤醒优先级高的线程
        notifyAll()：执行此方法，会唤醒所有被wait的一个线程
    注：
        a.以上三个方法必须使用在同步代码块或同步方法中，同时其调用者必须是同步代码块或同步方法当中的同步监视器，否则会出现IllegalMonitorStateException异常
        b.上面三个方法是定义在java.lang.Object类中</code></pre>
<p>3.并行与并发<br>    定义：并行指的是多个CPU同时执行多个任务，并发指的是一个CPU(采用时间片)同时执行多个任务</p>
<hr>
<p>###枚举类与注解 </p>
<p>1.枚举类<br>    包：定义的枚举类默认继承于java.lang.Enum<br>    说明：<br>        a.类的对象只有有限个，确定的。当需要定义一组常量时，强烈建议使用枚举类<br>        b.如果枚举类当中只有一个对象，则可以作为单例模式的实现方式<br>        c.定义枚举类：<br>            （1）jdk5.0之前，自定义枚举类<br>                1-声明对象的属性权限为：private final<br>                2-私有化构造器，并给对象属性私有化<br>                3-提供当前枚举类的多个对象</p>
<pre><code>        （2）jdk5.0，可以使用enum关键字定义枚举类
            1-提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束
    d.使用enum关键字定义的枚举类实现接口：当我们需要在调用指定枚举类时进行不同的操作，则在枚举对象后进行重写

常用方法：
    valueOf()：返回枚举类型的对象数组，该方法可以很方便的遍历所有的枚举值。也可以给其赋值一个字符串，可以索引指定名字的枚举对象，要求字符串必须是枚举对象的&quot;名字&quot;，否则会运行异常
    toString()：返回当前枚举对象常量名称</code></pre>
<p>2.注解<br>    说明：<br>        是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。可以用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在Annotation的”name=value”对中</p>
<pre><code>使用示例：
    a.使用Annotation时要在前面增加@符号，并把该Annotation当成一个修饰符使用
    b.在编译时进行格式检查（JDK内置的三个基本注解Override\Deprecated\SuppressWarnings）
    c.跟踪代码依赖性，实现替代配置文件功能
    d.spring框架中关于“事务”的管理

自定义注解：自定义注解必须配上注解的信息处理流程(使用反射)才有意义
    a.定义新的Annotation类型使用@interface关键字
    b.内部成员，通常使用value表示，可以指定成员的默认值，使用default定义。如果自定义注解没有成员，表示是一个标识作用。

元注解：    
    说明：用于修饰其他Annotation定义，对现有的注解进行解释说明的注解
    使用：
        Retention：只能用于修饰一个Annotation定义，用于指定该Annotation的生命周期---》SOURCE\CLASS(默认行为)\RUNTIME(能通过反射)
        Target：用于指定被修饰的Annotation能用于修饰哪些程序元素
        Documented：用于指定那个被盖院Annotation修饰的Annotation类将被javadoc工具提取成文档。默认情况下，javadoc是不包括注解的
        Inherited：被它修饰的Annotation将具有继承性

jdk8中注解的新特性
    可重复注解：@Repeatable
    类型注解：
        ElementType.TYPE_PARAMETER：表示该注解能写在类型变量的声明语句中（如：泛型声明）
        ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中</code></pre>
<hr>
<p>###java集合<br>1.Collection接口：单列数据，定义了存区一组对象的方法的集合</p>
<pre><code>List：元素有序、可重复集合
    （1）ArrayList：
            作为List接口的主要实现类，线程不安全的，效率高。底层使用了Object[]存储
            源码说明：
                jdk7情况下：
                    使用空参的构造器，底层创建了长度为10的Objectp[]数组elementData，如果某次添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原    来的容量的1.5倍，同时将原有数组中的数据复制到新的数组中
                jdk8中：
                    使用空参构造器，底层创建了Object[] elementData初始化为&#123;&#125;，直到第一次调用add()时，底层才创建了长度为10的数组，后续的添加扩容操作与上个版本无异
    （2）LinkedList：
            对于频繁的插入、删除操作，使用此类效率比ArrayList效率高。底层使用双向链表存储 
    （3）Vector：
            作为List接口的古老实现类，线程不安全的，效率低。底层使用了Object[]存储
    （4）常用方法：
                &lt;!-- https://www.cnblogs.com/gaomanito/p/8979076.html --&gt;
            get：获取指定index位置的元素
            addAll(int index,Collection eles)：从index位置开始将eles中的所有元素添加进来
            indexOf(Object obj)：返回obj在集合中首次出现的位置
            set(int index,Object eles)：设置指定index位置的元素为eles
            List subList(int fromIndex,int toIndex)：返回从fromIndex到toIndex位置的子集合
            Object remove(int index)：移除指定index位置阿元素，并返回此元素
            toArray()：将集合转换为数组
            asList()：将数组转换为集合

Set：元素无序，不可重复的集合(注：无序性不等于随机性，存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的)
    （1）HashSet：底层源码使用的时HashMap
            作为Set接口的主要实现类；线程不安全；可以存储null值
            注意：元素a与已经存在指定索引位置上数据以链表的方式存储，在jdk7中，元素a存放到数组中，指向原来的元素，在jdk8中，原来的元素在数组，只想元素a（七上八下准则）
    （2）LinkedHashSet：
            作为HashSet的子类；在添加数据的同时，每个数据还维护了两个引用，记录此数据的前后数据；遍历器内部数据时，可以按照添加的顺序遍历；对于频繁的遍历操作，LinkedHashSet效率高于HashSet5
    上述要求：
        1-向Set中添加的数据，其所在的类一定要重写hashCode()和equals
        2-重写的hashCode()和equals尽可能保持一致性：相等的对象必须具有相等的散列码

    （3）TreeSet：
            可以按照添加对象的指定属性进行排序；在底层当中采用红黑树的存储结构；有序，查询速度比List快；

    上述要求：
        1-向其中添加数据，要求是相同类的对象
        2-在自然排序当中，其比较数据是否相同的方法是通过compareTo函数是否返回0，定制排序中，则使用的是compare函数，不再是通过equals </code></pre>
<p>2.Map接口：双列数据，包存具有映射关系”key-value对”的集合</p>
<pre><code>说明：
    1-Map中的key：无序的、不可重复的，使用Set存储所有的key------&gt;key所在的类要重写equals()和hashCode()（以HashMap为例）
    2-Map中的value：无序的、可重复的，使用Collection存储所有的value-----&gt;value所在的类要重写equals()  
    3-一个键值对&quot;key-value&quot;构成了一个Entry对象
    4-Map中的entry：无序的、不可重复的，使用Set存储所有的entry（对于map内部值的调用，可以通过内部接口Map.Entry的getKey和getValue来查看）
    5-负载因子：用于表示哈希表中元素填满的程度
        a.其大小决定了HashMap的数据密度
        b.负载因子越大，密度越大，发生碰撞的机率越高，数组中的链表越长
        c.负载因子越小，就越容易促发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短
        d.考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数

（1）HashMap
        说明：作为Map中的主要实现类；线程不安全的，效率高；可以存储null的key和value；在jdk7以及之前底层结构为数组+链表，在jdk7之后加入了红黑树
        子类：
            LinkedHashMap（在原有的HashMap底层结构基础上，添加了一堆指针，指向前后元素）
        底层实现原理：
            1-实例化：
                jdk7：底层创建了长度为16的一维数组Entry[] table
                jdk8：底层没有创建一个长度为16的数组，直到首次调用put()方法才创建长度为16的数组，而且其底层数组为Node[]，并非Entry[]
            2-存放数据过程：
                jdk7：调用key所在类的hashCode()计算key哈希值，得到在Entry数组中的存放位置
                    情况：
                        if(位置为空)
                            &lt;!-- 添加成功 --&gt;
                        else
                            if(此位置上所链数据的哈希值是否与hashCode(key)相同)
                                if(key.equals(obj))
                                    key-&gt;value = obj-&gt;value
                                else
                                    &lt;!-- 添加成功 --&gt;
                            else
                                &lt;!-- 添加成功 --&gt;
                        注意：如果原位置上有数据，之后添加进去的数据是以链表的形式与原数据链接
                jdk8：
                    与jdk7的区别，存储结构加入了红黑树（当数组的某一个索引位置上的元素以链表形式存在的数据个数&gt;8且当前数组的长度&gt;64时，此时此索引位置上的所有数据改为使用红黑树存储）
            3-扩容方式：扩容为原来容量的两倍，将原有的数据复制过来


                功能：保证在遍历map元素时，可以添加的顺序实现遍历；对于频繁的遍历操作，此类执行效率高于HashMap
（2）TreeMap
        功能：保证按照添加的key-value对进行排序，实现排序遍历；此时考虑key的自然排序或定制排序
        说明：底层使用红黑树
（3）Hashtable
        说明：作为古老的实现类；线程安全，效率低；不能够存储null的key或value 
        子类：
            Properties
                功能：常用来处理配置文件，key和value都是String类型

（4）常用方法：
        Obeject put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中
        void putAll(Map m)：将m中的所有key-value存放到当前的map中
        Set keySet()：返回所有key构成的Set集合
        Collection values()：返回所有value构成的Collection集合
        Set entrySet()：返回所有key-value对构成的Set集合 </code></pre>
<hr>
<p>###泛型</p>
<pre><code>说明：jdk5.0新增的特性；允许在定义类、接口时通过一个标识表示类中某个属性的类型或者时某个方法的返回值及参数类型，这个类型将在使用时确定
使用：
    1-集合接口或集合类在jdk5.0时都修改为泛型的结构
    2-在实例化集合类时，可以指明具体的泛型类型
    3-指明完以后，在集合类或接口中凡是定义类或接口时，内部结构使用到类的泛型的位置，都指定为你实例化的泛型类型
    4-泛型的类型必须是类，不能是基本数据类型；需要用到基本数据类型的位置，拿包装类替换
    5-如果实例化时，没有指明泛型的类型，默认类型为java.lang.Object类型 
    6-自定义泛型类、接口
        说明：
            a.如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object,但不等价于Object
            b.父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型。如果子类在继承带泛型的父类时，指明了泛型类型，则实例化子类对象时，不再需要指明泛型
            c.泛型类可能有多个参数，此时应将多个参数一起放在尖括号内
            d.实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致
            e.泛型不同的引用不能相互赋值
            f.在编译时两个指定不同泛型的ArrayList,但是在运行时只有一个ArryList被加载到JVM当中
            g.如果泛型结构是一个抽象类或接口，则不可创建泛型类对象
            h.异常类和静态方法不能使用泛型
            i.泛型方法：
                格式：
                    [访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出异常
                （1）在方法中出现泛型结构，泛型参数与类的泛型参数没有任何关系，换句话说，泛型方法所属的类是不是泛型类都没有关系
                （2）泛型方法在调用时，指明了泛型参数的类型
                （3）可以声明为静态的（因为泛型参数实在调用方法时确定的，并非在实例化类时确定）
            j.通配符的使用
                对于?：
                    如List&lt;?&gt;:
                        添加：不能向其内部添加数据除了添加null之外(null是所有类型的成员)
                        获取：允许读取数据，可以用get()方法并使用其返回值，读取的数据类新为Object
                对于 ? extends A:
                    如G&lt;? extends A&gt;：可以作为G&lt;A&gt;和G&lt;B&gt;的父类的，其中B是A的子类
                对于 ? super A:
                    如G&lt;? super A&gt;：可以作为G&lt;A&gt;和G&lt;B&gt;的父类的，其中B是A的父类
                添加：可以向其添加允许范围内的对象</code></pre>
<hr>
<p>###IO流</p>
<pre><code>File类（声明再java.io包下 ）

    说明：
        File类的一个对象，代表一个文件或一个文件目录；在File类当中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作；如果需要读取或写入文件内容，必须使用IO流来完成；后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点 ”

    路径：
        在IDEA中，若没有声明绝对路径，此时其默认的相对路径在当前工程文件下，若使用的是JUnit中的单元测试方法测试，相对路径即为当前Module下。
        在eclipse中，则相对路径都在当前的Project下
        路径分隔符：
            windows：\\
            unix：/

    构造器：
        File(String filePath)
        File(String parentPath,String childPath)
        File(File parantFile,String childPath)

    常用方法：
        （1）String getAbsolutrPath()：获取绝对路径
        （2）String getPath()：获取路径
        （3）String getName()：获取名称
        （4）String gatParent()：获取上层文件目录路径。若无，返回null
        （5）long length()：获取文件长度(即：字节数)；不能获取目录的长度
        （6）long lastModified()：获取最后一次的修改时间，毫秒值
        （7）String[] list()：获取指定目录下的所有文件或者文件目录的名称数组
        （8）File[] listFiles()：获取定制目录下的所有文件或者文件目录的File数组 
        （9）Boolean ranameTo(File dest)：把文件重命名为指定的文件路径；需要file1在硬盘当中是存在的，且dest不能再硬盘当中存在

        （10）boolean isDirectory()：判断是否是文件目录
        （11）boolean isFile()：判断是否是文件
        （12）boolean exists()：判断是否存在
        （13）boolean canRead()：判断是否可读
        （14）boolean canWrite()：判断是否可写
        （15）boolean isHidden()：判断是否隐藏

        （16）boolean createNewFile()：创建文件；若文件存在，则不创建，返回false
        （17）boolean mkdir()：创建文件目录；如果文件目录存在，则不创建，如果此文件目录的上层目录不存在，也不创建(使用mkdirs就可以一并创建)；
            注意：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下
        （18）boolean delete()：删除文件或者文件夹
            注意：java中的删除不走回收站，同时，要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录


I/O流

    流的分类：
        （1）按操作的数据单位：字节流(8 bit--InputStream/OutputStream) 、 字符流(16 bit--Reader/Writer)
        （2）按数据流的流向：输入流(InputSreram\Reader) 、 输出流(OutputStream\Writer)
        （3）按流的角色：节点流 、 处理流

    使用：
        结点流(文件流)---&gt;FileInputStream/FileOutputStream/FileReader/FileWriter：
            1-对于文本文件(.txt/.java/.c/.cpp)，使用字符流处理；对于非文本文件(.jpg/.mp3/.mp4/.avi/.doc/.ppt)，使用字节流处理

            2-写入：
                （1）read()的理解：返回读入的一个字符，如果达到文件末尾，返回-1
                （2）异常处理：为了保证流资源一定可以执行关闭操作，需要使用try-catch-finally处理
                （3）读入文件一定要存在，否则会报异常FileNotFoundException

            3-输出：
                （1）对于输出操作，对应的File可以不存在的；如果不存在，在输出过程中会自动创建此文件
                （2）对于FileWriter的输出操作，可以指定输出内容是否覆盖原文件内容。
        处理流：
            1-缓冲流(处理流的一种)----&gt;BufrferedInputStream/BufferedOutputStream/BufferReader/BufferedWriter
                作用：提高了流的读取、写入的速度(内部提供了一个缓冲区)
                使用：
                    （1）造文件
                    （2）造流（先造节点流，后造缓冲流）
                    （3）使用完后，资源关闭(顺序是从外到内，当我们关闭外层流时，内层流也会自动关闭)

            2-转换流
                作用：提供了在字节流和字符流之间的转换
                使用：
                    InputStreanReader：将一个字节的输入流转换为字符的输入流(解码)
                    OuputStreamWriter：将一个字符的输出流转换为字节的输出流 (编码)
                注意：文件编码的方式，决定了解析时使用的字符集

            3-标准输入、输出流
                作用：
                    System.in：标准的输入流，默认从键盘输入
                    System.out：标准的输出流，默认从控制台输出
                使用：
                    System类的setIn(InputStream is)/setOut(PrintStream ps)方式重新指定输入和输出的

            4-打印流
                作用：实现将基本数据类型的数据格式转换为字符串输出
                使用：
                    PrintStream/PrintWriter 
                        功能：
                            （1）提供可一系列重载的print()和println()方法，用于多种数据类的输出
                            （2）上面两者的输出不会抛出IOException异常
                            （3）有自动的flush功能
                            （4）PrintStream打印的所有字符都使用平台的默认字符编码转化为字节，在需要写入字符而不是写入字节的情况下，应该使用PrintWriter类
                            （5）System.out返回的是PrintStream的实例

            5-数据流
                作用：更方便的操作java语言的基本数据类型和String的数据，用于读取和写出基本数据类型、String类的数据
                使用：主要通过DataOutputStream/DataIntputStream实现
                    注意：读取不同类型的数据的顺序要与当初写入文件时，保存的数据顺序一致

            6-对象流
                作用：用于存储和读取基本数据类型数据或对象的处理流，其强大之处在于可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来
                使用：
                    ObjectInputStream/ObjectOutputStream
                    （1）序列化：用ObjectOutputStream类保存基本数据或对象的机制
                            （1）该机制允许把内存当中的java对象转换成平台无关的二进制流
                            （2）可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原
                            （3）序列化是RMI(Remote Method Invoke - 远程方法调用)过程的参数和返回值都必须实现的机制，而RMI是JavaEE的基础；因此序列化机制是JavaEE
                            （4）要使某个对象支持可序列化，则必须让对象所属的类即其属性是可序列化的
                            注意：
                                为了让某个类是可序列化的，该类必须
                                    a.实现 Serializable/Externalizable 这两个接口之一，否则会抛出NotSerializableException异常；
                                    b.该类需要提供一个全局常量：serialVersionUID（其用来表明类的不同版本间的兼容性，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容）；如果类没有显式定义这个静态变量，它的值时Java在运行时环境根据类的内部细节自动生成的，若类的实例变量做了修改，则serialVersionUID可能发生变化
                    （2）反序列化：用ObjectInputStream类读取基本数据类型或对象的机制
                    注意：
                        ObjectInputStream和ObjectOutputStream不能序列化static和transient修饰的成员变量

            7-随机存取文件流(RandomAccessFile)
                作用：支持“随机访问”方式，程序可以直接跳到文件的任意地方来读、写文件；支持只访问文件的部分内容，可以向已存在的文件后追加内容
                使用：
                    （1）其直接继承于java.lang.Object类，实现了DataInput和DataOutput接口
                    （2）其既可以作为一个输入流，又可以作为一个输出流
                    （3）创建的RandomAccessFile类实例需要指定一个mode参数，该参数只当RandomAccessFile的访问模式：
                        --r：以只读方式打开
                        --rw：打开以便读取和写入
                        --rwd：打开以便读取和写入；同步文件内容的更新
                        --rws：打开以便读取和写入；同步文件内容和元数据的更新
                        注意：
                            a.如果模式为只读r，其是去读取一个已经存在的文件，如果读取的文件不存在，则会出现异常；如果是rw读写模式，当文件不存在时，则会去创建文件，如果存在则不创建
                            b.如果RandomAccessFile作为输出流时，如果写出的文件存在，则会对原有文件内容进行覆盖(默认情况下，从头覆盖)
                    （4）该类的对象包含一个记录指针，用以指示当前读写处的位置；其对象可以自由移动记录指针：
                        --long getFilePointer()：获取文件记录指针的当前位置
                        --void seek(long pos)：将文件记录指针定位到pos位置

NIO(New IO,Non-Blocking IO)
    说明：用于替代标准的Java IO API，其与原来的IO有同样作用和目的，但是使用方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作，NIO将以更高效的方式进行文件的读写操作

    使用：
    --java.nio.channels.Channel
        --FileChannel：处理本地文件
        --SocketChannel：TCP网络编程的客户端的Channel
        --ServerSocketChannel：TCP网络编程的服务器端的Channel
        --DataGramChannel：UDP网络编程中发送端和接收端的Channel

    （1）针对标准输入输出NIO
    （2）网络编程NIO</code></pre>
<p>###网络编程</p>
<pre><code>说明：直接或间接地通过网络协议与其他计算机实现数据交换，进行通讯        
要素：
    1-IP地址(InetAddress)
        --作用：唯一的表示Internet上计算机
        --本地回环地址：127.0.0.1
        --主机名：localhost
        --分类方式：
            方式1：
                --IPV4：4个字节组成，4个0-255，以点分十进制表示
                --IPV6：128位(16个字节)，写成8个无符号整数，每个整数用四个16禁止位表示，数之间用冒号(:)分开，如：3ffe:3201:1401:1280:c8ff:fe4d:db39:1984
            方式2：
                公用地址（万维网使用）/私有地址（局域网使用）
                注意：以192.168.开头就是私有地址

        --使用：java中使用InetAddress类代表IP
            --实例化：
                a.使用getByName(String host)，对其赋IP地址或域名
                b.使用getLocalHost()，生成本地的IP地址

    2-端口号
        --作用：标识正在计算机上运行的进程(程序)
        --格式：规定为一个16位的整数0~65535
        --分类：
            --公认端口：0~1023，被预先定义的服务通信占用
            --注册端口：1024~49151，分配给用户进程或应用进程
            --动态/私有端口：49152~65535
        --Socket：端口号与IP地址的组合得出的网络套接字

    3-网络协议
        --TCP协议(传输控制协议)/IP协议(网络互联协议)
            --IP协议是网络层的主要协议，支持网间互连的数据通信
            --TCP/IP协议模型形成了高效的四层体系结构（物理链路层、IP层、传输层和应用层）
            --协议要求：
                1.使用TCP协议钱，须简历TCP链接，形成数据通道
                2.传输前，采用“三次握手”方式，点对点通信，是可靠的
                3.TCP协议进行通信的两个应用进程：客户端、服务端
                4.在连接中可进行大数据量的传输
                5.传输完毕，需释放已建立的链接(&quot;四次挥手&quot;)，效率低
            --使用：
                --进程端：
                    1.创建Socket对象，指明服务器端的ip和端口号
                    2.获取一个输出流，用于输出数据
                    3.写出数据操作
                    4.资源关闭
                --服务器端：
                    1.创建服务器端的ServerSocket，指明自己的端口号
                    2.调用accept()表示接受来自于客户端的socket
                    3.获取输入流
                    4.读取输入流中的数据
                    5.关闭资源

        --UDP协议(用户数据报协议)
            --协议要求：
                1.将数据、源、目的封装成数据包，不需要建立连接
                2.每个数据报的大小限制在64K
                3.发送不管对方是否准备好，接受方收到也不确认，是不可靠的
                4.可以广播发送
                5.发送数据结束时无需释放资源，开销小，速度快
            --使用：
                1.DatagramSocket/DatagranPacket实现了基于UDP协议网络程序
                2.其通过数据报套接字DatagramSocket发送和接收系统不保证UDP数据报一定能够安全送到目的地，也不确定什么时候可以抵达
                3.DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号
                4.UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接
                --发送端

        --URL类 
            说明：统一资源定位符，表示Internet上某一资源的地址
            基本结构：&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表
                --参数列表格式：参数名=参数值&amp;参数名=参数值......</code></pre>
<p>###Java反射机制(Reflection)</p>
<pre><code>说明：
    反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法；加载完类后，在对内存的方法区中就产生了一个class类型的对象(一个类只有一个Class对象)，这个对象就包含了完整的类的结构信息，可以通过这个对象看到类的结构 

区别：
    正常方式：引入需要的“包类”名称---&gt;通过new实例化----&gt;取得实例化对象
    反射方式：实例化对象---&gt;getClass()方法---&gt;得到完整的“包类”名称 

java.lang.Class类（对应着加载到内存中的一个运行时类）
    类的加载过程：
        --程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)，接着使用java.exe命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，加载到内存中的类，称其为运行时类，此运行时类就作为Class的一个实例。
        --加载到内存中的运行时类，会缓存一定的时间，在此时间之内，可以通过不同的方式来获取此运行时类

    获取Class实例的方式：
        --调用运行时类的属性：class
        --通过运行时类的对象，调用getClass方法
        --调用Class的静态方法：forName(String classPath(绝对路径))
        --使用类的加载器(ClassLoader):
            --类加载器
                作用：
                    将class文件字节码内容加载到内存中，并将这些静态数据转换成方法风趣的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法去中类数据的访问入口
                类缓存：
                    标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载(缓存)一段时间；不过JVM垃圾回收机制可以回收这些Class对象
                分类：
                    --引导类加载器：
                        用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库，该加载器无法直接获取
                    --扩展类加载器：
                        负责jre/lib/ext目标下的jar包或-D java.ext.dirs指定目录下的jar包装入工作库
                    --系统类加载器：
                        负责java -classpath 或 -D java.class.path 所指的目录下的类与jar包装入工作，是最常用的加载器
                    注意：
                        --对于自定义类，使用系统类加载器进行加载
                        --调用系统加载的getParent()，获取扩展类加载器
                        --调用扩展类加载的getParent()，无法获取引导类加载器

    读取配置文件：
        方式：
            (1)此时的文件默认在当前的module下
                Properties pros = new Properties();
                FileInputStream fis = new FileInputStream(配置文件)
                pros.load(fis);
            (2)使用ClassLoader：此时配置文件默认在当前module的src下
                ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
                InputStream is = classLoader.getResourceAsStream(配置文件)
                pros.load(is);

    常用方法：
        --newInstance()：调用此方法，创建对应的运行时类的对象；内部调用了运行时类的空参构造器
            注意：
                （1）创建运行时类的对象，要求：
                    --运行时类必须提供空参的构造器
                    --空参的构造器的访问权限得够，通常设置为public
                （2）javabean中要求提供一个public的空参构造器，原因：
                    --便于通过反射，创建运行时类的对象
                    --便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器 

        --getFields()：获取当前运行时类及其父类中声明为public访问权限的属性
        --getDelaredFields()：获取当前运行时类中声明的所有属性(不包含父类中声明的属性)
        --getMethods()：获取当前运行时类及其父类中声明为public访问权限的方法
        --getDelaredMethods()：获取当前运行时类中声明的所有方法(不包含父类中声明的方法)
        --getConstructors()：获取当前运行时类中声明的public的构造器
        --getDelaredConstructors()：获取当前运行时类中声明的所有的构造器
        --getGenericSuperclass()：获取运行时类的带泛型的父类的泛型
        --getDeclaredConstructor()：调用构造器
        --getPackage()：获取运行时类所在的包

        调用运行时类中的指定属性：
            --创建运行时类的对象
            --通过getDeclaredField(String fieldName)：获取运行时类中指定变量名的属性
            --为了保证当前属性是可访问的，使用setAccessible()置为true
            --获取、修改指定对象的此属性值

        获取指定的某个方法：
            --创建运行时类的对象
            --通过getDelaredMethod(获取的方法名称，获取方法的形参列表)
            --为了保证当前属性是可访问的，使用setAccessible()置为true
            --调用方法invoke(方法的调用者，给方法形参赋值的实参 )

动态代理：

    说明：是指客户通过对代理类来调用其他对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象

    使用场景：
        --调试
        --远程方法调用

    区别：
        --静态代理：代理类与被代理类在编译期间，就确定下来了

    实行方法：
        --创建接口与被代理类
        --创建InvocationHandler的接口类，重写invoke函数
        --创建代理类（每次调用代理类时，会跳转到接口类的invoke方法，从而调用被代理类当中的方法）

    优点：相比于静态代理，其抽象角色中(接口)声明的所有方法都被转移到调用处理器一个集中的方法中处理，可以更加灵活和统一的处理众多的方法</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/27/Java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" data-id="ckp6d4ty5000km0ub5cnrdpgr" data-title="Java高级编程" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java/设计模式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/22/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2021-03-22T06:51:03.838Z" itemprop="datePublished">2021-03-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/22/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="设计模式"><a href="#设计模式" class="headerlink" title="#设计模式"></a>#设计模式</h2><p>##单例设计模式<br>    描述：采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，能够减少系统性的开销<br>    实现方法：<br>        1.饿汉式：其是线程安全的，但加载时间相对更长<br>            （1）私有化类的构造器<br>            （2）内部创建类的对象（也必须声明为静态）<br>            （3）提供公共的静态方法，返回类的对象<br>        2.懒汉式：能够延迟对象的创建，但目前是线程不安全的<br>            （1）私有化类的构造器<br>            （2）声明当前类对象，没有初始化（此对象也须声明为static）<br>            （3）声明public、static的返回当前类对象的方法</p>
<hr>
<p>##模板方法设计模式<br>    描述：当功能内部一部分实现是确定的，一部分是现实不确定的。这时可以把不确定的部分暴露出去，让子类去实现，这是一种模板模式</p>
<hr>
<p>##代理设计模式<br>    描述：代理设计就是为其他对象提供一种代理以控制对这个对象的访问<br>    应用场景：<br>        安全代理：屏蔽对真实角色的直接访问<br>        远程代理：通过代理类处理远程方法调用(RMI)<br>        延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象<br>    分类：<br>        静态代理：静态定义代理类<br>        动态代理：动态生成代理类</p>
<hr>
<p>##工厂设计模式<br>    描述：实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/22/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" data-id="ckp6d4twg000bm0ub288965ls" data-title="设计模式" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Other/STL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/15/Other/STL/" class="article-date">
  <time class="dt-published" datetime="2021-03-15T12:07:43.502Z" itemprop="datePublished">2021-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/15/Other/STL/">STL</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="STL"><a href="#STL" class="headerlink" title="#STL"></a>#STL</h2><h2 id="stl的使用"><a href="#stl的使用" class="headerlink" title="##stl的使用"></a>##stl的使用</h2><p>###pair的使用</p>
<pre><code>定义：
    （1）pair&lt;数据类型,数据类型&gt; p;
    （2）pair&lt;int,int&gt; p(1,5),直接初始化其内容
    （3）pair&lt;int,int&gt; p[maxnum]，定义了一个pair类型数组

访问：
    通过first与second访问其前后的内容
使用：
    （1）向pair数组里面插入值
        （a）map&lt;int,int&gt; mp;
            mp.insert(make_pair(1,2));
        （b）pair&lt;int,int&gt; p[maxnum];
            p[i]=&#123;1,2&#125;;
注意：可以直接使用关系运算符进行比较，当first相同时会通过判别second的大小来比较</code></pre>
<hr>
<p>###set的使用</p>
<pre><code>说明：
    （1）是一种包含已排序对象的关联容器，set集合容器实现了红黑树的平衡二叉搜索树的数据结构，在插入元素时，会自动调整二叉树的排序，把元素放到适当的位置，他不会插入相同键值的元素，而采取忽略处理
    （2）平衡二叉树的检索使用中序遍历算法，检索效率高于vector\deque\list等容器
    （3）对于该容器中的简直，不可直接去修改，应该先删除该键值，再插入新的键值
    （4）不提供直接存取元素的任何操作函数，只能通过迭代器进行间接存区，而且从迭代器角度来看，元素值是常数
    （5）元素比较动作只能用于型别相同的容器(即元素和排序准则必须相同)

常用方法：
    begin()：返回指向第一个元素的迭代器
    clear()：清除所有元素
    count()：返回某个值元素的个数
    end()：返回指向最后一个元素下一个位置的迭代器
    equal_range()：返回集合中与给定值相等的上下限的两个迭代器
    erase()：删除集合中的元素 find()：返回一个指向被查找到元素的迭代器 get_allocator()：返回集合的分配器
    insert()：在集合中插入元素 lower_bound()：返回指向大于（或等于）某值的第一个元素的迭代器
    key_comp()：返回一个用于元素间值比较的函数 max_size()：返回集合能容纳的元素的最大限值
    rbegin()：返回指向集合中最后一个元素的反向迭代器 rend()：返回指向集合中第一个元素的反向迭代器 size()：集合中元素的数目
    swap()：交换两个集合变量 upper_bound()：返回大于某个值元素的迭代器 value_comp()：返回一个用于比较元素间的值的函数</code></pre>
<p>###其他函数</p>
<p>iterator unique(iterator it_1,iterator it_2)：元素去重(删除相邻的重复元素(只保留一个))<br>    说明：其去重过程实际上就是不停的把后面不重复的元素移到起那面，即使用不重复的元素占领重读元素的位置，容器的长度并没有发生变化</p>
<p>lower_bound(iteraror it_1,iterator it_2,x)：返回指向a中第一个大于/等于x的元素迭代器<br>upper_bound(iteraror it_1,iterator it_2,x)：返回指向a中第一个大于x的元素迭代器<br>    注意：it_1到it_2之间的区域需要为一个元素(从小到大)排列的vector的一部分，若添加compare函数找小于等于或小于x的元素，则需要时从大到小的顺序</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/15/Other/STL/" data-id="ckp6d4twk000dm0ubbrpbf36x" data-title="STL" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Other/algorithm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/15/Other/algorithm/" class="article-date">
  <time class="dt-published" datetime="2021-03-15T12:05:55.901Z" itemprop="datePublished">2021-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/03/15/Other/algorithm/">algorithm</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="algorithm"><a href="#algorithm" class="headerlink" title="#algorithm"></a>#algorithm</h2><h2 id="算法学习"><a href="#算法学习" class="headerlink" title="##算法学习"></a>##算法学习</h2><p>###快速排序</p>
<pre><code>void quickSort(vector&lt;int&gt;&amp; arr,int left,int right)&#123;

    if(left&gt;=right)
        return;
    &lt;!--确定目标数与比较数的位置--&gt;
    int oldLeft = left,oldRight = right;

    &lt;!-- 用于记录序列是否排序完毕 --&gt;
    bool judge = true;
    int    target = arr[left];

    &lt;!-- 通过左右往返比较，确定目标值在序列当中的位置 --&gt;
    while(left&lt;right)&#123;
        while(left&lt;right &amp;&amp; arr[right]&gt;=target)&#123;
            right--;
            judge=false;
        &#125;
        arr[left] = arr[right];

        while(left&lt;right &amp;&amp; arr[left]&lt;=target)&#123;
            left++;
            judge=false;
        &#125;
        arr[right] = arr[left];
    &#125;
    arr[left] = target;

    &lt;!-- 将目标数左右两侧的序列分开进行排序 --&gt;
    if(!judge)&#123;
        quickSort(arr,oldLeft,left-1);
        quickSort(arr,left+1,oldRight);
    &#125;
    return ;
&#125;</code></pre>
<hr>
<p>###堆排序</p>
<pre><code>void adjustPos(vector&lt;int&gt;&amp; args,int markPos,int size)
&#123;
    &lt;!-- 左右叶节点  --&gt;
    int left = 2*markPos+1;
    int right = 2*markPos+2;

    &lt;!-- 记录最值位置，比较左右结点与根节点的大小  --&gt;
    int maxNums=markPos;
    if(left&lt;size &amp;&amp; args[left]&gt;args[maxNums])
        maxNums = left;
    if(right&lt;size &amp;&amp; args[right]&gt;args[maxNums])
        maxNums = right;
    if(maxNums!=markPos)&#123;
        swap(args[maxNums],args[markPos]);    
        adjustPos(args,maxNums,size);
    &#125;
    return ;
&#125;
void heapSort(vector&lt;int&gt;&amp; args)&#123;
    int markNode=args.size()/2-1;        &lt;!-- 最后一个非叶子节点位置 --&gt; 

    &lt;!-- 通过遍历非叶子结点，将其构造成大顶堆（升序）/小顶堆（降序） --&gt; 
    for(int i=markNode;i&gt;=0;i--)&#123;
        adjustPos(args,i,args.size());
    &#125;

    &lt;!-- 每次得到根节点为最大值  --&gt;
    for(int i=args.size()-1;i&gt;=1;i--)&#123;
        swap(args[i],args[0]);
        adjustPos(args,0,i);
    &#125;
    return ;
&#125;</code></pre>
<p>###哈希表</p>
<p>###优先队列</p>
<pre><code>功能：在优先队列中，元素被赋予优先级，当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出的行为特征

实现：
    class prorityQueue&#123;
        public:
            prorityQueue()&#123;

            &#125;
            &lt;!-- 对于基本类型的大/小顶堆  --&gt;
            void bigTopPile()&#123;
                &lt;!-- 等同于priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; a
                若要其置成小顶堆则
                    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; --&gt;
                priority_queue&lt;int&gt; a;          
                int s=0;
                while(cin&gt;&gt;s)&#123;
                    a.push(s);
                &#125;
                while(!a.empty())&#123;
                    cout&lt;&lt;a.top()&lt;&lt;&quot; &quot;;
                    a.pop();
                &#125;
                return ;
            &#125;

            &lt;!-- 使用pair做优先队列元素，先比较第一个元素，第一个相等比较第二个 --&gt;
            void pairPriorityQueue(int nums)&#123;
                priority_queue&lt;pair&lt;int,string&gt; &gt; pq;
                int pos;
                string posStr;
                pair&lt;int,string&gt; p1[nums];
                int i=0;
                while(cin&gt;&gt;pos&gt;&gt;posStr)&#123;
                    p1[i]=&#123;pos,posStr&#125;;
                    pq.push(p1[i]);
                    i++;
                &#125;
                while(!pq.empty())&#123;
                    cout&lt;&lt;pq.top().first&lt;&lt;&quot; &quot;&lt;&lt;pq.top().second&lt;&lt;endl;
                    pq.pop();
                &#125;
                return ;

            &lt;!-- 用自定义的类型做优先队列元素 --&gt;

            &#125;
    &#125;;</code></pre>
<p>###并查集</p>
<pre><code>作用：主要可以用于解决一些元素分组的问题，管理一系列不相交的集合
功能：
    （1）合并：把两个不相交的集合合并为一个集合
    （2）查询：查询两个元素是否在同一个集合中
实现：
    MergeQurey()&#123;
        nums=0;
        &lt;!-- 使用两个数组分别来记录当前点所连接的根节点，以及当前节点深度 --&gt;
        vector&lt;int&gt; t1(10001,0),t2(10000,1);
        pre = t1;
        rank = t2;
        for(int i=0;i&lt;10001;i++)
            pre[i]=i;
    &#125;
    &lt;!-- 用于搜寻当前结点的根节点 --&gt;
    int find(int j)&#123;
        if(pre[j] == j)
            return j;
        else
            return find(pre[j]);
    &#125;
    &lt;!-- 合并两个节点,比较两个节点的深度,尽量由深度短的节点,指向深度深的节点,减少节点长度,降低搜寻长度 --&gt;
    void orderMerge(int i,int j)&#123;
        int x= find(i),y = find(j);
        if(rank[x] &lt;= rank[y])&#123;
            pre[x] = y;
        &#125;else&#123;
            pre[y] = x;
        &#125;
        &lt;!-- 当两个节点深度相同，则二者相连 --&gt;
        if(rank[x] == rank[y] &amp;&amp; x!=y)
            rank[y]++; 
    &#125;</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/15/Other/algorithm/" data-id="ckp6d4twt000fm0ubas5o09b4" data-title="algorithm" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java/JavaLearing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/08/Java/JavaLearing/" class="article-date">
  <time class="dt-published" datetime="2021-03-08T06:43:23.566Z" itemprop="datePublished">2021-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <hr>
<p>title: JavaLearing<br>tags: </p>
<hr>
<h2 id="Java学习"><a href="#Java学习" class="headerlink" title="#Java学习"></a>#Java学习</h2><p>##编程基础</p>
<hr>
<p>###基础知识杂记<br>1.进制转换</p>
<pre><code>二进制：0b开头
八进制：0开头
十六进制：0x开头</code></pre>
<p>2.运算符<br>    位运算符：</p>
<pre><code>    操作的都为整型数据
    右移运算符根据最高位的数来补充（&gt;&gt;&gt;都用0补）
    ~：正(负)数取反，各二进制码按补码各位取反
    运算符优先级：</code></pre>
<p>3.Scanner</p>
<pre><code>包：java.util.Scanner
对象生成：Scanner scanner = new Scanner(System.in);

int型数据：nextInt()
double型数据：nextDouble()
float型数据：nextFloat()
boolean型数据：nextBoolean()
char型数据：Scanner没有提供相关的方法，只能通过获取一个字符串，再通过String当中的charAt()获取

注意：需要根据相应的方法来输入指定类型的值，如果输入的数据类型与要求的类型不匹配时，会报异常</code></pre>
<p>4.条件转换语句</p>
<pre><code>switch结构中的表达式所允许的数据类型：
    byte、short、char、int、枚举类型（JDK5.0新增）、String类型（JDK7.0新增）</code></pre>
<p>5.可变个数形参(jdk5.0新增的内容)</p>
<pre><code>格式：数据类型 ... 变量名
使用：其性质与数组相同
注意：
    (1)    则其与本类名中方法名相同，形参类型也相同的数组之间不构成重载，二者不能共存
    (2)    在形参当中使用，必须声明在末尾
    (3)    最多只能声明一个可变形参</code></pre>
<p>6.Java中的参数传递机制：值传递</p>
<pre><code>如果参数是基本数据类型，此时实参赋给形参的是实参的真实存储的数据值
如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值 </code></pre>
<hr>
<p>###面向对象（程序设计要求高内聚、 低耦合）</p>
<p>1.对象的内存解析：</p>
<pre><code>堆：所有的对象实例以及数组都要在堆上分配
栈（虚拟机栈）：用于存储局部变量等
方法区：用于存储已被虚拟机加载的类信息、常量、静态、变量、即使编译器编译后的代码等数据
类属性：在内存当中加载到堆空间中
局部变量：在内存当中加载到栈空间中</code></pre>
<p>2.封装性：</p>
<pre><code>访问权限：用于修饰类以及类的内部结构：属性、方法、构造器、内部类
    (1)    private：类内部
    (2)    default（缺省）：private + 同一个包 
    (3)    protected：default + 不同包的子类
    (4)    public：proctected + 同一个工程
    注意：对于class的权限修饰只可以用public和default，public类可以在任意地方被访问，default类只可以被同一个包内部的类访问</code></pre>
<p>3.继承性：</p>
<pre><code>格式：class A extends B（子类A继承父类B后，子类A中就获取了父类B中声明的结构、属性和方法 ）
        A:子类、派生类、subclass
        B:父类、超类、基类、superclass

使用：
    （1）一个类只能有一个父类，java中的单继承性 
    （2）一个父类可以派生出多个子类
    （3）子父类是相对的
    （4）子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法

注意：
    （1）父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私 有的结构，只因为封装性的影响，使得子类不能直接调用父类的结构
    （2）如果没有显示的声明一个类的父类，则此类继承于java.lang.Object类（注：所有的java类，处java.lang.Object类之外，都直接或简介的继承于java.lang,Object类，也就意味着，所有Java类具有java.lang.Object类生命的功能）</code></pre>
<p>4.多态性：父类的引用指向子类的对象</p>
<pre><code>使用：
    （1）虚拟方法调用：子类中定义了伊夫雷同名同参数的方法，在多态情况下，将此时父类的方法成为虚拟方法，父类根据赋值给他的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期时无法确定的
    （2）有了对象多态性以后，在编译期中，我们只能调用父类中声明的方法，但在运行期，实际执行的时子类重写父类的方法
    （3）对象的多态性只适用于方法， 不适用于属性
    （4）使用对象的多态性时，内存实际上是加载了子类特有的属性和方法，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法，子类特有的属性和方法不能调用
    （5）可以使用强制类型转换向下转型，赋给子类对象（注意：使用强制类型转换，可能会出现ClassCastException异常，我们可以使用instanceof关键字进行判断）</code></pre>
<p>5.方法的重写（override/overwrite）：</p>
<pre><code>功能：重写后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的时子类重写父类的方法，进行覆盖操作
规定：
    （1）子类重写方法的权限修饰符不小父类被重写的方法的权限修饰符
    （2）返回值类型
        父类为void--------&gt;子类void
        父类为A类型-------&gt;子类为A类或A类的子类
        父类为基本数据类型---------&gt;子类为相同的基本数据类型
    （3）子类重写的方法抛出异常 类型不大于父类被重写的方法抛出的异常类型
注意：子类不能重写父类中声明为private的方法</code></pre>
<p>6.子类对象实例化的全过程</p>
<pre><code>（1）从结果上看：（继承性）
    子类继承父类够，就获取了父类中声明的属性或方法
    创建子类对象，在堆空间中就会加载所有父类中生命的属性
（2）从过程上看：
    当我们通过子类的构造器创建子类对象时，一定会直接或间接的调用其父类的构造器，进而调用父类的父类构造器，直到调用了java.lang,Object类中的空参的构造器为止。因此我们才可以看到内存中有父类的结构，子类对象才可以考虑进行调用</code></pre>
<p>7.关键字</p>
<pre><code>this关键字：
    功能：用来修饰属性、方法、构造器，可以理解为当前对象或当前正在创建的对象
    使用：
        在类的构造器和方法中我们可以使用“this.属性”或“this.方法”的方式，来调用当前正在创建的对象属性或方法/已存在的对象属性或方法，同时我们可以通过使用“this（形参列表）”的方式，来调用本类中指定的其他构造器，但是不能调用自己这个构造器 


package关键字：
    功能：为了更好的实现项目中类的管理
    使用：
        （1）使用其声明类或接口所属的包，声明在源文件的首行
        （2）属性名中每“.”一次，代表一层文件目录
        （3）同一个包下，不能命名同名的接口或类

import关键字：
    功能：在源文件中显式的使用import结构导入指定包下的类、接口 
    使用： 
        （1）声明在包的声明和类的声明之间
        （2）使用“xxx.*”的方式，表示可以导入xxx包下的所有结构
        （3）如果使用的类或接口是java.lang包下定义的或者是在本包下定义的，则可以省略import结构
        （4）如果在源文件中，使用了不同包下的同名类，则必须至少有一个需要以全类名的方式显示
        （5）使用“xxx.*”方式表明可以调用xxx包下的所有结构，但是如果使用的是xxx子包下的结构，则仍需导入 
        （6）import static：导入指定类或接口中的静态结构

super关键字（可以理解为父类的）
    功能：
        （1）可以在子类的方法或构造器当中，通过使用“super.属性”或“super.方法”的方式，显式的调用父类中声明的属性或方法，但是通常对其进行省略
        （2）当子类和父类中定义了同名的属性时，想要在子类当中调用父类中声明的属性，则必须显式的使用“super.属性”的方法，表明调用的时父类中声明的属性
        （3）当子类重写了父类中的方法后，若是需要在子类当中调用父类的方法时，则必须显式的使用“super.方法”的方式，表明调用的是父类被重写的方法
        （4）可以在子类的构造器中显式的使用“super(形参列表)”的方法调用父类中声明的指定构造器（注意：必须声明在子类构造器的首行，同时对于this(形参列表)或super(形参列表)，二者不能同时出现）
        （5）在构造器的首行中，没有显式的声明“this(形参列表)”或“super(形参列表)”，则默认调用的是父类中空参的构造器
        （6）在类的多个构造器中，至少有一个类的构造器实用了“super(形参)”，调用父类中的构造器

instanceof关键字
    功能：判断指定对象是否是指定类的实例
    格式：a instanceof A（a对象 A类）

static关键字：
    功能：静态的，可以用来修饰属性、方法、代码块、内部类
    使用：
        （1）属性：是否使用static修饰，分为静态属性(类变量)和非静态属性(实例变量)
                实例变量：所创建的每个对象都独立拥有一套类中的非静态属性
                静态变量：所创建的多个对象都共享一个静态变量，当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，进行了修改。同时，静态变量随着类的加载而加载，其加载要早于对象的创建，则可以通过 “ 类.静态变量 ” 的方式来进行调用
        （2）方法：其使用方法与属性一致
                注意：
                    a.在静态方法中，只能调用静态的方法或属性
                    b.在静态方法中，不可以使用this关键字、super关键字

final关键字：
    功能：可以用来修饰类、方法、变量
    使用：
        （1）用来修饰类，此类不能被其他类所继承
        （2）用来修饰方法，表明此方法不能被重写
        （3）用来修饰变量，此时变量称为“常量 ”，其赋值的位置有显式初始化、代码块中初始化、构造器中初始化。当使用final修饰形参时，表明此形参是一个常量，当我们调用此方法时，给常量形参赋一个实参，一旦赋值以后，就只呢在方法体内使用此形参，但不能进行重新赋值
        （4）static final用来修饰属性：全局常量

abstract关键字： 
    功能：可以用来修饰的类和方法 
    使用：
        修饰对象为类： 
            （1）此类不能实例化
            （2）此类中一定有构造器，便于子类实例化时调用（因此，在开发中都会提供抽象类的子类，让子类对象完成实例化，完成相关操作） 
        修饰对象为方法：
            （1）抽象方法只有方法的声明，没有方法体 
            （2）包含抽象方法的类，一定是个抽象类，而抽象类中可以没有抽象方法
            （3）若子类重写了父类中的所有抽象方法后，此子类方可实例化，若没有重写完父类中所有的抽象方法，此子类也是一个抽象类，需要使用abstract修饰 
    注意：
        （1）不能用来修饰属性、构造器等结构 
        （2）不能用来修饰私有方法、静态方法、final方法、final类

mian()方法
    功能： 
        （1）作为程序的入口
        （2）一个普通的静态方法
        （3）可以作为与控制台交互的方式 </code></pre>
<p>8.代码块（初始化块）</p>
<pre><code> 作用：用来初始化类、对象
 使用：
     （1）代码块如果有修饰的话，只能使用static
     （2）对于静态代码块：初始化类的信息 
             a.内部可以有输出语句
             b.随着类的加载而执行，而且只会执行一次
             c.如果类中定义了多个静态代码块，则按照声明的先后顺序执行
             d.只能调用静态结构
         对于非静态代码块：可以在创建对象时，对对象的等进行初始化
             a.内部可以有输出语句
             b.随着对象的创建而执行，每创建一次对象执行一次
             c.按照声明的先后顺序执行</code></pre>
<p>9.接口(interface)：Java中，接口和类是并列的两个结构</p>
<pre><code>使用：
    （1）在JDK7及以前：只能定义全局常量(public static final)和抽象方法(public abstract)，在JDK8以后：增加定义静态方法、默认方法
    （2）接口中不能定义构造器，意味着其不能实例化
    （3）Java开发中，接口通过让类去实现(implements)的方式来使用实例化，如果实现类覆盖了接口中所有的抽象方法，则实现类就可以实例化，若没有完全覆盖，则仍为抽象类
    （4）Java类中可以实现多个接口（弥补Java当中单继承性的局限性）
        格式：class AA extends BB implements CC,DD
    （5）接口与接口之间可以继承，而且可以多继承
    （6）接口中定义的静态方法，只能通过接口来调用
    （7）通过实现类的对象，可以调用接口中的默认方法。如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法
    （8）对于方法的类优先原则：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的方法，那么子类再没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法
    （9）接口冲突：在实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么实现类没有重写此方法的情况下，会报错。解决接口冲突则需在实现类当中重写此方法
    （10）在子类(或实现类)的方法当中调用父类、接口被重写的方法
            自己重写的方法：use();
            父类中声明的方法：super.use();
            接口中的默认方法：XXX.super.use()</code></pre>
<p>10.内部类</p>
<pre><code>描述：在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类
分类：
    （1）成员内部类(静态、非静态)：
        a.作为一个类：
            类内可以定义属性、方法、构造器等
            可以被final修饰，表示此类不能被继承
            可以被abstract修饰
        b.作为外部类的成员：
            可以调用外部类的结构
            可以被static修饰
            可以被4种不同的权限修饰

    （2）局部内部类(方法内、代码块内、构造器内)：在局部内部类的方法中，如果调用及局部内部类所声明的方法中的局部变量，要求此局部变量声明为final
使用：
    （1）实例化成员内部类对象
        example ：Person.Bird bird = new p.Bird()</code></pre>
<hr>
<p>###异常处理(抓抛模型)</p>
<pre><code>方法：
    （1）try-catch-finally：
            使用：
                try&#123;
                    可能出现异常的代码
                &#125;catch(异常类型1 变量名1)&#123;
                    处理异常的方式
                &#125;
                ....
                finally&#123;
                    一定会被执行的代码(即使catch当中出现异常，或try当中出现return语句)
                &#125;

        注意：
            a.finally是可选的
            b.catch中的若异常类型如果满足子父类关系，则要求子类一定声明在父类上面。否则，报错。
            c.使用该异常处理方式，处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错
            d.开发中，由于运行时异常比较常见，所以通常不针对运行时异常编写 方法来处理

    （2）throws+异常类型：
            使用：
                （1）写在方法的声明处，指明方法执行时，可能会抛出的异常类型。一旦方法体执行时出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码就不再执行
                （2）如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws

    （3）throw关键字：通过throw new 异常类的方法，从而可以手动生成异常对象，声明在方法体内

    （4）自定义异常类
            使用：
                （1）继承与现有的异常结构：RuntimeExeption\Exception
                （2）提供全局常量：serialVersionUID
                （3）提供重载的构造器</code></pre>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/08/Java/JavaLearing/" data-id="ckp6d4tw90009m0ubcrxffxm1" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/27/Other/README/">计算机网络——网络层</a>
          </li>
        
          <li>
            <a href="/2021/05/26/ComputerNetWork/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%945%E4%BC%A0%E8%BE%93%E5%B1%82/">计算机网络——传输层</a>
          </li>
        
          <li>
            <a href="/2021/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%944%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络——网络层</a>
          </li>
        
          <li>
            <a href="/2021/05/20/ComputerNetWork/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%944%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络——网络层</a>
          </li>
        
          <li>
            <a href="/2021/05/14/ComputerNetWork/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%943%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">计算机网络——数据链路层</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>