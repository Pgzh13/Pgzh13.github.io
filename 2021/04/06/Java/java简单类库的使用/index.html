<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Java类库与基本操作 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="#简单的类库使用###数字 Math.random():令系统随机选取大于等于0.0且小于1.0的伪随机double值     Math.random()*(n-m)+m：返回指定范围的随机数（m-n之间）的公式  ###字符 string.equals():判断二者是否相同   ###Arrys工具类 Ops:java.util.Arrays Using:     sort():快速排序">
<meta property="og:type" content="article">
<meta property="og:title" content="Java类库与基本操作">
<meta property="og:url" content="http://example.com/2021/04/06/Java/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="#简单的类库使用###数字 Math.random():令系统随机选取大于等于0.0且小于1.0的伪随机double值     Math.random()*(n-m)+m：返回指定范围的随机数（m-n之间）的公式  ###字符 string.equals():判断二者是否相同   ###Arrys工具类 Ops:java.util.Arrays Using:     sort():快速排序">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-04-06T06:27:24.916Z">
<meta property="article:modified_time" content="2021-05-14T01:40:46.141Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Java/java简单类库的使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/06/Java/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2021-04-06T06:27:24.916Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Java类库与基本操作
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="简单的类库使用"><a href="#简单的类库使用" class="headerlink" title="#简单的类库使用"></a>#简单的类库使用</h2><p>###数字</p>
<pre><code>Math.random():令系统随机选取大于等于0.0且小于1.0的伪随机double值
    Math.random()*(n-m)+m：返回指定范围的随机数（m-n之间）的公式</code></pre>
<hr>
<p>###字符</p>
<pre><code>string.equals():判断二者是否相同 </code></pre>
<hr>
<p>###Arrys工具类</p>
<pre><code>Ops:java.util.Arrays
Using:
    sort():快速排序
    binary():二分查找
    equals():判断两个数组是否相同
    fill(int[] a,int val):将指定值填充到数组之中</code></pre>
<hr>
<p>###JavaBean:是一种Java语言写成的可重用组件（也是一个Java类）</p>
<pre><code>特征：
    （1）类是公共的
    （2）有一个无参的公共的构造器
    （3）有属性，且对应的get、set方法
功能：
    可以将功能、处理、值、数据库访问和其他任何可以用Java代码创造对象进行打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。</code></pre>
<hr>
<p>###UML类图</p>
<pre><code>结构：
    类名
    属性（属性名：属性类型）
    方法（方法的类型 方法名(参数名：参数类型)：返回值类型）注：若方法有下划线表示为构造器
    ‘+’表示public,‘-’表示private，‘#’表示proctected</code></pre>
<hr>
<p>###Object类（是所有java类的根父类，如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类） </p>
<pre><code>（1）equals()： 比较二者是否相同

    使用：
        （1）是一个方法，并不是运算符
        （2）只能适用于引用数据类型
        （3）Object类中定义的equals()和==的作用是相同的，比较两个对象的地址值是否相同
        （4）在String、Data、File、包装类等都重写了Object类中的equals()方法，重写后，比较的是两个对象的实体内容

    与“==”的却别：
        ==：
            （1）可以使用在基本数据类型 变量和引用数据类型变量中
            （2）如果比较的是基本数据类型变量，比较二者保存的数据是否相同（不一定要类型相同）
                如果比较的是引用数据类型变量，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体

（2）toString()：

    使用：
        a.当输出一个对象的引用时，实际上就是调用当前对象的toString()方法
        b.String、Date、File、包装类等都重写了Object类中的toString()方法</code></pre>
<hr>
<p>###包装类(Wrapper)的使用</p>
<pre><code>功能：java提供了8种数据类型对应的包装类，使得基本数据类型的变量具有类的特征
使用：
    （1）基本数据类型、包装类、String三者之间的相互转换
        基本数据类型-----&gt;包装类：调用包装类的构造器
        包装类-----&gt;基本数据类型：调用包装类Xxx的xxxValue()
        基本数据类型、包装类----&gt;String类型：调用String重载的valueOf(Xxx xxx)
        String类型-------&gt;基本数据类型、包装类：调用包装类的parseXxx(String s)
    注意：
        自动装箱：可以直接将基本数据类型赋给包装类，可以提高效率（只可以赋值到-128到127，当大于这个数则会通过d调用构造器来创建对象）
        自动拆箱：直接将包装类赋给基本数据类型</code></pre>
<hr>
<p>###Vector类的使用</p>
<pre><code>功能：代替数组进行处理
使用：
    （1）addElement(Object ob)：给向量添加元素
    （2）elementAt(0)：取出向量中的元素，返回值是Object类型
    （3）size()：计算向量长度 </code></pre>
<hr>
<p>###JDK8日期时间API</p>
<pre><code>1.LocalDate\LocalTime\LocalDateTime
    实例化：
        now(Zoneid zone)：静态方法，根据当前时间创建对象/指定时区的对象
        of()：静态方法，根据指定日期/时间创建对象，不存在偏移量

    使用方法：    
        getDayOfMonth()/getDayOfYear()：获得月份太难书(1-31)/获得年份天数(1-366)
        getDayOfWeek()：获取星期几(返回一个DayOfWeek枚举值)
        getMonth()：获得月份，返回一个Month枚举值
        getMonthValue()/getYear()：获取月份(1-12)/获取年份
        getHour()/getMinute/getSecond()：获取当前对象对应的时分秒
        withDayOfMonth()/withDayOfYear()/withMonth()/withYear()：将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象

2.Instent类：时间线上的一个瞬时点
    实例化：
        now()：静态方法，返回默认UTC时区的Instant类的对象
        ofEpochMilli(long epochMilli)：静态方法，返回在1970-01-01 00：00：00基础上加上指定毫秒数之后的Instant类的对象

    使用：
        atOffset(ZoneOffset offset)：结合即时的偏移来创建一个OffsetDateTime
        toEpochMilli()：返回1970-01-01 00：00：00到当前时间的毫秒数，即为时间戳（ofEpochMilli：通过给定的毫秒数，获取Instant实例）

3.DateTimeFormatter类：该类提供了三种格式化方法
    使用：
        ofPattern(String pattern)：静态方法，返回一个指定字符串格式的DateTimeFormatter
        format(TemporalAccessor t)：格式化一个日期、时间，返回字符串
        parse(CharSequence text)：将指定格式的字符序列解析为一个日期、时间

4.Date类
    位置：java.util.Date
    使用：使用其空参构造器创建一个对应当前时间的Date对象，也可以给其构造器赋指定毫秒数
        a.toString()：显式当前的年月日时分秒
        b.getTime()：获取当前Date对象对应的时间戳

5.java.sql.Date
    说明：对应这数据库中的日期类型变量，该类时System类的子类
    实例化：java.sql.Date date = new java.sql.Date(毫秒数)

6.java.text.SimpleFormat类
    说明：是一个不与语言环境有关的方式来格式化和解析日期的具体类
    解析：文本--&gt;日期
    使用：
        a.格式化：日期----&gt;字符串
            String对象 = (SimpleFormat对象).format(Date对象)
        b.解析：格式化的逆过程，字符串----&gt;日期
            解析的String对象需要为&quot;年份-月份-日期 上下午 时:分&quot;
            通过指定格式实例化的方法，可以指定转换的日期格式：Date对象 = SimpleDateFormat对象.parse(&quot;指定格式时间的字符串&quot;)
                要求：字符串必须时符合SimpleDateFormat识别的格式(通过构造器参数体现，否则抛异常)

7.java.util.Calendar(日历)类
    说明：是一个抽象基类，主要用于完成日期字段之间相互操作的功能
    实例化：通过调用它的子类GregorianCalendar的构造器/使用Calendar.getInstance()方法
    常用方法：
        get()：获取常用的时间属性信息
        set()：将指定的时间属性设置成新的值
        add()：在原有的基础属性的值上添加
        getTime()：日历类-----&gt;Date
        setTime()：Date-----&gt;日历类
    注意：月份从0开始，星期从1(星期日)开始

8.其他的时间类
    ZoneId：该类中包含了所有的时区信息】
    ZonedDateTime：一个在ISO-8601日历系统时区的日期时间
    Clock：使用时区提供堆当前即时、日期和时间的访问的时钟
    Duration：用于计算两个&quot;时间&quot;间隔
    Period：用于计算两个&quot;日期&quot;间隔
    TemporalAdjuster：时间校正器。
    TemporalAdjusters：该类通过静态方法(firstDayOfXxx() / lastDayOfXxx() / nextXxx())提供了大量的常用TemporalAdjust的实现</code></pre>
<hr>
<p>###java比较器</p>
<pre><code>Comparable接口：自然排序
    包：java.lang.Comparable
    使用：
        1.像String、包装类等实现了Comparable接口，重写了compareTo()方法，给出了比较两个对象的大小，进行从小到大的排序
        2.重写compareTo()的规则
            当前对象&gt;形参对象，返回正整数，&lt;返回负整数，相等返回0
        3.对于自定义类，如果说需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法，在CompareTo(obj)方法中指明如何排序

Comparator接口：定制排序、
    包：java.lang.Comparator
    使用：可以使用匿名的方式，重写conpare方法</code></pre>
<p>###System类</p>
<pre><code>说明：代表系统，系统级的很多属性和控制方法都放置在该类的内部
包：java.lang
使用：
    1.该类的构造器为私有的，所以无法创建该类的对象
    2.内部成员变量和成员方法都为static
常用方法：
    currentTimeMillis()：返回当前的计算机时间
    exit(int status)：退出程序，0表示正常退出，非0表示异常退出，使用该方法可以在图形界面编程中实现程序的退出功能
    gc()：请求系统进行垃圾回收
    getProperty(String key)：获得系统中属性名为key的属性对应的值</code></pre>
<p>###Math类</p>
<pre><code>说明：提供了一系列静态方法用于科学计算，其方法的参数和返回值类型一般为double型
包：java.lang
常用方法：
    abs：绝对值
    sqrt：平方值
    pow(a,b)：a的b次幂
    log：自然对数
    exp：e为底指数
    random：返回0.0到1.0的随机数
    round：将double类型数据转换为long</code></pre>
<p>###BigInteger类</p>
<pre><code>说明：
    可以表示不可变的任意精度的整数，其提供所有Java的基本整数操作符的对应物，并提供java.lang.Math的所有相关方法，还提供：模运算、GCD计算、质数测试、素数生成、位操作以及一些其他操作
包:java.math    
使用：
    构造器：BigInteger(String val)，根据字符串构建BigInteger对象    </code></pre>
<p>###BigDecimal类<br>    说明：表示精度要求比较高的数字，该类支持不可变的、任意精度的有符号十进制定点数<br>    包：java.math<br>    使用：<br>        构造器：BigDecimal(double val/String val)<br>    常用方法：<br>        add：<br>        substract：</p>
<p>###字符串相关的类</p>
<pre><code>（1）string
        特征：
            a.不可被继承：String类是一个final类
            b.内部定义了final char[] value用于存储字符串数据
            c.字符串是支持序列化： String实现了Serializable接口
            d.String可以比较大小： 实现了Comparable接口
            e.不可变性： String代表不可变的字符序列
                体现：
                    1-当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值
                    2-当对现有的字符串进行链接操作时，也需要重新指定内存区域赋值
                    3-当调用replace()方法修改指定字符或字符串时，也需要重新制定内存区域赋值
            f.通过字面量直接赋值(区别于new)的方式给一个字符串复制，此时字符串值生命在方法区的字符串常量池中（字符串常量池中不会存储相同内容的字符串）
            g.通过new+构造器方式的方式直接进行实例化，其数据是存储在堆空间中开辟空间以后对应的地址值所指向的常量池
            h.常量与常量短的拼接结果在常量池，且常量池中不会存在相同内容的常量，只要其中一个是变量，结果就在堆中

        JVM中字符串常量池存放位置：
            jdk1.6（jdk 6.0 ,java 6.0）：字符串常量池存储在方法区(永久区)
            jdk1.7：字符串常量池存储在堆空间
            jdk1.8：字符串常量池存储在方法区(元空间)


        数据类型转换：
            a.String----&gt;基本数据类型、包装类之间的转换：
                调用包装类的静态方法：parseXxx(str)
            b.基本数据类型、包装类----&gt;String:
                调用String重载的valueOf(xxx)
            c.String----&gt;char[]之间的转换
                调用String的toCharArray()
            d.char[]----&gt;String：
                调用String的构造器
            e.Stirng---&gt;byte[](该过程称为编码)：
                调用String的getBytes()：该函数使用默认的字符集，进行转换
            f.byte[]----&gt;String（该过程称为解码）：
                调用String的构造器：使用默认的字符集进行解码

        常用方法：
            string inten()：要求该函 数返回值在常量池当中
            int length()：返回字符串长度
            char charAt(int index)：返回某索引的字符
            boolean isEmpty()：判断是否是空字符串
            String toLowerCase()：使用默认语言环境，将String中的所有字符为小写
            String toUpperCase()：使用默认语言环境，将String中的所有字符转换为大写
            String trim()：返回字符串的副本，忽略前导空白和尾部空白
            boolean equals(Object obj)：比较字符串内容是否相同
            boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写
            String concat(String str)：将指定字符串链接到字符串的结尾，等价于“+”
            int compareTo(String anotherString)：比较两个字符串的大小
            String subString(int beginIndex)：返回一个新的字符串，从beginIndex开始截取
            String substring(int beginIndex,int endIndex)：返回一个新字符串，它是此字符串从beginIndex截取到endIndex

            boolean endWith(String suffix)：测试此字符串是否以指定的后缀结束
            boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始
            boolean startsWith(String prefix,int toffset)：测试此字符串从指定索引开始的子字符串是否以指定字符串开始

            boolean contains(CharSequence s)：当且仅当此字符串包含指定的char值序列时，返回true
            int indexOf(String str)：返回指定字符串在此字符串中第一次出现处的索引
            int indexOf(String str,inr fromIndex)：返回指定字符串在此字符串中第一次出现处的索引，从指定的索引开始
            int lastIndexOf(String str)：返回指定字符串在此字符串中最右边出现处的索引
            int lastIndexOf(String str,int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向操作
                注：indexOf和lastIndexOf未找到，都返回-1
            替换：
                String replace(char oldChar,char newChar)：返回一个新的字符串，他是通过用newChar替换此字符串中出现的所有oldChar得到
                String replace(CharSequence target,CharSequence replacement)：使用指定的字面值替换序列替换此字符串所以匹配字面值目标序列的子字符串
                String replaceAll(String regex,String replacement)：使用给定的replacement替换此字符串所有匹配给顶的正则表达式的子字符串
                String replaceFirst(String regex,String replacement)：使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串
            匹配：
                boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式
            切片：
                String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串
                String[] split(String regex，int limut)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中 

（2）StringBuffer和StringBuilder
        与String的异同点
            a.String：不可变的字符序列，效率最低 
                内存解析:
                    底层使用char[]存储
            b.StringBuffer：可变的字符序列；线程安全的，效率低；
                内存解析：
                    底层使用char[]存储；调用构造器创建字符数组时，默认给数组扩容为16个字符，若给到指定长度，也在原数组上扩容16，但使用length()函数返回的长度不计算这16扩容，若要添加的数据底层数组盛不下，默认情况下，扩容为原来的2倍+2，同时将原有数组中的元素赋值到新的数组中，但这种操作会降低效率
            c.StringBuilder：可变的字符序列；jdk5.0新增，线程不安全的，效率高；
                内存解析：
                    底层使用char[]存储；同StringBuilder一致 

        常用方法：
            append()：提供了很多的append()方法，用于进行字符串拼接
            delete(int start,int end)：删除指定位置的内容
            replace(int start,int end,String str)：把[start,end)位置换位str
            insert(int offset,xxx)：在指定位置插入xxx
            reverse()：把当前字符序列逆转
            setCharAt(int n,char ch)：修改指定位置的字符
            注：
                append和insert时，如果原来的value数组长度不够，可扩容
                以上的方法支持方法链操作
                方法链原理</code></pre>
<hr>
<p>###集合Collections工具类</p>
<pre><code>说明：操作Map和Collection的工具类
常用方法：
    reverse(List)：反转List中元素的顺序
    shuffle(List)：对List集合元素进行随机排序
    sort(List)：根据元素的自然顺序对指定List集合元素按升序排序
    sort(List,Comparator)：根据Comparator产生的顺序对List集合元素进行排序
    Object max/min(Collection)：根据元素的自然顺序，返回给定集合的最大/最小元素
    Obeject max/min(Collection,Comparator)：根据Comparator指定的顺序，返回给定集合中最大/最小的元素
    int frequency(Collection,Object)：返回指定集合中指定元素的出现次数
    void copy(List dest,List src)：将src中的内容赋值到dest中
        注意：
            if( dest.size()&lt;src.size() )
                &lt;!-- 抛异常 --&gt;
            else
                复制成功
    boolean replace(List list,Object oldVal,Object newVal)：使用新值替换List对象

    注：在该类当中有多个synchronizedXxx()方法，该方法可以将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</code></pre>
<hr>
<p>###日常使用</p>
<p>（1）Eclipse快捷键(可到preference当中的keys进行修改)</p>
<pre><code>（1）补全代码的声明：alt + /
（2）快速修复：ctrl + 1
（3）批量导包：ctrl + shift + o
（4）多行注释：ctrl + shift + /（取消使用 \ ）
（5）复制指定行的代码：ctrl + alt +down 或 ctrl + alt + up
（6）删除指定行的代码：ctrl + d
（7）上下移动代码：alt + up 或 alt + down
（8）切换到下一行代码空位：shift + enter（上一行则 + ctrl）
（9）查看源码：ctrl + 选中指定结构 或 ctrl + shift + t
（10）退回到前一个编辑页面：alt + left（下一个编辑界面则是alt + right）
（11）光标选中指定的类，查看继承树结构：ctrl + t
（12）撤销与反撤销：ctrl + z/y
（13）格式化代码：ctrl + shift +f
（14）在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o
（15）批量修改指定的变量名、方法名、类名等：alt + shift + r
（16）选中结构的大小写的切换：ctrl + shift + x/y
（17）调出生成getter/setter/构造器等结构：alt + shift + s
（18）显示当前选择资源（工程 或 文件）的属性：alt + enter
（19）快速查找.参照选中的word快速定位到下一个：ctrl + k
（20）关闭所有窗口：ctrl + shift + w
（21）查看指定的结构使用过的地方：ctrl + alt + g
（22）查找与替换：ctrl + f
（23）最大化当前的View：ctrl + m
（24）直接定位到当前行的首位：home
（25）直接定位到当前行的末位：end</code></pre>
<p>（2）JUnit单元测试</p>
<pre><code>使用：
    a.选中当当前工程-右键选择：bulid path - add libraries -JUnit 4 - 下一步
    b.创建java类，进行单元测试，要求的Java类要求：1.此类权限为public 2.此类提供公共的无参构造函数
    c.此类中声明单元测试方法：此时的单元测试方法权限是public，没有返回值，没有形参
    d.此单元测试方法需要声明注解：@Test，并在单元测试类中导入：org.junit.Test包 </code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/06/Java/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" data-id="ckp6d1bd5000htgubhsn0c201" data-title="Java类库与基本操作" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/28/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java8新特性
        
      </div>
    </a>
  
  
    <a href="/2021/03/27/Java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java高级编程</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/27/Other/README/">计算机网络——网络层</a>
          </li>
        
          <li>
            <a href="/2021/05/26/ComputerNetWork/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%945%E4%BC%A0%E8%BE%93%E5%B1%82/">计算机网络——传输层</a>
          </li>
        
          <li>
            <a href="/2021/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%944%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络——网络层</a>
          </li>
        
          <li>
            <a href="/2021/05/20/ComputerNetWork/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%944%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络——网络层</a>
          </li>
        
          <li>
            <a href="/2021/05/14/ComputerNetWork/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%943%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">计算机网络——数据链路层</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>