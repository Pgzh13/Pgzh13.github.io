<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>操作系统——进程管理 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="#操作系统##进程管理###进程 定义（体现的是动态性）：     --进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位     --进程是程序的一次执行过程     --进程是一个程序及其数据在处理及上顺序执行时所发生的活动     --进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位     --进程是分配系统资源的单位（包括内存地址空间">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统——进程管理">
<meta property="og:url" content="http://example.com/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="#操作系统##进程管理###进程 定义（体现的是动态性）：     --进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位     --进程是程序的一次执行过程     --进程是一个程序及其数据在处理及上顺序执行时所发生的活动     --进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位     --进程是分配系统资源的单位（包括内存地址空间">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-05-07T08:18:57.033Z">
<meta property="article:modified_time" content="2021-05-07T08:18:57.034Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-操作系统—进程管理" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="article-date">
  <time class="dt-published" datetime="2021-05-07T08:18:57.033Z" itemprop="datePublished">2021-05-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      操作系统——进程管理
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="操作系统"><a href="#操作系统" class="headerlink" title="#操作系统"></a>#操作系统</h2><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="##进程管理"></a>##进程管理</h2><p>###进程</p>
<pre><code>定义（体现的是动态性）：
    --进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
    --进程是程序的一次执行过程
    --进程是一个程序及其数据在处理及上顺序执行时所发生的活动
    --进程是具有独立功能的程序在数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位
    --进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立

组成： 程序段、数据段、PCB(进程控制块，其是进程存在的唯一标志)三部分组成了进程实体(进程映像)，一般情况下，就把进程实体简称为进程；进程实体是静态的，进程是动态的 

 组织方式：
     （1）链接方式：
         --按照进程状态将PCB分为多个队列，操作系统持有指向个个队列的指针
     （2）索引方式：
         --根据进程状态的不同，建立几张索引表，操作系统持有指向各个索引表的指针

 特征：
     （1）动态性：进程最基本的特征
     （2）并发性
     （3）独立性：晋城市系统进行资源分配、调度的独立单位
     （4）异步性：各进程以不可预知的速度向前推进，可能导致运行结果的不确定性
     （5）结构性

 进程的状态
     （1）运行态(Running)：占有CPU，并在CPU上运行，单核处理机环境下，每一时刻最多只有一个进程处于运行态
     （2）就绪态(Ready)：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行；进程已经拥有了除处理及之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行
     （3）阻塞态(Waiting/Blocked，又称等待态)：因等待某一件事而暂时不能运行
     （4）创建态(New，新建态)：进程正在被创建，操作系统为进程分配资源、初始化PCB
     （5）终止态(Terminated，结束态)：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

 进程控制：
     （1）创建
     （2）终止
     （3）阻塞
     （4）唤醒
     （5）切换

 进程通信：
     说明：是指进程之间的信息交换
     （1）共享存储：
         --基于数据结构的共享：速度慢，限制多，是一种低级通信方式
         --基于存储区的共享：速度更快，是一种高级通信方式
         ps：两个进程对共享空间的访问必须是互斥的（互斥操作通过操作系统提供的工具实现）

     （2）消息传递
         说明：进程间的数据交换以格式化的消息为单位；进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换
         --直接通信方式：消息直接挂到接收进程的消息缓冲队列上
         --间接通信方式（信箱通信方式）：消息要先发送到中间实体(信箱)中

     （3）管道通信：
             --“管道”是指用于连接读写进程的一个共享文件(pipe文件)，其实就是在内存中开辟一个大小固定的缓冲区
             --管道只能采用半双工通信，某一时间段内只能实现单向的传输；如果需要实现双向同时通信，则需要设置两个管道
             --各进程要互斥的访问管道
             --数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待都进程将数据取走。当都进程将数据全部取走后，管道变空，此时读进程的read()系     统调用统调用统的调用将被阻塞
             --数据一旦被读出，就从管道中被抛弃，意味着读进程最多只能有一个，否则可能会有读错数据的情况</code></pre>
<hr>
<p>###线程</p>
<pre><code>定义：
    --线程是一个基本的CPU执行单元，也是程序执行流的最小单元
    --线程是程序执行流的最小单元
    --线程可以理解为“轻量级进进程”

与进程的区别：
    --进程是资源分配的基本单位，线程是调度的基本单位

属性：
    --线程是处理机调度的单位
    --多CPU计算机中，各个线程可以占用不同的CPU
    --每个线程都有一个线程ID、线程控制块(TCB)
    --线程几乎不拥有系统资源
    --统一进程的不同线程间共享进程的资源
    --由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
    --同一进程中的线程切换，不会引起进程切换
    --不同进程中的线程切换，会引起进程切换
    --切换同进程内的线程，系统开销很小；切换进程，系统开销较大

实现方式：

    --用户级线程：
        （1）说明：
            --由应用程序通过线程库实现，所有线程管理工作都有应用程序负责(包括线程切换)
            --用户级线程中，线程切换在用户态下即可完成，无需操作系统干预
            --用户级线程对用户不透明，对操作系统透明

    --内核级线程：
        （1）说明：
            --内核级线程的管理工作由操作系统内核完成
            --内核级线程的切换需要在核心态下才能完成
            --内核级线程对用户透明，对操作系统不透明
            --内核线程是处理机分配的单位

多线程模型：

    --多对一模型：多用户对单内核，每个用户进程只对应一个内核级线程
        advantage：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
        disadvantage：当一个用户线程被阻塞后，整个进程都会被阻塞，并发度不高，多个线程不可在多核处理机上并行运行

    --一对一模型：单用户对单内核
        advantage：当一个线程阻塞后，别的线程还可以继续执行，并发能力强；多线程可在多核处理机上并发执行
        disadvantage：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大

    --多对多模型：n用户对m内核，每个用户进程对应m个内核级线程
        action：克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的特点</code></pre>
<hr>
<p>###处理机调度：</p>
<pre><code>说明：处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理及分配给它运行，以实现进程的并发执行
分层：
    （1）高级调度(作业调度)：主要是指调入的问题
        --按一定的原则从外存上处于后备队列的作业中挑选一个(或多个)作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB)，以使得其获得竞争处理机的权力
        --高级调度是辅存与内存之间的调度，作业调入时会建立相应的PCB，作业调出时才撤销PCB

    （2）中级调度(内存调度)：
        --将暂时不能运行的进程调至外存等待，等它重新具备了运行条件且内存稍有空闲时，再重新调入内存；提高内存利用率和系统吞吐量
        --暂时调到外存等待的进程状态为挂起状态，PCB并不会一起调到外存，而是会常驻内存，PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统同过内存中的P     CB来保持对各个进程的监控、管理；被挂起的进程PCB会被放到挂起队列中
            &lt;!-- 
                挂起状态：指的是暂时调到外存等待的进程状态，为减轻系统负载，提高资源利用率
                    分类：
                        --就绪挂起
                        --阻塞挂起 
                    注意:
                        --&quot;挂起&quot;和&quot;阻塞&quot;两种状态都是暂时不能获得CPU的服务,但挂起状态是将进程映像调到外存去了,而阻塞态下进程映像还在内存中
            --&gt;

    （3）低级调度(进程调度)：
        --说明：
            （1）其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它
            （2）进程调度是操作系统中最基本的一种调度

        --过程：
            （1）队员来运行进程的各种数据的保存
            （2）对新的进程各种数据的恢复

        --调度时机：
            （1）需要进行进程调度和切换：
                --当前运行进程主动放弃处理机：
                    a.进程正常终止
                    b.运行过程中发生异常而终止
                    c.进程主动请求阻塞(如 等待I/O)
                --当前运行的进程被动放弃处理机：
                    a.分配给进程的时间片用完
                    b.有更紧急的事需要处理(如I/O中断)
                    c.有更高优先级的进程进入就绪队列
            （2）不能进行进程调度与切换
                --在处理中断过程中。
                --进程在操作系统内核程序临界区中
                    &lt;!--
                        临界资源：一个时间段内只允许一个进程使用的资源，各进程需要互斥地访问临界资源
                        临界区：访问临界资源的那段代码
                      --&gt;
                --在原子操作过程中

        --调度方式：
            （1）非剥夺调度方式(非抢占方式)：只允许进程主动放弃处理机
                特点：实现简单，系统开销小，但无法处理紧急任务；适合于早期的批处理系统
            （2）剥夺调度方式(抢占方式):允许进程被动放弃处理机
                特点：可以优先处理更紧急的进程，也可以实现让各进程按时间片轮流执行的功能(通过时钟中断)；适合于分时操作系统、实时操作系统

调度指标：
    （1）CPU利用率：指CPU“忙碌”的时间占总时间的比例
    （2）系统吞吐量：单位时间内完成作业的数量
    （3）周转时间：是指从作业被提交给系统开始，到作业完成为止的这段时间间隔
    （4）等待时间：指进程/作业处于等处理机状态事件之和
    （5）响应时间：只从用户提交请求到首次产生相应所用的时间

调度算法：
    （1）先来先服务(FCFS)
            --规则：按照作业/进程到达的先后顺序进行服务
            --使用：
                a.用于作业调度时，考虑的是哪个作业先到达后备队列
                b.用于进程调度时，考虑的是哪个进程先到达就绪队列
            --特性：
                a.非抢占式算法
                b.公平，算法实现简单
                c.对长作业有利，对短作业不利

    （2）短作业优先(SJF)
            --规则：最短的作业/进程优先得到服务（是指要求服务时间最短）
            --使用：既可用于作业调度，也可用于进程调度
            --特性：
                a.SJF和SPF(短进程优先算法)是非抢占式算法，而SRTM(最短剩余时间优先算法)是抢占式算法
                b.“最短的”平均等待时间、平均周转时间
                c.不公平，作业/进程的运行时间是由用户提供的，并不一定真是，不一定能做到真正的短作业优先
                d.会导致饥饿现象，如果一直得不到服务，则称为“饿死 ”

    （3）高响应比优先(HRRN)
            --规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务
                &lt;!--
                    响应比 = (等待时间+要求服务时间)/要求服务时间 
                 --&gt;
            --使用：既可以用于作业调度,也可以用于进程调度 
            --特性：
                a.非抢占式算法
                b.综合考虑了等待时间和运行时间(要求服务时间);等待时间相同时,要求服务时间短的优先;要求服务时间相同时,等待时间长的优先 

    （4）时间片轮转算法(RR)
            --规则：按照各进程到达就绪队列的顺序，轮转让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队；如果两个进程在同一时刻到达，则默认新到达的进程先进就绪队列
            --使用：用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)
            --特性：
                a.抢占式算法；由时钟装置发出时钟中断来通知CPU时间片已到
                b.公平且响应快，适用于分时操作系统
                c.由于高频率的进程切换，因此有一定开销，不区分任务的紧急程度

    （5）优先级调度算法
            --规则：没个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程
            --使用：既可以用于作业调度，也可以用于进程调度
            --特性:
                a.具有抢占式和非抢占式
                b.用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各个作业/进程的偏好程度
                c.若源源不断地有高优先级进程到来，则可能导致饥饿

    （6）多级反馈队列调度算法
            --规则：
                a.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
                b.新进程到达时先进入第一级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级地队列，则重新放回该队列队尾
                c.只有第k级队列为空时，才会为k+1级队头地进程分配时间
                d.对各类进程相对公平(FSFC优点)；每个新到达地进程都可以很快得到响应(RR优点)；短进程都只用较少的时间就可完成(SPF优点)；不必实现估计进程的运行时间(避免用户作假)；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程(拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O进程就可以保持较高优先级)
                e.可能会产生饥饿现象</code></pre>
<hr>
<p>###进程同步和互斥</p>
<pre><code>进程同步：
    （1）说明：要让各并发进程按要求有序地推进
进程互斥：
    （1）说明：指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待，当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源
    （2）过程：
        --进入区：负责检查是否可以进入临界区，若可以，则应设置正在访问临界资源的标志，以阻止其他进程同时进入临界区
        --临界区：访问临界资源的代码
        --退出区：负责解除正在访问临界资源的标志
        --剩余区：做其他处理
        注意：
            进入去和退出区是负责实现互斥的代码段

    （3）原则：
        --空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
        --忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待
        --有限等待：对请求访问的进程，应保证能在有限的时间内进入临界区(保证不会饥饿)
        --让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待

    （4）软件实现方法：
        --单标志法：
            a.思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程进入临界区的权限只能被另一个进程赋予
        --双标志先检查法：
            a.思想：色织一个布尔型数组flag[]，数组中各个元素用来标记个进程想进入临界区的医院。每个进程在进入临界区之前先检查当前有没有别的想进入临界区，若没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区
            b.缺点：违反“忙则等待”原则
        --双标志后检查法：
            a.思想：先上锁后检查
            b.缺点：违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象
        --Peterson算法：
            a.思想：如果双方都争着进入临界区，则主动让对方先使用临界区
            b.缺点：未遵循让权等待

    （5）硬件实现方法：
        --中断屏蔽方法：
            a.思想：利用“开/关中断指令”实现（与原语的实现思想相同）
            b.过程：
                --关中断：关中断后即不允许当前进程被中断，也必然不会发生进程切换
                --临界区
                --开中断：直到而当前进程访问完临界区，在执行开中断指令，才有可能有别的进程上处理机并访问临界区
            c.优缺点：
                --简单、高效
                --不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)

        --TestAndSet指令(TestAndSetLock指令/TS指令)：
            a.思想：TSL指令是用硬件实现的，执行的过程不允许被中断
            b.优缺点：
                --实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
                --不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”

        --Swap指令(Exchange指令/XCHG指令)：
            a.思想：Swap指令是用硬件实现的，执行的过程不允许被中断
            b.优缺点：
                --实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
                --不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”</code></pre>
<hr>
<p>###信号量机制</p>
<pre><code>说明：进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步
    &lt;!-- 信号量：用来表示系统中某种资源的数量 --&gt;

使用：通过wait(S)和signal(S)原语，也就是PV操作，实现系统资源的“申请”和“释放”

分类：
    --整型信号量：用来表示系统中某种资源的数量 
        使用：通过该信号量表示系统中的资源，当所需资源大于0，则获取资源，当资源小于等于0，则循环等待
        缺点：存在“忙等”问题
    --记录型信号量：用记录型数据结构表示的信号量
        使用：在记录型数据结构当中有着等待队列，每次进行P操作时，对所需资源数-1，若所需资源数小于0，则将其阻塞，加入到等待队列当中（运行态-&gt;阻塞态）；在执行释放操作时，对所需资源数加1，若当前所需资源数仍然小于等于0，说明当前等待队列中还有阻塞进程，则分配资源给该进程（阻塞态-&gt;就绪态）

注意：实现互斥的P操作一定要在实现同步的P操作之后</code></pre>
<hr>
<p>###管程</p>
<pre><code>说明：是一种特殊的软件模块
组成：
    （1）局部于管程的共享数据结构说明
    （2）对该数据结构进行操作的一组过程
    （3）对局部于管程的共享数据设置初始值的语句
    （4）管程有一个名字

基本特征：
    （1）局部于管程的数据只能被局部于管程的过程访问
    （2）一个进程只有通过调用管程内的过程才能进入管程访问共享数据
    （3）每次仅允许一个进程在管程内执行某个内部过程（这种互斥特性是由编译器负责是实现的）
    （4）可在管程中设置条件变量及等待/唤醒操作以解决同步问题，可以让一个进程或线程在条件变量上等待(此时，该进程应先释放管程的使用权)，可以通过唤醒操作将等待在条件变量上的线程或进程唤醒</code></pre>
<hr>
<p>###死锁</p>
<pre><code>说明：在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象

条件：
    （1）互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁
    （2）不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放
    （3）请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放
    （4）循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程所获得的资源同时被下一个进程所请求
    注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁

处理：
    （1）预防死锁：破坏死锁产生的四个必要条件中的一个或几个
            --破坏互斥条件：将互斥使用的资源改造为允许共享使用，如SPOOLing技术将打印机改为共享设备
                缺点：并不是所有的资源都可以改造成可共享使用的资源

            --破坏不剥夺条件：
                缺点：
                    a.实现起来比较复杂
                    b.释放获得的资源可能造成前一阶段工作的失效，因此这种方法一般只适用于易保存和恢复状态的资源，如CPU
                    c.反复地申请和释放资源会增加系统开销，降低吞吐量
                    d.可能会导致饥饿现象

            --破坏请求和保持条件：采用静态分配方法；即进程在运行前一次申请完它所需要地全部资源，在它地资源未满足前，不让其投入运行，一旦投入运行后，指定资源就一直归其使用，该进程就不会在请求别的任何资源
                缺点：
                    a.可能会造成严重的资源浪费，资源利用率极低
                    b.可能导致某些进程饥饿

            --破坏循环等待条件：可采用顺序资源分配法；给系统中的资源编号，规定每个进程必须按编号递增地顺序请求资源，同类资源一次申请完
                缺点：
                    a.不方便增加新的设备，因为可能需要重新分配所有编号
                    b.进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费
                    c.必须按规定次序申请资源，用户编程麻烦

    （2）避免死锁：如银行家算法
            &lt;!-- 安全状态:指如果系统按照这种序列分配资源,则每个进程都能顺利完成;只要找出一个安全序列,系统就是安全状态;如果系统处于安全状态,就一定不会发生死锁;如果处于不安全状态,就可能发生死锁 --&gt;
            银行家算法:
                a.思想:在进程提出资源申请时,先预判此次分配是否会导致系统进入不安全状态,如果会进入不安全状态,就暂时不答应这次的请求,让该进程先阻塞等待
                b.步骤:
                    1-检查此次申请是否超过了之前声明地最大需求数
                    2-检查此时系统剩余地可用资源是否还能满足这次请求
                    3-试探着分配,更改各数据结构
                    4-用安全性算法检查此次分配是否会导致系统进入不安全状态
                    &lt;!-- 安全性算法:检查当前地剩余可用资源是否能满足某个进程的最大需求,如果可以,就把该进程加入安全序列,并把该进程持有的资源全部回收,不断重复 --&gt;

    （3）死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁
            --死锁的检测:
                a.条件:
                    1-用某种数据结构来保存资源的请求和分配的信息
                    2-提供一种算法,利用上述信息来检测系统是否已进入死锁状态
                b.资源分配图:
                    1-结点:进程结点\资源结点
                    2-边:
                        --请求边:进程结点--&gt;资源结点
                        --分配边:资源结点--&gt;进程结点
                c.死锁检测算法:
                    1-方法:依次消除与不阻塞进程相连的边,直到无边可消
                        &lt;!-- 
                            所谓不阻塞进程是指申请的资源数还足够的进程 
                            --&gt;
                    2-结果:用死锁检测算法花间资源分配图后,还连着那些进程就是死锁进程

            --死锁的解除:
                a.资源剥夺法:挂起(暂时放到外存上)某些死锁进程,并抢占它的资源,将这些资源分配给其他的死锁进程,但是应防止被挂起的进程长时间得不到资源而饥饿
                b.撤销进程法(终止进程法):强制撤销部分\甚至全部死锁进程,并剥夺这些进程的资源
                    优缺点:实现简单,但是付出的代价可能会很大
                c.进程回退法:让一个或多个死锁进程回退到足迹避免死锁的底部,这就要求系统要记录进程的历史信息,设置还原点</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" data-id="ckoo0iqvd000el8ubafte0rrf" data-title="操作系统——进程管理" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          操作系统——文件管理
        
      </div>
    </a>
  
  
    <a href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">操作系统——内存管理</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E7%89%A9%E7%90%86%E5%B1%82/">计算机网络——物理层</a>
          </li>
        
          <li>
            <a href="/2021/05/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%94%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">计算机网络</a>
          </li>
        
          <li>
            <a href="/2021/05/11/java%E7%BC%96%E7%A8%8B%E6%9D%82%E8%AE%B0/">Java编程杂记</a>
          </li>
        
          <li>
            <a href="/2021/05/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86/">操作系统——设备管理</a>
          </li>
        
          <li>
            <a href="/2021/05/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/">操作系统——文件管理</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>