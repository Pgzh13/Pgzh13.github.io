<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Java高级编程 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="#高级编程##基础知识  1.进程    定义：是程序依次执行过程，或正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程—–生命周期    内容：        （1）进程作为资源分配的单位，系统在运行时回味每个进程分配不同的内存区域  2.线程 定义：是一个程序内部的一条执行路径  内容：     （1）线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器，线程切换">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高级编程">
<meta property="og:url" content="http://example.com/2021/03/27/Java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="#高级编程##基础知识  1.进程    定义：是程序依次执行过程，或正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程—–生命周期    内容：        （1）进程作为资源分配的单位，系统在运行时回味每个进程分配不同的内存区域  2.线程 定义：是一个程序内部的一条执行路径  内容：     （1）线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器，线程切换">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-27T14:37:01.185Z">
<meta property="article:modified_time" content="2021-05-04T06:37:00.900Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Java/java高级编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/27/Java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-03-27T14:37:01.185Z" itemprop="datePublished">2021-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Java高级编程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="高级编程"><a href="#高级编程" class="headerlink" title="#高级编程"></a>#高级编程</h2><p>##基础知识 </p>
<p>1.进程<br>    定义：是程序依次执行过程，或正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程—–生命周期<br>    内容：<br>        （1）进程作为资源分配的单位，系统在运行时回味每个进程分配不同的内存区域 </p>
<p>2.线程</p>
<pre><code>定义：是一个程序内部的一条执行路径

内容：
    （1）线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器，线程切换的开销小
    （2）一个进程中的多个线程共享相同的内存单元/内存地址空间-&gt;它们从同一个堆中分配对象，可以访问相同的变量和对象


生命周期：
    ![avatar](D:/ComputerUse/blog/img/live.jpg)

多线程的创建：
    （1）方式一：继承于Thread类
        使用：
            a.创建一个Thread类的子类
            b.重写Thread类的run()----&gt;将此线程执行的操作声明在run()中
            c.创建Thread类的子类对象
            d.通过此对象调用start()：该函数会启动当前线程，并调用当前线程的run()

    （2）方式二：实现Runnable接口------&gt;该方法的实现没有类单继承的局限性，更适合用来处理多个线程有共享数据的情况
        使用：
            a.创建一个实现了Runnable接口的类
            b.实现类去实现Runnable中的抽象方法：run()
            c.创建实现类的对象
            d.将此对象作为参数传递到Thread类中的构造器中，创建Thread类的对象
            e.通过Thread类的对象调用start()：启动线程，然后调用当前线程的run()-----&gt;调用了Runnable类型的target的run()

    （3）方式三：实现Callable接口
        使用：
            a.创建一个实现Callable的实现类
            b.实现call方法，将此线程需要执行的操作声明在call()中
            c.创建Callable接口实现类的对象
            d.将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象
            e.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
            f.获取Callable中Call方法中的返回值------&gt;可以通过get()得到返回值
        注：
            a.其call()方法，可以有返回值
            b.方法可以抛出异常，被外面的操作捕获，获取异常信息 
            c.支持泛型的返回值
            d.需要借助FutureTask类

    （4）方式四：使用线程池
            作用：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中，可以避免频繁创建销毁、实现重复里哟
            优点：提高响应速度、降低资源消耗、便于线程管理
            使用：
                a.提供指定线程数量的线程池：ExexcutorService service = Exectors.newFixedThreadPool( &lt;!-- 线程数量 --&gt; )
                b.执行指定线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象
                    service.excute( &lt;!-- 实现Runnable接口类的对象 --&gt; )
                    service.submit( &lt;!-- 实现Callable接口类 的对象 --&gt; )
                c.关闭线程池：service.shutdown()
            注：可以通过强制类型转换的方式，将ExecutorService转换成ThreadPoolExecutor类型对象，对线程池的属性进行设置


Thread类常见的方法：
    start()：启动线程，并执行run()方法
    run()：线程在被调度时执行的操作
    String getName()：返回线程的名称
    void setName(String name)：设置该线程的名称
    static Thread currentThread()：返回当前线程，在Thread子类中就是this，通常用于主线程和Runnable实现类
    yeild()：释放当前CPU的执行权
    join()：在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到join的线程执行完，线程a才结束阻塞状态
    stop()：强制线程生命周期结束，不推荐使用
    boolean isAlive()：返回boolean，判断线程是否还活着
    sleep(long millitime)：让当前线程阻塞指定的millitime毫秒
    getPriority()：返回线程优先级
    setPriority(int newPriority)：改变线程的优先级

解决线程的安全问题
    同步机制：
        （1）方式一：同步代码块
                使用：
                    synchronized(同步监视器)&#123;
                        &lt;!-- 需要被同步的代码(即操作共享数据的代码) --&gt;
                    &#125;
                注：
                    a.同步监视器：俗称，“锁”。任何一个类的对象，都可以充当锁。在以上方法中，多个线程必须要共用同一把锁
                    b.在实现Runnable接口创建多线程方式中，可以考虑使用this充当同步监视器

        （2）方式二：同步方法
                使用：通过 synchronized+方法 的来使用
                注：
                    a.同步方法仍然设计到同步监视器，只是不需要我们显式的声明
                    b.非静态的同步方法的同步监视器是this，静态的同步方法的同步监视器是当前类的本身

    Lock锁：
        使用：通过生成ReentrantLock类的对象，手动的启动同步(Lock())，同时结束同步也需要手动的实现(unlock())
        注：
            a.Lock是显式锁，需要进行手动的开启和关闭，synchronized是隐式锁，除了作用域自动释放
            b.Lock只有代码块锁，synchronized有代码块锁和方法所
            c.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性

死锁：
    定义：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己所需要的同步资源，就形成了线程的死锁。出现死锁后，不会出现异常、提示，只是所有的线程都处于阻塞状态，无法继续

线程通信方法：
    方法：
        wait()：执行此方法，当前线程就进入阻塞状态
        notify()：执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，会优先唤醒优先级高的线程
        notifyAll()：执行此方法，会唤醒所有被wait的一个线程
    注：
        a.以上三个方法必须使用在同步代码块或同步方法中，同时其调用者必须是同步代码块或同步方法当中的同步监视器，否则会出现IllegalMonitorStateException异常
        b.上面三个方法是定义在java.lang.Object类中</code></pre>
<p>3.并行与并发<br>    定义：并行指的是多个CPU同时执行多个任务，并发指的是一个CPU(采用时间片)同时执行多个任务</p>
<hr>
<p>###枚举类与注解 </p>
<p>1.枚举类<br>    包：定义的枚举类默认继承于java.lang.Enum<br>    说明：<br>        a.类的对象只有有限个，确定的。当需要定义一组常量时，强烈建议使用枚举类<br>        b.如果枚举类当中只有一个对象，则可以作为单例模式的实现方式<br>        c.定义枚举类：<br>            （1）jdk5.0之前，自定义枚举类<br>                1-声明对象的属性权限为：private final<br>                2-私有化构造器，并给对象属性私有化<br>                3-提供当前枚举类的多个对象</p>
<pre><code>        （2）jdk5.0，可以使用enum关键字定义枚举类
            1-提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束
    d.使用enum关键字定义的枚举类实现接口：当我们需要在调用指定枚举类时进行不同的操作，则在枚举对象后进行重写

常用方法：
    valueOf()：返回枚举类型的对象数组，该方法可以很方便的遍历所有的枚举值。也可以给其赋值一个字符串，可以索引指定名字的枚举对象，要求字符串必须是枚举对象的&quot;名字&quot;，否则会运行异常
    toString()：返回当前枚举对象常量名称</code></pre>
<p>2.注解<br>    说明：<br>        是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。可以用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在Annotation的”name=value”对中</p>
<pre><code>使用示例：
    a.使用Annotation时要在前面增加@符号，并把该Annotation当成一个修饰符使用
    b.在编译时进行格式检查（JDK内置的三个基本注解Override\Deprecated\SuppressWarnings）
    c.跟踪代码依赖性，实现替代配置文件功能
    d.spring框架中关于“事务”的管理

自定义注解：自定义注解必须配上注解的信息处理流程(使用反射)才有意义
    a.定义新的Annotation类型使用@interface关键字
    b.内部成员，通常使用value表示，可以指定成员的默认值，使用default定义。如果自定义注解没有成员，表示是一个标识作用。

元注解：    
    说明：用于修饰其他Annotation定义，对现有的注解进行解释说明的注解
    使用：
        Retention：只能用于修饰一个Annotation定义，用于指定该Annotation的生命周期---》SOURCE\CLASS(默认行为)\RUNTIME(能通过反射)
        Target：用于指定被修饰的Annotation能用于修饰哪些程序元素
        Documented：用于指定那个被盖院Annotation修饰的Annotation类将被javadoc工具提取成文档。默认情况下，javadoc是不包括注解的
        Inherited：被它修饰的Annotation将具有继承性

jdk8中注解的新特性
    可重复注解：@Repeatable
    类型注解：
        ElementType.TYPE_PARAMETER：表示该注解能写在类型变量的声明语句中（如：泛型声明）
        ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中</code></pre>
<hr>
<p>###java集合<br>1.Collection接口：单列数据，定义了存区一组对象的方法的集合</p>
<pre><code>List：元素有序、可重复集合
    （1）ArrayList：
            作为List接口的主要实现类，线程不安全的，效率高。底层使用了Object[]存储
            源码说明：
                jdk7情况下：
                    使用空参的构造器，底层创建了长度为10的Objectp[]数组elementData，如果某次添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原    来的容量的1.5倍，同时将原有数组中的数据复制到新的数组中
                jdk8中：
                    使用空参构造器，底层创建了Object[] elementData初始化为&#123;&#125;，直到第一次调用add()时，底层才创建了长度为10的数组，后续的添加扩容操作与上个版本无异
    （2）LinkedList：
            对于频繁的插入、删除操作，使用此类效率比ArrayList效率高。底层使用双向链表存储 
    （3）Vector：
            作为List接口的古老实现类，线程不安全的，效率低。底层使用了Object[]存储
    （4）常用方法：
                &lt;!-- https://www.cnblogs.com/gaomanito/p/8979076.html --&gt;
            get：获取指定index位置的元素
            addAll(int index,Collection eles)：从index位置开始将eles中的所有元素添加进来
            indexOf(Object obj)：返回obj在集合中首次出现的位置
            set(int index,Object eles)：设置指定index位置的元素为eles
            List subList(int fromIndex,int toIndex)：返回从fromIndex到toIndex位置的子集合
            Object remove(int index)：移除指定index位置阿元素，并返回此元素
            toArray()：将集合转换为数组
            asList()：将数组转换为集合

Set：元素无序，不可重复的集合(注：无序性不等于随机性，存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的)
    （1）HashSet：底层源码使用的时HashMap
            作为Set接口的主要实现类；线程不安全；可以存储null值
            注意：元素a与已经存在指定索引位置上数据以链表的方式存储，在jdk7中，元素a存放到数组中，指向原来的元素，在jdk8中，原来的元素在数组，只想元素a（七上八下准则）
    （2）LinkedHashSet：
            作为HashSet的子类；在添加数据的同时，每个数据还维护了两个引用，记录此数据的前后数据；遍历器内部数据时，可以按照添加的顺序遍历；对于频繁的遍历操作，LinkedHashSet效率高于HashSet5
    上述要求：
        1-向Set中添加的数据，其所在的类一定要重写hashCode()和equals
        2-重写的hashCode()和equals尽可能保持一致性：相等的对象必须具有相等的散列码

    （3）TreeSet：
            可以按照添加对象的指定属性进行排序；在底层当中采用红黑树的存储结构；有序，查询速度比List快；

    上述要求：
        1-向其中添加数据，要求是相同类的对象
        2-在自然排序当中，其比较数据是否相同的方法是通过compareTo函数是否返回0，定制排序中，则使用的是compare函数，不再是通过equals </code></pre>
<p>2.Map接口：双列数据，包存具有映射关系”key-value对”的集合</p>
<pre><code>说明：
    1-Map中的key：无序的、不可重复的，使用Set存储所有的key------&gt;key所在的类要重写equals()和hashCode()（以HashMap为例）
    2-Map中的value：无序的、可重复的，使用Collection存储所有的value-----&gt;value所在的类要重写equals()  
    3-一个键值对&quot;key-value&quot;构成了一个Entry对象
    4-Map中的entry：无序的、不可重复的，使用Set存储所有的entry（对于map内部值的调用，可以通过内部接口Map.Entry的getKey和getValue来查看）
    5-负载因子：用于表示哈希表中元素填满的程度
        a.其大小决定了HashMap的数据密度
        b.负载因子越大，密度越大，发生碰撞的机率越高，数组中的链表越长
        c.负载因子越小，就越容易促发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短
        d.考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数

（1）HashMap
        说明：作为Map中的主要实现类；线程不安全的，效率高；可以存储null的key和value；在jdk7以及之前底层结构为数组+链表，在jdk7之后加入了红黑树
        子类：
            LinkedHashMap（在原有的HashMap底层结构基础上，添加了一堆指针，指向前后元素）
        底层实现原理：
            1-实例化：
                jdk7：底层创建了长度为16的一维数组Entry[] table
                jdk8：底层没有创建一个长度为16的数组，直到首次调用put()方法才创建长度为16的数组，而且其底层数组为Node[]，并非Entry[]
            2-存放数据过程：
                jdk7：调用key所在类的hashCode()计算key哈希值，得到在Entry数组中的存放位置
                    情况：
                        if(位置为空)
                            &lt;!-- 添加成功 --&gt;
                        else
                            if(此位置上所链数据的哈希值是否与hashCode(key)相同)
                                if(key.equals(obj))
                                    key-&gt;value = obj-&gt;value
                                else
                                    &lt;!-- 添加成功 --&gt;
                            else
                                &lt;!-- 添加成功 --&gt;
                        注意：如果原位置上有数据，之后添加进去的数据是以链表的形式与原数据链接
                jdk8：
                    与jdk7的区别，存储结构加入了红黑树（当数组的某一个索引位置上的元素以链表形式存在的数据个数&gt;8且当前数组的长度&gt;64时，此时此索引位置上的所有数据改为使用红黑树存储）
            3-扩容方式：扩容为原来容量的两倍，将原有的数据复制过来


                功能：保证在遍历map元素时，可以添加的顺序实现遍历；对于频繁的遍历操作，此类执行效率高于HashMap
（2）TreeMap
        功能：保证按照添加的key-value对进行排序，实现排序遍历；此时考虑key的自然排序或定制排序
        说明：底层使用红黑树
（3）Hashtable
        说明：作为古老的实现类；线程安全，效率低；不能够存储null的key或value 
        子类：
            Properties
                功能：常用来处理配置文件，key和value都是String类型

（4）常用方法：
        Obeject put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中
        void putAll(Map m)：将m中的所有key-value存放到当前的map中
        Set keySet()：返回所有key构成的Set集合
        Collection values()：返回所有value构成的Collection集合
        Set entrySet()：返回所有key-value对构成的Set集合 </code></pre>
<hr>
<p>###泛型</p>
<pre><code>说明：jdk5.0新增的特性；允许在定义类、接口时通过一个标识表示类中某个属性的类型或者时某个方法的返回值及参数类型，这个类型将在使用时确定
使用：
    1-集合接口或集合类在jdk5.0时都修改为泛型的结构
    2-在实例化集合类时，可以指明具体的泛型类型
    3-指明完以后，在集合类或接口中凡是定义类或接口时，内部结构使用到类的泛型的位置，都指定为你实例化的泛型类型
    4-泛型的类型必须是类，不能是基本数据类型；需要用到基本数据类型的位置，拿包装类替换
    5-如果实例化时，没有指明泛型的类型，默认类型为java.lang.Object类型 
    6-自定义泛型类、接口
        说明：
            a.如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object,但不等价于Object
            b.父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型。如果子类在继承带泛型的父类时，指明了泛型类型，则实例化子类对象时，不再需要指明泛型
            c.泛型类可能有多个参数，此时应将多个参数一起放在尖括号内
            d.实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致
            e.泛型不同的引用不能相互赋值
            f.在编译时两个指定不同泛型的ArrayList,但是在运行时只有一个ArryList被加载到JVM当中
            g.如果泛型结构是一个抽象类或接口，则不可创建泛型类对象
            h.异常类和静态方法不能使用泛型
            i.泛型方法：
                格式：
                    [访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出异常
                （1）在方法中出现泛型结构，泛型参数与类的泛型参数没有任何关系，换句话说，泛型方法所属的类是不是泛型类都没有关系
                （2）泛型方法在调用时，指明了泛型参数的类型
                （3）可以声明为静态的（因为泛型参数实在调用方法时确定的，并非在实例化类时确定）
            j.通配符的使用
                对于?：
                    如List&lt;?&gt;:
                        添加：不能向其内部添加数据除了添加null之外(null是所有类型的成员)
                        获取：允许读取数据，可以用get()方法并使用其返回值，读取的数据类新为Object
                对于 ? extends A:
                    如G&lt;? extends A&gt;：可以作为G&lt;A&gt;和G&lt;B&gt;的父类的，其中B是A的子类
                对于 ? super A:
                    如G&lt;? super A&gt;：可以作为G&lt;A&gt;和G&lt;B&gt;的父类的，其中B是A的父类
                添加：可以向其添加允许范围内的对象</code></pre>
<hr>
<p>###IO流</p>
<pre><code>File类（声明再java.io包下 ）

    说明：
        File类的一个对象，代表一个文件或一个文件目录；在File类当中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作；如果需要读取或写入文件内容，必须使用IO流来完成；后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点 ”

    路径：
        在IDEA中，若没有声明绝对路径，此时其默认的相对路径在当前工程文件下，若使用的是JUnit中的单元测试方法测试，相对路径即为当前Module下。
        在eclipse中，则相对路径都在当前的Project下
        路径分隔符：
            windows：\\
            unix：/

    构造器：
        File(String filePath)
        File(String parentPath,String childPath)
        File(File parantFile,String childPath)

    常用方法：
        （1）String getAbsolutrPath()：获取绝对路径
        （2）String getPath()：获取路径
        （3）String getName()：获取名称
        （4）String gatParent()：获取上层文件目录路径。若无，返回null
        （5）long length()：获取文件长度(即：字节数)；不能获取目录的长度
        （6）long lastModified()：获取最后一次的修改时间，毫秒值
        （7）String[] list()：获取指定目录下的所有文件或者文件目录的名称数组
        （8）File[] listFiles()：获取定制目录下的所有文件或者文件目录的File数组 
        （9）Boolean ranameTo(File dest)：把文件重命名为指定的文件路径；需要file1在硬盘当中是存在的，且dest不能再硬盘当中存在

        （10）boolean isDirectory()：判断是否是文件目录
        （11）boolean isFile()：判断是否是文件
        （12）boolean exists()：判断是否存在
        （13）boolean canRead()：判断是否可读
        （14）boolean canWrite()：判断是否可写
        （15）boolean isHidden()：判断是否隐藏

        （16）boolean createNewFile()：创建文件；若文件存在，则不创建，返回false
        （17）boolean mkdir()：创建文件目录；如果文件目录存在，则不创建，如果此文件目录的上层目录不存在，也不创建(使用mkdirs就可以一并创建)；
            注意：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下
        （18）boolean delete()：删除文件或者文件夹
            注意：java中的删除不走回收站，同时，要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录


I/O流

    流的分类：
        （1）按操作的数据单位：字节流(8 bit--InputStream/OutputStream) 、 字符流(16 bit--Reader/Writer)
        （2）按数据流的流向：输入流(InputSreram\Reader) 、 输出流(OutputStream\Writer)
        （3）按流的角色：节点流 、 处理流

    使用：
        结点流(文件流)---&gt;FileInputStream/FileOutputStream/FileReader/FileWriter：
            1-对于文本文件(.txt/.java/.c/.cpp)，使用字符流处理；对于非文本文件(.jpg/.mp3/.mp4/.avi/.doc/.ppt)，使用字节流处理

            2-写入：
                （1）read()的理解：返回读入的一个字符，如果达到文件末尾，返回-1
                （2）异常处理：为了保证流资源一定可以执行关闭操作，需要使用try-catch-finally处理
                （3）读入文件一定要存在，否则会报异常FileNotFoundException

            3-输出：
                （1）对于输出操作，对应的File可以不存在的；如果不存在，在输出过程中会自动创建此文件
                （2）对于FileWriter的输出操作，可以指定输出内容是否覆盖原文件内容。
        处理流：
            1-缓冲流(处理流的一种)----&gt;BufrferedInputStream/BufferedOutputStream/BufferReader/BufferedWriter
                作用：提高了流的读取、写入的速度(内部提供了一个缓冲区)
                使用：
                    （1）造文件
                    （2）造流（先造节点流，后造缓冲流）
                    （3）使用完后，资源关闭(顺序是从外到内，当我们关闭外层流时，内层流也会自动关闭)

            2-转换流
                作用：提供了在字节流和字符流之间的转换
                使用：
                    InputStreanReader：将一个字节的输入流转换为字符的输入流(解码)
                    OuputStreamWriter：将一个字符的输出流转换为字节的输出流 (编码)
                注意：文件编码的方式，决定了解析时使用的字符集

            3-标准输入、输出流
                作用：
                    System.in：标准的输入流，默认从键盘输入
                    System.out：标准的输出流，默认从控制台输出
                使用：
                    System类的setIn(InputStream is)/setOut(PrintStream ps)方式重新指定输入和输出的

            4-打印流
                作用：实现将基本数据类型的数据格式转换为字符串输出
                使用：
                    PrintStream/PrintWriter 
                        功能：
                            （1）提供可一系列重载的print()和println()方法，用于多种数据类的输出
                            （2）上面两者的输出不会抛出IOException异常
                            （3）有自动的flush功能
                            （4）PrintStream打印的所有字符都使用平台的默认字符编码转化为字节，在需要写入字符而不是写入字节的情况下，应该使用PrintWriter类
                            （5）System.out返回的是PrintStream的实例

            5-数据流
                作用：更方便的操作java语言的基本数据类型和String的数据，用于读取和写出基本数据类型、String类的数据
                使用：主要通过DataOutputStream/DataIntputStream实现
                    注意：读取不同类型的数据的顺序要与当初写入文件时，保存的数据顺序一致

            6-对象流
                作用：用于存储和读取基本数据类型数据或对象的处理流，其强大之处在于可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来
                使用：
                    ObjectInputStream/ObjectOutputStream
                    （1）序列化：用ObjectOutputStream类保存基本数据或对象的机制
                            （1）该机制允许把内存当中的java对象转换成平台无关的二进制流
                            （2）可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原
                            （3）序列化是RMI(Remote Method Invoke - 远程方法调用)过程的参数和返回值都必须实现的机制，而RMI是JavaEE的基础；因此序列化机制是JavaEE
                            （4）要使某个对象支持可序列化，则必须让对象所属的类即其属性是可序列化的
                            注意：
                                为了让某个类是可序列化的，该类必须
                                    a.实现 Serializable/Externalizable 这两个接口之一，否则会抛出NotSerializableException异常；
                                    b.该类需要提供一个全局常量：serialVersionUID（其用来表明类的不同版本间的兼容性，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容）；如果类没有显式定义这个静态变量，它的值时Java在运行时环境根据类的内部细节自动生成的，若类的实例变量做了修改，则serialVersionUID可能发生变化
                    （2）反序列化：用ObjectInputStream类读取基本数据类型或对象的机制
                    注意：
                        ObjectInputStream和ObjectOutputStream不能序列化static和transient修饰的成员变量

            7-随机存取文件流(RandomAccessFile)
                作用：支持“随机访问”方式，程序可以直接跳到文件的任意地方来读、写文件；支持只访问文件的部分内容，可以向已存在的文件后追加内容
                使用：
                    （1）其直接继承于java.lang.Object类，实现了DataInput和DataOutput接口
                    （2）其既可以作为一个输入流，又可以作为一个输出流
                    （3）创建的RandomAccessFile类实例需要指定一个mode参数，该参数只当RandomAccessFile的访问模式：
                        --r：以只读方式打开
                        --rw：打开以便读取和写入
                        --rwd：打开以便读取和写入；同步文件内容的更新
                        --rws：打开以便读取和写入；同步文件内容和元数据的更新
                        注意：
                            a.如果模式为只读r，其是去读取一个已经存在的文件，如果读取的文件不存在，则会出现异常；如果是rw读写模式，当文件不存在时，则会去创建文件，如果存在则不创建
                            b.如果RandomAccessFile作为输出流时，如果写出的文件存在，则会对原有文件内容进行覆盖(默认情况下，从头覆盖)
                    （4）该类的对象包含一个记录指针，用以指示当前读写处的位置；其对象可以自由移动记录指针：
                        --long getFilePointer()：获取文件记录指针的当前位置
                        --void seek(long pos)：将文件记录指针定位到pos位置

NIO(New IO,Non-Blocking IO)
    说明：用于替代标准的Java IO API，其与原来的IO有同样作用和目的，但是使用方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作，NIO将以更高效的方式进行文件的读写操作

    使用：
    --java.nio.channels.Channel
        --FileChannel：处理本地文件
        --SocketChannel：TCP网络编程的客户端的Channel
        --ServerSocketChannel：TCP网络编程的服务器端的Channel
        --DataGramChannel：UDP网络编程中发送端和接收端的Channel

    （1）针对标准输入输出NIO
    （2）网络编程NIO</code></pre>
<p>###网络编程</p>
<pre><code>说明：直接或间接地通过网络协议与其他计算机实现数据交换，进行通讯        
要素：
    1-IP地址(InetAddress)
        --作用：唯一的表示Internet上计算机
        --本地回环地址：127.0.0.1
        --主机名：localhost
        --分类方式：
            方式1：
                --IPV4：4个字节组成，4个0-255，以点分十进制表示
                --IPV6：128位(16个字节)，写成8个无符号整数，每个整数用四个16禁止位表示，数之间用冒号(:)分开，如：3ffe:3201:1401:1280:c8ff:fe4d:db39:1984
            方式2：
                公用地址（万维网使用）/私有地址（局域网使用）
                注意：以192.168.开头就是私有地址

        --使用：java中使用InetAddress类代表IP
            --实例化：
                a.使用getByName(String host)，对其赋IP地址或域名
                b.使用getLocalHost()，生成本地的IP地址

    2-端口号
        --作用：标识正在计算机上运行的进程(程序)
        --格式：规定为一个16位的整数0~65535
        --分类：
            --公认端口：0~1023，被预先定义的服务通信占用
            --注册端口：1024~49151，分配给用户进程或应用进程
            --动态/私有端口：49152~65535
        --Socket：端口号与IP地址的组合得出的网络套接字

    3-网络协议
        --TCP协议(传输控制协议)/IP协议(网络互联协议)
            --IP协议是网络层的主要协议，支持网间互连的数据通信
            --TCP/IP协议模型形成了高效的四层体系结构（物理链路层、IP层、传输层和应用层）
            --协议要求：
                1.使用TCP协议钱，须简历TCP链接，形成数据通道
                2.传输前，采用“三次握手”方式，点对点通信，是可靠的
                3.TCP协议进行通信的两个应用进程：客户端、服务端
                4.在连接中可进行大数据量的传输
                5.传输完毕，需释放已建立的链接(&quot;四次挥手&quot;)，效率低
            --使用：
                --进程端：
                    1.创建Socket对象，指明服务器端的ip和端口号
                    2.获取一个输出流，用于输出数据
                    3.写出数据操作
                    4.资源关闭
                --服务器端：
                    1.创建服务器端的ServerSocket，指明自己的端口号
                    2.调用accept()表示接受来自于客户端的socket
                    3.获取输入流
                    4.读取输入流中的数据
                    5.关闭资源

        --UDP协议(用户数据报协议)
            --协议要求：
                1.将数据、源、目的封装成数据包，不需要建立连接
                2.每个数据报的大小限制在64K
                3.发送不管对方是否准备好，接受方收到也不确认，是不可靠的
                4.可以广播发送
                5.发送数据结束时无需释放资源，开销小，速度快
            --使用：
                1.DatagramSocket/DatagranPacket实现了基于UDP协议网络程序
                2.其通过数据报套接字DatagramSocket发送和接收系统不保证UDP数据报一定能够安全送到目的地，也不确定什么时候可以抵达
                3.DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号
                4.UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接
                --发送端

        --URL类 
            说明：统一资源定位符，表示Internet上某一资源的地址
            基本结构：&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表
                --参数列表格式：参数名=参数值&amp;参数名=参数值......</code></pre>
<p>###Java反射机制(Reflection)</p>
<pre><code>说明：
    反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法；加载完类后，在对内存的方法区中就产生了一个class类型的对象(一个类只有一个Class对象)，这个对象就包含了完整的类的结构信息，可以通过这个对象看到类的结构 

区别：
    正常方式：引入需要的“包类”名称---&gt;通过new实例化----&gt;取得实例化对象
    反射方式：实例化对象---&gt;getClass()方法---&gt;得到完整的“包类”名称 

java.lang.Class类（对应着加载到内存中的一个运行时类）
    类的加载过程：
        --程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)，接着使用java.exe命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，加载到内存中的类，称其为运行时类，此运行时类就作为Class的一个实例。
        --加载到内存中的运行时类，会缓存一定的时间，在此时间之内，可以通过不同的方式来获取此运行时类

    获取Class实例的方式：
        --调用运行时类的属性：class
        --通过运行时类的对象，调用getClass方法
        --调用Class的静态方法：forName(String classPath(绝对路径))
        --使用类的加载器(ClassLoader):
            --类加载器
                作用：
                    将class文件字节码内容加载到内存中，并将这些静态数据转换成方法风趣的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法去中类数据的访问入口
                类缓存：
                    标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载(缓存)一段时间；不过JVM垃圾回收机制可以回收这些Class对象
                分类：
                    --引导类加载器：
                        用C++编写的，是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库，该加载器无法直接获取
                    --扩展类加载器：
                        负责jre/lib/ext目标下的jar包或-D java.ext.dirs指定目录下的jar包装入工作库
                    --系统类加载器：
                        负责java -classpath 或 -D java.class.path 所指的目录下的类与jar包装入工作，是最常用的加载器
                    注意：
                        --对于自定义类，使用系统类加载器进行加载
                        --调用系统加载的getParent()，获取扩展类加载器
                        --调用扩展类加载的getParent()，无法获取引导类加载器

    读取配置文件：
        方式：
            (1)此时的文件默认在当前的module下
                Properties pros = new Properties();
                FileInputStream fis = new FileInputStream(配置文件)
                pros.load(fis);
            (2)使用ClassLoader：此时配置文件默认在当前module的src下
                ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
                InputStream is = classLoader.getResourceAsStream(配置文件)
                pros.load(is);

    常用方法：
        --newInstance()：调用此方法，创建对应的运行时类的对象；内部调用了运行时类的空参构造器
            注意：
                （1）创建运行时类的对象，要求：
                    --运行时类必须提供空参的构造器
                    --空参的构造器的访问权限得够，通常设置为public
                （2）javabean中要求提供一个public的空参构造器，原因：
                    --便于通过反射，创建运行时类的对象
                    --便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器 

        --getFields()：获取当前运行时类及其父类中声明为public访问权限的属性
        --getDelaredFields()：获取当前运行时类中声明的所有属性(不包含父类中声明的属性)
        --getMethods()：获取当前运行时类及其父类中声明为public访问权限的方法
        --getDelaredMethods()：获取当前运行时类中声明的所有方法(不包含父类中声明的方法)
        --getConstructors()：获取当前运行时类中声明的public的构造器
        --getDelaredConstructors()：获取当前运行时类中声明的所有的构造器
        --getGenericSuperclass()：获取运行时类的带泛型的父类的泛型
        --getDeclaredConstructor()：调用构造器
        --getPackage()：获取运行时类所在的包

        调用运行时类中的指定属性：
            --创建运行时类的对象
            --通过getDeclaredField(String fieldName)：获取运行时类中指定变量名的属性
            --为了保证当前属性是可访问的，使用setAccessible()置为true
            --获取、修改指定对象的此属性值

        获取指定的某个方法：
            --创建运行时类的对象
            --通过getDelaredMethod(获取的方法名称，获取方法的形参列表)
            --为了保证当前属性是可访问的，使用setAccessible()置为true
            --调用方法invoke(方法的调用者，给方法形参赋值的实参 )

动态代理：

    说明：是指客户通过对代理类来调用其他对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象

    使用场景：
        --调试
        --远程方法调用

    区别：
        --静态代理：代理类与被代理类在编译期间，就确定下来了

    实行方法：
        --创建接口与被代理类
        --创建InvocationHandler的接口类，重写invoke函数
        --创建代理类（每次调用代理类时，会跳转到接口类的invoke方法，从而调用被代理类当中的方法）

    优点：相比于静态代理，其抽象角色中(接口)声明的所有方法都被转移到调用处理器一个集中的方法中处理，可以更加灵活和统一的处理众多的方法</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/27/Java/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" data-id="ckp6d1bdg000ktgub9axu65xw" data-title="Java高级编程" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/06/Java/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java类库与基本操作
        
      </div>
    </a>
  
  
    <a href="/2021/03/22/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">设计模式</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/27/Other/README/">计算机网络——网络层</a>
          </li>
        
          <li>
            <a href="/2021/05/26/ComputerNetWork/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%945%E4%BC%A0%E8%BE%93%E5%B1%82/">计算机网络——传输层</a>
          </li>
        
          <li>
            <a href="/2021/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%944%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络——网络层</a>
          </li>
        
          <li>
            <a href="/2021/05/20/ComputerNetWork/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%944%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络——网络层</a>
          </li>
        
          <li>
            <a href="/2021/05/14/ComputerNetWork/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E2%80%943%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/">计算机网络——数据链路层</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>