<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Java高级编程 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="#高级编程##基础知识1.进程    定义：是程序依次执行过程，或正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程—–生命周期    内容：        （1）进程作为资源分配的单位，系统在运行时回味每个进程分配不同的内存区域  2.线程 定义：是一个程序内部的一条执行路径  内容：     （1）线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器，线程切换的开">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高级编程">
<meta property="og:url" content="http://example.com/2021/03/27/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="#高级编程##基础知识1.进程    定义：是程序依次执行过程，或正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程—–生命周期    内容：        （1）进程作为资源分配的单位，系统在运行时回味每个进程分配不同的内存区域  2.线程 定义：是一个程序内部的一条执行路径  内容：     （1）线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器，线程切换的开">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-27T14:37:01.185Z">
<meta property="article:modified_time" content="2021-04-07T06:12:18.373Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-java高级编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/27/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-03-27T14:37:01.185Z" itemprop="datePublished">2021-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Java高级编程
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="高级编程"><a href="#高级编程" class="headerlink" title="#高级编程"></a>#高级编程</h2><p>##基础知识<br>1.进程<br>    定义：是程序依次执行过程，或正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程—–生命周期<br>    内容：<br>        （1）进程作为资源分配的单位，系统在运行时回味每个进程分配不同的内存区域 </p>
<p>2.线程</p>
<pre><code>定义：是一个程序内部的一条执行路径

内容：
    （1）线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器，线程切换的开销小
    （2）一个进程中的多个线程共享相同的内存单元/内存地址空间-&gt;它们从同一个堆中分配对象，可以访问相同的变量和对象


生命周期：
    ![avatar](D:/ComputerUse/blog/img/live.jpg)

多线程的创建：
    （1）方式一：继承于Thread类
        使用：
            a.创建一个Thread类的子类
            b.重写Thread类的run()----&gt;将此线程执行的操作声明在run()中
            c.创建Thread类的子类对象
            d.通过此对象调用start()：该函数会启动当前线程，并调用当前线程的run()

    （2）方式二：实现Runnable接口------&gt;该方法的实现没有类单继承的局限性，更适合用来处理多个线程有共享数据的情况
        使用：
            a.创建一个实现了Runnable接口的类
            b.实现类去实现Runnable中的抽象方法：run()
            c.创建实现类的对象
            d.将此对象作为参数传递到Thread类中的构造器中，创建Thread类的对象
            e.通过Thread类的对象调用start()：启动线程，然后调用当前线程的run()-----&gt;调用了Runnable类型的target的run()

    （3）方式三：实现Callable接口
        使用：
            a.创建一个实现Callable的实现类
            b.实现call方法，将此线程需要执行的操作声明在call()中
            c.创建Callable接口实现类的对象
            d.将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象
            e.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()
            f.获取Callable中Call方法中的返回值------&gt;可以通过get()得到返回值
        注：
            a.其call()方法，可以有返回值
            b.方法可以抛出异常，被外面的操作捕获，获取异常信息 
            c.支持泛型的返回值
            d.需要借助FutureTask类

    （4）方式四：使用线程池
            作用：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中，可以避免频繁创建销毁、实现重复里哟
            优点：提高响应速度、降低资源消耗、便于线程管理
            使用：
                a.提供指定线程数量的线程池：ExexcutorService service = Exectors.newFixedThreadPool( &lt;!-- 线程数量 --&gt; )
                b.执行指定线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象
                    service.excute( &lt;!-- 实现Runnable接口类的对象 --&gt; )
                    service.submit( &lt;!-- 实现Callable接口类 的对象 --&gt; )
                c.关闭线程池：service.shutdown()
            注：可以通过强制类型转换的方式，将ExecutorService转换成ThreadPoolExecutor类型对象，对线程池的属性进行设置


Thread类常见的方法：
    start()：启动线程，并执行run()方法
    run()：线程在被调度时执行的操作
    String getName()：返回线程的名称
    void setName(String name)：设置该线程的名称
    static Thread currentThread()：返回当前线程，在Thread子类中就是this，通常用于主线程和Runnable实现类
    yeild()：释放当前CPU的执行权
    join()：在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到join的线程执行完，线程a才结束阻塞状态
    stop()：强制线程生命周期结束，不推荐使用
    boolean isAlive()：返回boolean，判断线程是否还活着
    sleep(long millitime)：让当前线程阻塞指定的millitime毫秒
    getPriority()：返回线程优先级
    setPriority(int newPriority)：改变线程的优先级

解决线程的安全问题
    同步机制：
        （1）方式一：同步代码块
                使用：
                    synchronized(同步监视器)&#123;
                        &lt;!-- 需要被同步的代码(即操作共享数据的代码) --&gt;
                    &#125;
                注：
                    a.同步监视器：俗称，“锁”。任何一个类的对象，都可以充当锁。在以上方法中，多个线程必须要共用同一把锁
                    b.在实现Runnable接口创建多线程方式中，可以考虑使用this充当同步监视器

        （2）方式二：同步方法
                使用：通过 synchronized+方法 的来使用
                注：
                    a.同步方法仍然设计到同步监视器，只是不需要我们显式的声明
                    b.非静态的同步方法的同步监视器是this，静态的同步方法的同步监视器是当前类的本身

    Lock锁：
        使用：通过生成ReentrantLock类的对象，手动的启动同步(Lock())，同时结束同步也需要手动的实现(unlock())
        注：
            a.Lock是显式锁，需要进行手动的开启和关闭，synchronized是隐式锁，除了作用域自动释放
            b.Lock只有代码块锁，synchronized有代码块锁和方法所
            c.使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性

死锁：
    定义：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己所需要的同步资源，就形成了线程的死锁。出现死锁后，不会出现异常、提示，只是所有的线程都处于阻塞状态，无法继续

线程通信方法：
    方法：
        wait()：执行此方法，当前线程就进入阻塞状态
        notify()：执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，会优先唤醒优先级高的线程
        notifyAll()：执行此方法，会唤醒所有被wait的一个线程
    注：
        a.以上三个方法必须使用在同步代码块或同步方法中，同时其调用者必须是同步代码块或同步方法当中的同步监视器，否则会出现IllegalMonitorStateException异常
        b.上面三个方法是定义在java.lang.Object类中</code></pre>
<p>3.并行与并发<br>    定义：并行指的是多个CPU同时执行多个任务，并发指的是一个CPU(采用时间片)同时执行多个任务</p>
<p>###枚举类与注解<br>1.枚举类<br>    包：定义的枚举类默认继承于java.lang.Enum<br>    说明：<br>        a.类的对象只有有限个，确定的。当需要定义一组常量时，强烈建议使用枚举类<br>        b.如果枚举类当中只有一个对象，则可以作为单例模式的实现方式<br>        c.定义枚举类：<br>            （1）jdk5.0之前，自定义枚举类<br>                1-声明对象的属性权限为：private final<br>                2-私有化构造器，并给对象属性私有化<br>                3-提供当前枚举类的多个对象</p>
<pre><code>        （2）jdk5.0，可以使用enum关键字定义枚举类
            1-提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束
    d.使用enum关键字定义的枚举类实现接口：当我们需要在调用指定枚举类时进行不同的操作，则在枚举对象后进行重写

常用方法：
    valueOf()：返回枚举类型的对象数组，该方法可以很方便的遍历所有的枚举值。也可以给其赋值一个字符串，可以索引指定名字的枚举对象，要求字符串必须是枚举对象的&quot;名字&quot;，否则会运行异常
    toString()：返回当前枚举对象常量名称</code></pre>
<p>2.注解<br>    说明：<br>        是代码里的特殊标记，这些标记可以在编译、类加载、运行时被读取，并执行相应的处理。可以用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在Annotation的”name=value”对中</p>
<pre><code>使用示例：
    a.使用Annotation时要在前面增加@符号，并把该Annotation当成一个修饰符使用
    b.在编译时进行格式检查（JDK内置的三个基本注解Override\Deprecated\SuppressWarnings）
    c.跟踪代码依赖性，实现替代配置文件功能
    d.spring框架中关于“事务”的管理

自定义注解：自定义注解必须配上注解的信息处理流程(使用反射)才有意义
    a.定义新的Annotation类型使用@interface关键字
    b.内部成员，通常使用value表示，可以指定成员的默认值，使用default定义。如果自定义注解没有成员，表示是一个标识作用。

元注解：    
    说明：用于修饰其他Annotation定义，对现有的注解进行解释说明的注解
    使用：
        Retention：只能用于修饰一个Annotation定义，用于指定该Annotation的生命周期---》SOURCE\CLASS(默认行为)\RUNTIME(能通过反射)
        Target：用于指定被修饰的Annotation能用于修饰哪些程序元素
        Documented：用于指定那个被盖院Annotation修饰的Annotation类将被javadoc工具提取成文档。默认情况下，javadoc是不包括注解的
        Inherited：被它修饰的Annotation将具有继承性

jdk8中注解的新特性
    可重复注解：@Repeatable
    类型注解：
        ElementType.TYPE_PARAMETER：表示该注解能写在类型变量的声明语句中（如：泛型声明）
        ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中</code></pre>
<p>###java集合</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/27/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/" data-id="ckn729voi0004m8ub0mv85tff" data-title="Java高级编程" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/06/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java类库与基本操作
        
      </div>
    </a>
  
  
    <a href="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">设计模式</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/06/java%E7%AE%80%E5%8D%95%E7%B1%BB%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/">Java类库与基本操作</a>
          </li>
        
          <li>
            <a href="/2021/03/27/java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B/">Java高级编程</a>
          </li>
        
          <li>
            <a href="/2021/03/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/2021/03/15/STL/">STL</a>
          </li>
        
          <li>
            <a href="/2021/03/15/algorithm/">algorithm</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>